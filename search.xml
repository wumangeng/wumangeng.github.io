<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Netty学习笔记</title>
      <link href="/2021/10/05/netty/"/>
      <url>/2021/10/05/netty/</url>
      
        <content type="html"><![CDATA[<h1 id="第-1-章-Netty-介绍和应用场景"><a href="#第-1-章-Netty-介绍和应用场景" class="headerlink" title="第 1 章 Netty 介绍和应用场景"></a>第 1 章 Netty 介绍和应用场景</h1><h2 id="1-1-本课程学习要求"><a href="#1-1-本课程学习要求" class="headerlink" title="1.1 本课程学习要求"></a>1.1 本课程学习要求</h2><ol><li>本课程不适用于 <code>0</code> 基础的学员。</li><li>要求已经掌握了 <code>Java</code> 编程，主要技术构成：<code>Java OOP</code> 编程、<code>Java</code> 多线程编程、<code>Java IO</code> 编程、<code>Java</code> 网络编程、常用的 <code>Java</code> 设计模式（比如观察者模式，命令模式，职责链模式）、常用的数据结构（比如链表）。</li><li>本课程的《<code>Netty</code> 核心源码剖析章节》要求学员最好有项目开发和阅读源码的经历。</li></ol><h2 id="1-2-Netty-的介绍"><a href="#1-2-Netty-的介绍" class="headerlink" title="1.2 Netty 的介绍"></a>1.2 Netty 的介绍</h2><ol><li><code>Netty</code> 是由 <code>JBOSS</code> 提供的一个 <code>Java</code> 开源框架，现为 <code>Github</code> 上的独立项目。</li><li><code>Netty</code> 是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络 <code>IO</code> 程序。</li><li><code>Netty</code> 主要针对在 <code>TCP</code> 协议下，面向 <code>Client</code> 端的高并发应用，或者 <code>Peer-to-Peer</code> 场景下的大量数据持续传输的应用。</li><li><code>Netty</code> 本质是一个 <code>NIO</code> 框架，适用于服务器通讯相关的多种应用场景。</li><li>要透彻理解 <code>Netty</code>，需要先学习 <code>NIO</code>，这样我们才能阅读 <code>Netty</code> 的源码。</li></ol><h2 id="1-3-Netty-的应用场景"><a href="#1-3-Netty-的应用场景" class="headerlink" title="1.3 Netty 的应用场景"></a>1.3 Netty 的应用场景</h2><h3 id="1-3-1-互联网行业"><a href="#1-3-1-互联网行业" class="headerlink" title="1.3.1 互联网行业"></a>1.3.1 互联网行业</h3><ol><li>互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 <code>RPC</code> 框架必不可少，<code>Netty</code> 作为异步高性能的通信框架，往往作为基础通信组件被这些 <code>RPC</code> 框架使用。</li><li>典型的应用有：阿里分布式服务框架 <code>Dubbo</code> 的 <code>RPC</code> 框 架使用 <code>Dubbo</code> 协议进行节点间通信，<code>Dubbo</code> 协议默认使用 <code>Netty</code> 作为基础通信组件，用于实现各进程节点之间的内部通信。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_01.png" alt="img"></p><h3 id="1-3-2-游戏行业"><a href="#1-3-2-游戏行业" class="headerlink" title="1.3.2 游戏行业"></a>1.3.2 游戏行业</h3><ol><li>无论是手游服务端还是大型的网络游戏，<code>Java</code> 语言得到了越来越广泛的应用。</li><li><code>Netty</code> 作为高性能的基础通信组件，提供了 <code>TCP/UDP</code> 和 <code>HTTP</code> 协议栈，方便定制和开发私有协议栈，账号登录服务器。</li><li>地图服务器之间可以方便的通过 <code>Netty</code> 进行高性能的通信。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_02.png" alt="img"> <img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_03.png" alt="img"></p><h3 id="1-3-3-大数据领域"><a href="#1-3-3-大数据领域" class="headerlink" title="1.3.3 大数据领域"></a>1.3.3 大数据领域</h3><ol><li>经典的 <code>Hadoop</code> 的高性能通信和序列化组件 <code>Avro</code> 的 <code>RPC</code> 框架，默认采用 <code>Netty</code> 进行跨界点通信。</li><li>它的 <code>NettyService</code> 基于 <code>Netty</code> 框架二次封装实现。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_04.png" alt="img"></p><h3 id="1-3-4-其它开源项目使用到-Netty"><a href="#1-3-4-其它开源项目使用到-Netty" class="headerlink" title="1.3.4 其它开源项目使用到 Netty"></a>1.3.4 其它开源项目使用到 Netty</h3><p>网址：<a href="https://netty.io/wiki/related-projects.html">https://netty.io/wiki/related-projects.html</a></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter01/chapter01_05.png" alt="img"></p><h2 id="1-4-Netty-的学习资料参考"><a href="#1-4-Netty-的学习资料参考" class="headerlink" title="1.4 Netty 的学习资料参考"></a>1.4 Netty 的学习资料参考</h2><p><a href="https://item.jd.com/12070975.html"><img src="https://img10.360buyimg.com/n1/jfs/t5227/173/1793618117/453810/1253bd90/59141c1dN7a93c127.jpg" alt="img"></a> <a href="https://item.jd.com/11681556.html"><img src="https://img11.360buyimg.com/n1/jfs/t1516/258/38352851/215555/68f629a5/555080b2Ne6cbf9e3.jpg" alt="img"></a></p><h1 id="第-2-章-Java-BIO-编程"><a href="#第-2-章-Java-BIO-编程" class="headerlink" title="第 2 章 Java BIO 编程"></a>第 2 章 Java BIO 编程</h1><h2 id="2-1-I-O-模型"><a href="#2-1-I-O-模型" class="headerlink" title="2.1 I/O 模型"></a>2.1 I/O 模型</h2><h3 id="2-1-1-模型基本说明"><a href="#2-1-1-模型基本说明" class="headerlink" title="2.1.1 模型基本说明"></a>2.1.1 模型基本说明</h3><ol><li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li><li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li><li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li></ol><img src="https://dongzl.github.io/netty-handbook/_media/chapter02/chapter02_01.png" alt="img " style="zoom:50%;" /><ol><li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter02/chapter02_02.png" alt="img"></p><ol><li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li><li>我们依次展开讲解。</li></ol><h2 id="2-2-BIO、NIO、AIO-使用场景分析"><a href="#2-2-BIO、NIO、AIO-使用场景分析" class="headerlink" title="2.2 BIO、NIO、AIO 使用场景分析"></a>2.2 BIO、NIO、AIO 使用场景分析</h2><ol><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li><li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li><li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li></ol><h2 id="2-3-Java-BIO-基本介绍"><a href="#2-3-Java-BIO-基本介绍" class="headerlink" title="2.3 Java BIO 基本介绍"></a>2.3 Java BIO 基本介绍</h2><ol><li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li><li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li></ol><h2 id="2-4-Java-BIO-工作机制"><a href="#2-4-Java-BIO-工作机制" class="headerlink" title="2.4 Java BIO 工作机制"></a>2.4 Java BIO 工作机制</h2><img src="https://dongzl.github.io/netty-handbook/_media/chapter02/chapter02_03.png" alt="img " style="zoom:50%;" /><p>对 <code>BIO</code> 编程流程的梳理</p><ol><li>服务器端启动一个 <code>ServerSocket</code>。</li><li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li><li>如果有响应，客户端线程会等待请求结束后，在继续执行。</li></ol><h2 id="2-5-Java-BIO-应用实例"><a href="#2-5-Java-BIO-应用实例" class="headerlink" title="2.5 Java BIO 应用实例"></a>2.5 Java BIO 应用实例</h2><p>实例说明：</p><ol><li>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</li><li>要求使用线程池机制改善，可以连接多个客户端。</li><li>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</li><li>代码演示：</li></ol><pre><code class="java">package com.demo.bio;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class BIOServer &#123;    public static void main(String[] args) throws Exception &#123;        //线程池机制        //思路        //1. 创建一个线程池        //2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        //创建ServerSocket        ServerSocket serverSocket = new ServerSocket(6666);        System.out.println(&quot;服务器启动了&quot;);        while (true) &#123;            System.out.println(&quot;线程信息id = &quot; + Thread.currentThread().getId() + &quot;名字 = &quot; + Thread.currentThread().getName());            //监听，等待客户端连接            System.out.println(&quot;等待连接....&quot;);            final Socket socket = serverSocket.accept();            System.out.println(&quot;连接到一个客户端&quot;);            //就创建一个线程，与之通讯(单独写一个方法)            newCachedThreadPool.execute(new Runnable() &#123;                public void run() &#123;//我们重写                    //可以和客户端通讯                    handler(socket);                &#125;            &#125;);        &#125;    &#125;    //编写一个handler方法，和客户端通讯    public static void handler(Socket socket) &#123;        try &#123;            System.out.println(&quot;线程信息id = &quot; + Thread.currentThread().getId() + &quot;名字 = &quot; + Thread.currentThread().getName());            byte[] bytes = new byte[1024];            //通过socket获取输入流            InputStream inputStream = socket.getInputStream();            //循环的读取客户端发送的数据            while (true) &#123;                System.out.println(&quot;线程信息id = &quot; + Thread.currentThread().getId() + &quot;名字 = &quot; + Thread.currentThread().getName());                System.out.println(&quot;read....&quot;);                int read = inputStream.read(bytes);                if (read != -1) &#123;                    System.out.println(new String(bytes, 0, read));//输出客户端发送的数据                &#125; else &#123;                    break;                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            System.out.println(&quot;关闭和client的连接&quot;);            try &#123;                socket.close();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;</code></pre><h2 id="2-6-Java-BIO-问题分析"><a href="#2-6-Java-BIO-问题分析" class="headerlink" title="2.6 Java BIO 问题分析"></a>2.6 Java BIO 问题分析</h2><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li></ol><h1 id="第-3-章-NIO-编程"><a href="#第-3-章-NIO-编程" class="headerlink" title="第 3 章 NIO 编程"></a>第 3 章 NIO 编程</h1><h2 id="3-1-NIO-基本介绍"><a href="#3-1-NIO-基本介绍" class="headerlink" title="3.1 NIO 基本介绍"></a>3.1 NIO 基本介绍</h2><ol><li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong> ，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li><li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li><li><code>NIO</code> 有三大核心部分: <strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li><li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li><li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li><li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li><li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li><li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li></ol><pre><code class="java">import java.nio.IntBuffer;public class BasicBuffer &#123;    public static void main(String[] args) &#123;        //举例说明 Buffer 的使用(简单说明)        //创建一个 Buffer，大小为 5，即可以存放 5 个 int        IntBuffer intBuffer = IntBuffer.allocate(5);        //向buffer存放数据        //intBuffer.put(10);        //intBuffer.put(11);        //intBuffer.put(12);        //intBuffer.put(13);        //intBuffer.put(14);        for (int i = 0; i &lt; intBuffer.capacity(); i++) &#123;            intBuffer.put(i * 2);        &#125;        //如何从 buffer 读取数据        //将 buffer 转换，读写切换(!!!)        intBuffer.flip();        while (intBuffer.hasRemaining()) &#123;            System.out.println(intBuffer.get());        &#125;    &#125;&#125;</code></pre><h2 id="3-2-NIO-和-BIO-的比较"><a href="#3-2-NIO-和-BIO-的比较" class="headerlink" title="3.2 NIO 和 BIO 的比较"></a>3.2 NIO 和 BIO 的比较</h2><ol><li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li><li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li><li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li></ol><h2 id="3-3-NIO-三大核心原理示意图"><a href="#3-3-NIO-三大核心原理示意图" class="headerlink" title="3.3 NIO 三大核心原理示意图"></a>3.3 NIO 三大核心原理示意图</h2><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_01.png" alt="img " style="zoom:50%;" /><ol><li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li><li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li><li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li><li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li><li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li><li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li><li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li></ol><h2 id="3-4-缓冲区（Buffer）"><a href="#3-4-缓冲区（Buffer）" class="headerlink" title="3.4 缓冲区（Buffer）"></a>3.4 缓冲区（Buffer）</h2><h3 id="3-4-1-基本介绍"><a href="#3-4-1-基本介绍" class="headerlink" title="3.4.1 基本介绍"></a>3.4.1 基本介绍</h3><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_02.png" alt="img " style="zoom:50%;" /><h3 id="3-4-2-Buffer-类及其子类"><a href="#3-4-2-Buffer-类及其子类" class="headerlink" title="3.4.2 Buffer 类及其子类"></a>3.4.2 Buffer 类及其子类</h3><ol><li><p>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系：</p><blockquote><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul></blockquote></li><li><p><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</p></li></ol><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_05.png" alt="img " style="zoom:80%;" /><ol><li><code>Buffer</code> 类相关方法一览</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_06.png" alt="img"></p><h3 id="3-4-3-ByteBuffer"><a href="#3-4-3-ByteBuffer" class="headerlink" title="3.4.3 ByteBuffer"></a>3.4.3 ByteBuffer</h3><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_07.png" alt="img"></p><h2 id="3-5-通道（Channel）"><a href="#3-5-通道（Channel）" class="headerlink" title="3.5 通道（Channel）"></a>3.5 通道（Channel）</h2><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p><p>常见的 Channel 有</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h2 id="3-6-基本介绍"><a href="#3-6-基本介绍" class="headerlink" title="3.6 基本介绍"></a>3.6 基本介绍</h2><ol><li>NIO 的通道类似于流，但有些区别如下：<ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul></li><li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li><li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li><li>图示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_08.png" alt="img"></p><h3 id="3-6-1-FileChannel-类"><a href="#3-6-1-FileChannel-类" class="headerlink" title="3.6.1 FileChannel 类"></a>3.6.1 FileChannel 类</h3><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p><ul><li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li><li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li><li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li><li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li></ul><h3 id="3-6-2-应用实例1-本地文件写数据"><a href="#3-6-2-应用实例1-本地文件写数据" class="headerlink" title="3.6.2 应用实例1 - 本地文件写数据"></a>3.6.2 应用实例1 - 本地文件写数据</h3><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li><li>文件不存在就创建</li><li>代码演示</li></ol><pre><code class="java">import java.io.FileOutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel01 &#123;    public static void main(String[] args) throws Exception &#123;        String str = &quot;hello&quot;;        //创建一个输出流 -&gt; channel        FileOutputStream fileOutputStream = new FileOutputStream(&quot;d:\\file01.txt&quot;);        //通过 fileOutputStream 获取对应的 FileChannel        //这个 fileChannel 真实类型是 FileChannelImpl        FileChannel fileChannel = fileOutputStream.getChannel();        //创建一个缓冲区 ByteBuffer        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        //将 str 放入 byteBuffer        byteBuffer.put(str.getBytes());        //对 byteBuffer 进行 flip        byteBuffer.flip();        //将 byteBuffer 数据写入到 fileChannel        fileChannel.write(byteBuffer);        fileOutputStream.close();    &#125;&#125;</code></pre><h3 id="3-6-3-应用实例2-本地文件读数据"><a href="#3-6-3-应用实例2-本地文件读数据" class="headerlink" title="3.6.3 应用实例2 - 本地文件读数据"></a>3.6.3 应用实例2 - 本地文件读数据</h3><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li><li>假定文件已经存在</li><li>代码演示</li></ol><pre><code class="java">import java.io.File;import java.io.FileInputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel02 &#123;    public static void main(String[] args) throws Exception &#123;        //创建文件的输入流        File file = new File(&quot;d:\\file01.txt&quot;);        FileInputStream fileInputStream = new FileInputStream(file);                //通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl        FileChannel fileChannel = fileInputStream.getChannel();                //创建缓冲区        ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length());                //将通道的数据读入到 Buffer        fileChannel.read(byteBuffer);                //将 byteBuffer 的字节数据转成 String        System.out.println(new String(byteBuffer.array()));        fileInputStream.close();    &#125;&#125;</code></pre><h3 id="3-6-4-应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#3-6-4-应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="3.6.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>3.6.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</h3><p>实例要求：</p><ol><li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li><li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li><li>代码演示</li></ol><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_09.png" alt="img " style="zoom:50%;" /><pre><code class="java">import java.io.FileInputStream;import java.io.FileOutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel03 &#123;    public static void main(String[] args) throws Exception &#123;        FileInputStream fileInputStream = new FileInputStream(&quot;1.txt&quot;);        FileChannel fileChannel01 = fileInputStream.getChannel();        FileOutputStream fileOutputStream = new FileOutputStream(&quot;2.txt&quot;);        FileChannel fileChannel02 = fileOutputStream.getChannel();        ByteBuffer byteBuffer = ByteBuffer.allocate(512);                while (true) &#123; //循环读取            //这里有一个重要的操作，一定不要忘了            /*            public final Buffer clear() &#123;                position = 0;                limit = capacity;                mark = -1;                return this;            &#125;            */            byteBuffer.clear(); //清空 buffer            int read = fileChannel01.read(byteBuffer);            System.out.println(&quot;read = &quot; + read);            if (read == -1) &#123; //表示读完                break;            &#125;            //将 buffer 中的数据写入到 fileChannel02--2.txt            byteBuffer.flip();            fileChannel02.write(byteBuffer);        &#125;        //关闭相关的流        fileInputStream.close();        fileOutputStream.close();    &#125;&#125;</code></pre><h3 id="3-6-5-应用实例4-拷贝文件-transferFrom-方法"><a href="#3-6-5-应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="3.6.5 应用实例4 - 拷贝文件 transferFrom 方法"></a>3.6.5 应用实例4 - 拷贝文件 transferFrom 方法</h3><ol><li>实例要求：</li><li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li><li>拷贝一张图片</li><li>代码演示</li></ol><pre><code class="java">import java.io.FileInputStream;import java.io.FileOutputStream;import java.nio.channels.FileChannel;public class NIOFileChannel04 &#123;    public static void main(String[] args) throws Exception &#123;        //创建相关流        FileInputStream fileInputStream = new FileInputStream(&quot;d:\\a.jpg&quot;);        FileOutputStream fileOutputStream = new FileOutputStream(&quot;d:\\a2.jpg&quot;);                //获取各个流对应的 FileChannel        FileChannel sourceCh = fileInputStream.getChannel();        FileChannel destCh = fileOutputStream.getChannel();        //使用 transferForm 完成拷贝        destCh.transferFrom(sourceCh, 0, sourceCh.size());        //关闭相关通道和流        sourceCh.close();        destCh.close();        fileInputStream.close();        fileOutputStream.close();    &#125;&#125;</code></pre><h3 id="3-6-6-关于-Buffer-和-Channel-的注意事项和细节"><a href="#3-6-6-关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="3.6.6 关于 Buffer 和 Channel 的注意事项和细节"></a>3.6.6 关于 Buffer 和 Channel 的注意事项和细节</h3><ol><li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li></ol><pre><code class="java">import java.nio.ByteBuffer;public class NIOByteBufferPutGet &#123;    public static void main(String[] args) &#123;                //创建一个 Buffer        ByteBuffer buffer = ByteBuffer.allocate(64);        //类型化方式放入数据        buffer.putInt(100);        buffer.putLong(9);        buffer.putChar(&#39;尚&#39;);        buffer.putShort((short) 4);        //取出        buffer.flip();                System.out.println();                System.out.println(buffer.getInt());        System.out.println(buffer.getLong());        System.out.println(buffer.getChar());        System.out.println(buffer.getShort());    &#125;&#125;</code></pre><ol><li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li></ol><pre><code class="java">import java.nio.ByteBuffer;public class ReadOnlyBuffer &#123;    public static void main(String[] args) &#123;        //创建一个 buffer        ByteBuffer buffer = ByteBuffer.allocate(64);        for (int i = 0; i &lt; 64; i++) &#123;            buffer.put((byte) i);        &#125;        //读取        buffer.flip();        //得到一个只读的 Buffer        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();        System.out.println(readOnlyBuffer.getClass());        //读取        while (readOnlyBuffer.hasRemaining()) &#123;            System.out.println(readOnlyBuffer.get());        &#125;        readOnlyBuffer.put((byte) 100); //ReadOnlyBufferException    &#125;&#125;</code></pre><ol><li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li></ol><pre><code class="java">import java.io.RandomAccessFile;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;/** * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次 */public class MappedByteBufferTest &#123;    public static void main(String[] args) throws Exception &#123;        RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);        //获取对应的通道        FileChannel channel = randomAccessFile.getChannel();        /**         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式         * 参数 2：0：可以直接修改的起始位置         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存         * 可以直接修改的范围就是 0-5         * 实际类型 DirectByteBuffer         */        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 5);        mappedByteBuffer.put(0, (byte) &#39;H&#39;);        mappedByteBuffer.put(3, (byte) &#39;9&#39;);        mappedByteBuffer.put(5, (byte) &#39;Y&#39;);//IndexOutOfBoundsException        randomAccessFile.close();        System.out.println(&quot;修改成功~~&quot;);    &#125;&#125;</code></pre><ol><li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li></ol><pre><code class="java">import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Arrays;/** * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散] * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读 */public class ScatteringAndGatheringTest &#123;    public static void main(String[] args) throws Exception &#123;                //使用 ServerSocketChannel 和 SocketChannel 网络        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = new InetSocketAddress(7000);        //绑定端口到 socket，并启动        serverSocketChannel.socket().bind(inetSocketAddress);        //创建 buffer 数组        ByteBuffer[] byteBuffers = new ByteBuffer[2];        byteBuffers[0] = ByteBuffer.allocate(5);        byteBuffers[1] = ByteBuffer.allocate(3);        //等客户端连接 (telnet)        SocketChannel socketChannel = serverSocketChannel.accept();        int messageLength = 8; //假定从客户端接收 8 个字节        //循环的读取        while (true) &#123;            int byteRead = 0;            while (byteRead &lt; messageLength) &#123;                long l = socketChannel.read(byteBuffers);                byteRead += l; //累计读取的字节数                System.out.println(&quot;byteRead = &quot; + byteRead);                //使用流打印,看看当前的这个 buffer 的 position 和 limit                Arrays.asList(byteBuffers).stream().map(buffer -&gt; &quot;position = &quot; + buffer.position() + &quot;, limit = &quot; + buffer.limit()).forEach(System.out::println);            &#125;            //将所有的 buffer 进行 flip            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());            //将数据读出显示到客户端            long byteWirte = 0;            while (byteWirte &lt; messageLength) &#123;                long l = socketChannel.write(byteBuffers);//                byteWirte += l;            &#125;                        //将所有的buffer进行clear            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;                buffer.clear();            &#125;);                        System.out.println(&quot;byteRead = &quot; + byteRead + &quot;, byteWrite = &quot; + byteWirte + &quot;, messagelength = &quot; + messageLength);        &#125;    &#125;&#125;</code></pre><h2 id="3-7-Selector（选择器）"><a href="#3-7-Selector（选择器）" class="headerlink" title="3.7 Selector（选择器）"></a>3.7 Selector（选择器）</h2><h3 id="3-7-1-基本介绍"><a href="#3-7-1-基本介绍" class="headerlink" title="3.7.1 基本介绍"></a>3.7.1 基本介绍</h3><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li><li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销。</li></ol><h3 id="3-7-2-Selector-示意图和特点说明"><a href="#3-7-2-Selector-示意图和特点说明" class="headerlink" title="3.7.2 Selector 示意图和特点说明"></a>3.7.2 Selector 示意图和特点说明</h3><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_10.png" alt="img " style="zoom:50%;" /><p>说明如下：</p><ol><li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li><li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol><h3 id="3-7-3-Selector-类相关方法"><a href="#3-7-3-Selector-类相关方法" class="headerlink" title="3.7.3 Selector 类相关方法"></a>3.7.3 Selector 类相关方法</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_11.png" alt="img"></p><h3 id="3-7-4-注意事项"><a href="#3-7-4-注意事项" class="headerlink" title="3.7.4 注意事项"></a>3.7.4 注意事项</h3><ol><li><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</li><li>Selector相关方法说明<ul><li><code>selector.select();</code> //阻塞</li><li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li><li><code>selector.wakeup();</code> //唤醒 selector</li><li><code>selector.selectNow();</code> //不阻塞，立马返还</li></ul></li></ol><h2 id="3-8-NIO-非阻塞网络编程原理分析图"><a href="#3-8-NIO-非阻塞网络编程原理分析图" class="headerlink" title="3.8 NIO 非阻塞网络编程原理分析图"></a>3.8 NIO 非阻塞网络编程原理分析图</h2><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_22.png" alt="img"></p><p>对上图的说明：</p><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li><li>代码撑腰。。。</li></ol><h2 id="3-9-NIO-非阻塞网络编程快速入门"><a href="#3-9-NIO-非阻塞网络编程快速入门" class="headerlink" title="3.9 NIO 非阻塞网络编程快速入门"></a>3.9 NIO 非阻塞网络编程快速入门</h2><p>案例要求：</p><ol><li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><h2 id="3-10-SelectionKey"><a href="#3-10-SelectionKey" class="headerlink" title="3.10 SelectionKey"></a>3.10 SelectionKey</h2><ol><li>SelectionKey，表示Selector 和网络通道的注册关系，共四种：<ul><li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li><li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li><li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li><li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li></ul></li></ol><p>源码中：</p><pre><code class="java">public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4;</code></pre><ol><li><code>SelectionKey</code> 相关方法</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_12.png" alt="img"></p><h2 id="3-11-ServerSocketChannel"><a href="#3-11-ServerSocketChannel" class="headerlink" title="3.11 ServerSocketChannel"></a>3.11 ServerSocketChannel</h2><ol><li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li><li>相关方法如下</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_13.png" alt="img"></p><h2 id="3-12-SocketChannel"><a href="#3-12-SocketChannel" class="headerlink" title="3.12 SocketChannel"></a>3.12 SocketChannel</h2><ol><li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li><li>相关方法如下</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_14.png" alt="img"></p><h2 id="3-13-NIO-网络编程应用实例-群聊系统"><a href="#3-13-NIO-网络编程应用实例-群聊系统" class="headerlink" title="3.13 NIO 网络编程应用实例 - 群聊系统"></a>3.13 NIO 网络编程应用实例 - 群聊系统</h2><p>实例要求：</p><ol><li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li><li>示意图分析和代码</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_15.png" alt="img"></p><p>代码：</p><pre><code class="java">// 服务端：import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.Channel;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;public class GroupChatServer &#123;    //定义属性    private Selector selector;    private ServerSocketChannel listenChannel;    private static final int PORT = 6667;    //构造器    //初始化工作    public GroupChatServer() &#123;        try &#123;            //得到选择器            selector = Selector.open();            //ServerSocketChannel            listenChannel = ServerSocketChannel.open();            //绑定端口            listenChannel.socket().bind(new InetSocketAddress(PORT));            //设置非阻塞模式            listenChannel.configureBlocking(false);            //将该 listenChannel 注册到 selector            listenChannel.register(selector, SelectionKey.OP_ACCEPT);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public void listen() &#123;        try &#123;            //循环处理            while (true) &#123;                int count = selector.select();                if (count &gt; 0) &#123; //有事件处理                    // 遍历得到 selectionKey 集合                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                    while (iterator.hasNext()) &#123;                        //取出 selectionkey                        SelectionKey key = iterator.next();                        //监听到 accept                        if (key.isAcceptable()) &#123;                            SocketChannel sc = listenChannel.accept();                            sc.configureBlocking(false);                            //将该 sc 注册到 seletor                            sc.register(selector, SelectionKey.OP_READ);                            //提示                            System.out.println(sc.getRemoteAddress() + &quot; 上线 &quot;);                        &#125;                        if (key.isReadable()) &#123;//通道发送read事件，即通道是可读的状态                            // 处理读(专门写方法..)                            readData(key);                        &#125;                        //当前的 key 删除，防止重复处理                        iterator.remove();                    &#125;                &#125; else &#123;                    System.out.println(&quot;等待....&quot;);                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //发生异常处理....        &#125;    &#125;    //读取客户端消息    public void readData(SelectionKey key) &#123;        SocketChannel channel = null;        try &#123;            //得到 channel            channel = (SocketChannel) key.channel();            //创建 buffer            ByteBuffer buffer = ByteBuffer.allocate(1024);            int count = channel.read(buffer);            //根据 count 的值做处理            if (count &gt; 0) &#123;                //把缓存区的数据转成字符串                String msg = new String(buffer.array());                //输出该消息                System.out.println(&quot;form客户端:&quot; + msg);                //向其它的客户端转发消息(去掉自己),专门写一个方法来处理                sendInfoToOtherClients(msg, channel);            &#125;        &#125; catch (IOException e) &#123;            try &#123;                System.out.println(channel.getRemoteAddress() + &quot;离线了..&quot;);                //取消注册                key.cancel();                //关闭通道                channel.close();            &#125; catch (IOException e2) &#123;                e2.printStackTrace();            &#125;        &#125;    &#125;    //转发消息给其它客户(通道)    private void sendInfoToOtherClients(String msg, SocketChannel self) throws IOException &#123;        System.out.println(&quot;服务器转发消息中...&quot;);        //遍历所有注册到 selector 上的 SocketChannel,并排除 self        for (SelectionKey key : selector.keys()) &#123;            //通过 key 取出对应的 SocketChannel            Channel targetChannel = key.channel();            //排除自己            if (targetChannel instanceof SocketChannel &amp;&amp; targetChannel != self) &#123;                //转型                SocketChannel dest = (SocketChannel) targetChannel;                //将 msg 存储到 buffer                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());                //将 buffer 的数据写入通道                dest.write(buffer);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        //创建服务器对象        GroupChatServer groupChatServer = new GroupChatServer();        groupChatServer.listen();    &#125;&#125;// 客户端：import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Scanner;public class GroupChatClient &#123;    //定义相关的属性    private final String HOST = &quot;127.0.0.1&quot;;//服务器的ip    private final int PORT = 6667;//服务器端口    private Selector selector;    private SocketChannel socketChannel;    private String username;    //构造器,完成初始化工作    public GroupChatClient() throws IOException &#123;                selector = Selector.open();        //连接服务器        socketChannel = SocketChannel.open(new InetSocketAddress(HOST, PORT));        //设置非阻塞        socketChannel.configureBlocking(false);        //将 channel 注册到selector        socketChannel.register(selector, SelectionKey.OP_READ);        //得到 username        username = socketChannel.getLocalAddress().toString().substring(1);        System.out.println(username + &quot; is ok...&quot;);    &#125;    //向服务器发送消息    public void sendInfo(String info) &#123;        info = username + &quot; 说：&quot; + info;        try &#123;            socketChannel.write(ByteBuffer.wrap(info.getBytes()));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //读取从服务器端回复的消息    public void readInfo() &#123;        try &#123;            int readChannels = selector.select();            if (readChannels &gt; 0) &#123;//有可以用的通道                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    if (key.isReadable()) &#123;                        //得到相关的通道                        SocketChannel sc = (SocketChannel) key.channel();                        //得到一个 Buffer                        ByteBuffer buffer = ByteBuffer.allocate(1024);                        //读取                        sc.read(buffer);                        //把读到的缓冲区的数据转成字符串                        String msg = new String(buffer.array());                        System.out.println(msg.trim());                    &#125;                &#125;                iterator.remove(); //删除当前的 selectionKey,防止重复操作            &#125; else &#123;                //System.out.println(&quot;没有可以用的通道...&quot;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        //启动我们客户端        GroupChatClient chatClient = new GroupChatClient();        //启动一个线程,每个 3 秒，读取从服务器发送数据        new Thread() &#123;            public void run() &#123;                while (true) &#123;                    chatClient.readInfo();                    try &#123;                        Thread.currentThread().sleep(3000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;.start();        //发送数据给服务器端        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextLine()) &#123;            String s = scanner.nextLine();            chatClient.sendInfo(s);        &#125;    &#125;&#125;</code></pre><h2 id="3-14-NIO-与零拷贝"><a href="#3-14-NIO-与零拷贝" class="headerlink" title="3.14 NIO 与零拷贝"></a>3.14 NIO 与零拷贝</h2><h3 id="3-14-1-零拷贝基本介绍"><a href="#3-14-1-零拷贝基本介绍" class="headerlink" title="3.14.1 零拷贝基本介绍"></a>3.14.1 零拷贝基本介绍</h3><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开。</li><li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li><li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li></ol><h3 id="3-14-2-传统-IO-数据读写"><a href="#3-14-2-传统-IO-数据读写" class="headerlink" title="3.14.2 传统 IO 数据读写"></a>3.14.2 传统 IO 数据读写</h3><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p><pre><code class="java">File file = new File(&quot;test.txt&quot;);RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);byte[] arr = new byte[(int) file.length()];raf.read(arr);Socket socket = new ServerSocket(8080).accept();socket.getOutputStream().write(arr);</code></pre><h3 id="3-14-3-传统-IO-模型"><a href="#3-14-3-传统-IO-模型" class="headerlink" title="3.14.3 传统 IO 模型"></a>3.14.3 传统 IO 模型</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_17.png" alt="img"></p><p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p><h3 id="3-14-4-mmap-优化"><a href="#3-14-4-mmap-优化" class="headerlink" title="3.14.4 mmap 优化"></a>3.14.4 mmap 优化</h3><ol><li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li><li><code>mmap</code> 示意图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_18.png" alt="img"></p><h3 id="3-14-5-sendFile-优化"><a href="#3-14-5-sendFile-优化" class="headerlink" title="3.14.5 sendFile 优化"></a>3.14.5 sendFile 优化</h3><ol><li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li><li>示意图和小结</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_19.png" alt="img"></p><ol><li>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</li><li><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_20.png" alt="img"></p><ol><li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li></ol><h3 id="3-14-6-零拷贝的再次理解"><a href="#3-14-6-零拷贝的再次理解" class="headerlink" title="3.14.6 零拷贝的再次理解"></a>3.14.6 零拷贝的再次理解</h3><ol><li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li><li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li></ol><h3 id="3-14-7-mmap-和-sendFile-的区别"><a href="#3-14-7-mmap-和-sendFile-的区别" class="headerlink" title="3.14.7 mmap 和 sendFile 的区别"></a>3.14.7 mmap 和 sendFile 的区别</h3><ol><li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li><li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li><li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li></ol><h3 id="3-14-8-NIO-零拷贝案例"><a href="#3-14-8-NIO-零拷贝案例" class="headerlink" title="3.14.8 NIO 零拷贝案例"></a>3.14.8 NIO 零拷贝案例</h3><p>案例要求：</p><ol><li>使用传统的 <code>IO</code> 方法传递一个大文件</li><li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li><li>看看两种传递方式耗时时间分别是多少</li></ol><pre><code class="java">NewIOServer.javaimport java.net.InetSocketAddress;import java.net.ServerSocket;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;//服务器public class NewIOServer &#123;    public static void main(String[] args) throws Exception &#123;        InetSocketAddress address = new InetSocketAddress(7001);        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        ServerSocket serverSocket = serverSocketChannel.socket();        serverSocket.bind(address);        //创建buffer        ByteBuffer byteBuffer = ByteBuffer.allocate(4096);        while (true) &#123;            SocketChannel socketChannel = serverSocketChannel.accept();            int readcount = 0;            while (-1 != readcount) &#123;                try &#123;                    readcount = socketChannel.read(byteBuffer);                &#125; catch (Exception ex) &#123;                    // ex.printStackTrace();                    break;                &#125;                //                byteBuffer.rewind(); //倒带 position = 0 mark 作废            &#125;        &#125;    &#125;&#125;NewIOClient.javaimport java.io.FileInputStream;import java.net.InetSocketAddress;import java.nio.channels.FileChannel;import java.nio.channels.SocketChannel;public class NewIOClient &#123;    public static void main(String[] args) throws Exception &#123;        SocketChannel socketChannel = SocketChannel.open();        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 7001));        String filename = &quot;protoc-3.6.1-win32.zip&quot;;        //得到一个文件channel        FileChannel fileChannel = new FileInputStream(filename).getChannel();        //准备发送        long startTime = System.currentTimeMillis();        //在 linux 下一个 transferTo 方法就可以完成传输        //在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要        //传输时的位置=》课后思考...        //transferTo 底层使用到零拷贝        long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel);        System.out.println(&quot;发送的总的字节数 = &quot; + transferCount + &quot; 耗时: &quot; + (System.currentTimeMillis() - startTime));        //关闭        fileChannel.close();    &#125;&#125;</code></pre><h2 id="3-15-Java-AIO-基本介绍"><a href="#3-15-Java-AIO-基本介绍" class="headerlink" title="3.15 Java AIO 基本介绍"></a>3.15 Java AIO 基本介绍</h2><ol><li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li><li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li><li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li></ol><h2 id="3-16-BIO、NIO、AIO-对比表"><a href="#3-16-BIO、NIO、AIO-对比表" class="headerlink" title="3.16 BIO、NIO、AIO 对比表"></a>3.16 BIO、NIO、AIO 对比表</h2><table><thead><tr><th></th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>IO模型</td><td>同步阻塞</td><td>同步非阻塞（多路复用）</td><td>异步非阻塞</td></tr><tr><td>编程难度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>差</td><td>好</td><td>好</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><p><strong>举例说明</strong></p><ol><li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li><li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li><li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li></ol><h1 id="第-4-章-Netty-概述"><a href="#第-4-章-Netty-概述" class="headerlink" title="第 4 章 Netty 概述"></a>第 4 章 Netty 概述</h1><h2 id="4-1-原生-NIO-存在的问题"><a href="#4-1-原生-NIO-存在的问题" class="headerlink" title="4.1 原生 NIO 存在的问题"></a>4.1 原生 NIO 存在的问题</h2><ol><li><code>NIO</code> 的类库和 <code>API</code> 繁杂，使用麻烦：需要熟练掌握 <code>Selector</code>、<code>ServerSocketChannel</code>、<code>SocketChannel</code>、<code>ByteBuffer</code>等。</li><li>需要具备其他的额外技能：要熟悉 <code>Java</code> 多线程编程，因为 <code>NIO</code> 编程涉及到 <code>Reactor</code> 模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的 <code>NIO</code> 程序。</li><li>开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等。4. <code>JDK NIO</code> 的 <code>Bug</code>：例如臭名昭著的 <code>Epoll Bug</code>，它会导致 <code>Selector</code> 空轮询，最终导致 <code>CPU100%</code>。直到 <code>JDK1.7</code> 版本该问题仍旧存在，没有被根本解决。</li></ol><h2 id="4-2-Netty-官网说明"><a href="#4-2-Netty-官网说明" class="headerlink" title="4.2 Netty 官网说明"></a>4.2 Netty 官网说明</h2><p>官网：<a href="https://netty.io/">https://netty.io/</a></p><p>Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers &amp; clients.</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter04/chapter04_01.png" alt="img"></p><h2 id="4-3-Netty-的优点"><a href="#4-3-Netty-的优点" class="headerlink" title="4.3 Netty 的优点"></a>4.3 Netty 的优点</h2><p><code>Netty</code> 对 <code>JDK</code> 自带的 <code>NIO</code> 的 <code>API</code> 进行了封装，解决了上述问题。</p><ol><li>设计优雅：适用于各种传输类型的统一 <code>API</code> 阻塞和非阻塞 <code>Socket</code>；基于灵活且可扩展的事件模型，可以清晰地分离关注点；高度可定制的线程模型-单线程，一个或多个线程池。</li><li>使用方便：详细记录的 <code>Javadoc</code>，用户指南和示例；没有其他依赖项，<code>JDK5（Netty3.x）</code>或 <code>6（Netty4.x）</code>就足够了。</li><li>高性能、吞吐量更高：延迟更低；减少资源消耗；最小化不必要的内存复制。</li><li>安全：完整的 <code>SSL/TLS</code> 和 <code>StartTLS</code> 支持。</li><li>社区活跃、不断更新：社区活跃，版本迭代周期短，发现的 <code>Bug</code> 可以被及时修复，同时，更多的新功能会被加入。</li></ol><h2 id="4-4-Netty-版本说明"><a href="#4-4-Netty-版本说明" class="headerlink" title="4.4 Netty 版本说明"></a>4.4 Netty 版本说明</h2><ol><li><code>Netty</code> 版本分为 <code>Netty 3.x</code> 和 <code>Netty 4.x</code>、<code>Netty 5.x</code></li><li>因为 <code>Netty 5</code> 出现重大 <code>bug</code>，已经被官网废弃了，目前推荐使用的是 <code>Netty 4.x</code>的稳定版本</li><li>目前在官网可下载的版本 <code>Netty 3.x</code>、<code>Netty 4.0.x</code> 和 <code>Netty 4.1.x</code></li><li>在本套课程中，我们讲解 <code>Netty4.1.x</code> 版本</li><li><code>Netty</code> 下载地址：<a href="https://bintray.com/netty/downloads/netty/">https://bintray.com/netty/downloads/netty/</a></li></ol><h1 id="第-5-章-Netty-高性能架构设计"><a href="#第-5-章-Netty-高性能架构设计" class="headerlink" title="第 5 章 Netty 高性能架构设计"></a>第 5 章 Netty 高性能架构设计</h1><h2 id="5-1-线程模型基本介绍"><a href="#5-1-线程模型基本介绍" class="headerlink" title="5.1 线程模型基本介绍"></a>5.1 线程模型基本介绍</h2><ol><li>不同的线程模式，对程序的性能有很大影响，为了搞清 <code>Netty</code> 线程模式，我们来系统的讲解下各个线程模式，最后看看 <code>Netty</code> 线程模型有什么优越性。</li><li>目前存在的线程模型有：传统阻塞 <code>I/O</code> 服务模型 <code>Reactor</code> 模式</li><li>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现单 <code>Reactor</code> 单线程；单 <code>Reactor</code>多线程；主从 <code>Reactor</code>多线程</li><li><code>Netty</code> 线程模式（<code>Netty</code> 主要基于主从 <code>Reactor</code> 多线程模型做了一定的改进，其中主从 <code>Reactor</code> 多线程模型有多个 <code>Reactor</code>）</li></ol><h2 id="5-2-传统阻塞-I-O-服务模型"><a href="#5-2-传统阻塞-I-O-服务模型" class="headerlink" title="5.2 传统阻塞 I/O 服务模型"></a>5.2 传统阻塞 I/O 服务模型</h2><h3 id="5-2-1-工作原理图"><a href="#5-2-1-工作原理图" class="headerlink" title="5.2.1 工作原理图"></a>5.2.1 工作原理图</h3><ol><li><p>黄色的框表示对象，蓝色的框表示线程</p></li><li><p>白色的框表示方法（<code>API</code>）</p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_01.png" alt="img" style="zoom:80%;" /></li></ol><h3 id="5-2-2-模型特点"><a href="#5-2-2-模型特点" class="headerlink" title="5.2.2 模型特点"></a>5.2.2 模型特点</h3><ol><li>采用阻塞 <code>IO</code> 模式获取输入的数据</li><li>每个连接都需要独立的线程完成数据的输入，业务处理，数据返回</li></ol><h3 id="5-2-3-问题分析"><a href="#5-2-3-问题分析" class="headerlink" title="5.2.3 问题分析"></a>5.2.3 问题分析</h3><ol><li>当并发数很大，就会创建大量的线程，占用很大系统资源</li><li>连接创建后，如果当前线程暂时没有数据可读，该线程会阻塞在 <code>read</code> 操作，造成线程资源浪费</li></ol><h2 id="5-3-Reactor-模式"><a href="#5-3-Reactor-模式" class="headerlink" title="5.3 Reactor 模式"></a>5.3 Reactor 模式</h2><h3 id="5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案："><a href="#5-3-1-针对传统阻塞-I-O-服务模型的-2-个缺点，解决方案：" class="headerlink" title="5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案："></a>5.3.1 针对传统阻塞 I/O 服务模型的 2 个缺点，解决方案：</h3><ol><li>基于 <code>I/O</code> 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理 <code>Reactor</code> 对应的叫法：<ol><li>反应器模式</li><li>分发者模式（Dispatcher）</li><li>通知者模式（notifier）</li></ol></li><li>基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务。</li></ol><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_02.png" alt="img " style="zoom:67%;" /><h3 id="5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图"><a href="#5-3-2-I-O-复用结合线程池，就是-Reactor-模式基本设计思想，如图" class="headerlink" title="5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图"></a>5.3.2 I/O 复用结合线程池，就是 Reactor 模式基本设计思想，如图</h3><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_03.png" alt="img " style="zoom:80%;" /><p>对上图说明：</p><ol><li><code>Reactor</code> 模式，通过一个或多个输入同时传递给服务处理器的模式（基于事件驱动）</li><li>服务器端程序处理传入的多个请求,并将它们同步分派到相应的处理线程，因此 <code>Reactor</code> 模式也叫 <code>Dispatcher</code> 模式</li><li><code>Reactor</code> 模式使用 <code>IO</code> 复用监听事件，收到事件后，分发给某个线程（进程），这点就是网络服务器高并发处理关键</li></ol><h3 id="5-3-3-Reactor-模式中核心组成"><a href="#5-3-3-Reactor-模式中核心组成" class="headerlink" title="5.3.3 Reactor 模式中核心组成"></a>5.3.3 Reactor 模式中核心组成</h3><ol><li><code>Reactor</code>：<code>Reactor</code> 在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对 <code>IO</code> 事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人；</li><li><code>Handlers</code>：处理程序执行 <code>I/O</code> 事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。<code>Reactor</code> 通过调度适当的处理程序来响应 <code>I/O</code> 事件，处理程序执行非阻塞操作。</li></ol><h3 id="5-3-4-Reactor-模式分类"><a href="#5-3-4-Reactor-模式分类" class="headerlink" title="5.3.4 Reactor 模式分类"></a>5.3.4 Reactor 模式分类</h3><p>根据 <code>Reactor</code> 的数量和处理资源池线程的数量不同，有 <code>3</code> 种典型的实现</p><ol><li>单 <code>Reactor</code> 单线程</li><li>单 <code>Reactor</code> 多线程</li><li>主从 <code>Reactor</code> 多线程</li></ol><h2 id="5-4-单-Reactor-单线程"><a href="#5-4-单-Reactor-单线程" class="headerlink" title="5.4 单 Reactor 单线程"></a>5.4 单 Reactor 单线程</h2><p>原理图，并使用 <code>NIO</code> 群聊系统验证</p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_04.png" alt="img " style="zoom:67%;" /><h3 id="5-4-1-方案说明"><a href="#5-4-1-方案说明" class="headerlink" title="5.4.1 方案说明"></a>5.4.1 方案说明</h3><ol><li><code>Select</code> 是前面 <code>I/O</code> 复用模型介绍的标准网络编程 <code>API</code>，可以实现应用程序通过一个阻塞对象监听多路连接请求</li><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后通过 <code>Dispatch</code> 进行分发</li><li>如果是建立连接请求事件，则由 <code>Acceptor</code> 通过 <code>Accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理连接完成后的后续业务处理</li><li>如果不是建立连接事件，则 <code>Reactor</code> 会分发调用连接对应的 <code>Handler</code> 来响应</li><li><code>Handler</code> 会完成 <code>Read</code> → 业务处理 → <code>Send</code> 的完整业务流程</li></ol><p>结合实例：服务器端用一个线程通过多路复用搞定所有的 <code>IO</code> 操作（包括连接，读、写等），编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的 <code>NIO</code> 案例就属于这种模型。</p><h3 id="5-4-2-方案优缺点分析"><a href="#5-4-2-方案优缺点分析" class="headerlink" title="5.4.2 方案优缺点分析"></a>5.4.2 方案优缺点分析</h3><ol><li>优点：模型简单，没有多线程、进程通信、竞争的问题，全部都在一个线程中完成</li><li>缺点：性能问题，只有一个线程，无法完全发挥多核 <code>CPU</code> 的性能。<code>Handler</code>在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈</li><li>缺点：可靠性问题，线程意外终止，或者进入死循环，会导致整个系统通信模块不可用，不能接收和处理外部消息，造成节点故障</li><li>使用场景：客户端的数量有限，业务处理非常快速，比如 <code>Redis</code> 在业务处理的时间复杂度 <code>O(1)</code> 的情况</li></ol><h2 id="5-5-单-Reactor-多线程"><a href="#5-5-单-Reactor-多线程" class="headerlink" title="5.5 单 Reactor 多线程"></a>5.5 单 Reactor 多线程</h2><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_05.png" alt="img " style="zoom:80%;" /><h3 id="5-5-1-原理图"><a href="#5-5-1-原理图" class="headerlink" title="5.5.1 原理图"></a>5.5.1 原理图</h3><h3 id="5-5-2-对上图的小结"><a href="#5-5-2-对上图的小结" class="headerlink" title="5.5.2 对上图的小结"></a>5.5.2 对上图的小结</h3><ol><li><code>Reactor</code> 对象通过 <code>Select</code> 监控客户端请求事件，收到事件后，通过 <code>Dispatch</code> 进行分发</li><li>如果建立连接请求，则右 <code>Acceptor</code> 通过 <code>accept</code> 处理连接请求，然后创建一个 <code>Handler</code> 对象处理完成连接后的各种事件</li><li>如果不是连接请求，则由 <code>Reactor</code> 分发调用连接对应的 <code>handler</code> 来处理</li><li><code>handler</code> 只负责响应事件，不做具体的业务处理，通过 <code>read</code> 读取数据后，会分发给后面的 <code>worker</code> 线程池的某个线程处理业务</li><li><code>worker</code> 线程池会分配独立线程完成真正的业务，并将结果返回给 <code>handler</code></li><li><code>handler</code> 收到响应后，通过 <code>send</code> 将结果返回给 <code>client</code></li></ol><h3 id="5-5-3-方案优缺点分析"><a href="#5-5-3-方案优缺点分析" class="headerlink" title="5.5.3 方案优缺点分析"></a>5.5.3 方案优缺点分析</h3><ol><li>优点：可以充分的利用多核 <code>cpu</code> 的处理能力</li><li>缺点：多线程数据共享和访问比较复杂，<code>Reactor</code> 处理所有的事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈。</li></ol><h2 id="5-6-主从-Reactor-多线程"><a href="#5-6-主从-Reactor-多线程" class="headerlink" title="5.6 主从 Reactor 多线程"></a>5.6 主从 Reactor 多线程</h2><h3 id="5-6-1-工作原理图"><a href="#5-6-1-工作原理图" class="headerlink" title="5.6.1 工作原理图"></a>5.6.1 工作原理图</h3><p>针对单 <code>Reactor</code> 多线程模型中，<code>Reactor</code> 在单线程中运行，高并发场景下容易成为性能瓶颈，可以让 <code>Reactor</code> 在多线程中运行</p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_06.png" alt="img " style="zoom:67%;" /><h3 id="5-6-2-上图的方案说明"><a href="#5-6-2-上图的方案说明" class="headerlink" title="5.6.2 上图的方案说明"></a>5.6.2 上图的方案说明</h3><ol><li><code>Reactor</code> 主线程 <code>MainReactor</code> 对象通过 <code>select</code> 监听连接事件，收到事件后，通过 <code>Acceptor</code> 处理连接事件</li><li>当 <code>Acceptor</code> 处理连接事件后，<code>MainReactor</code> 将连接分配给 <code>SubReactor</code></li><li><code>subreactor</code> 将连接加入到连接队列进行监听，并创建 <code>handler</code> 进行各种事件处理</li><li>当有新事件发生时，<code>subreactor</code> 就会调用对应的 <code>handler</code> 处理</li><li><code>handler</code> 通过 <code>read</code> 读取数据，分发给后面的 <code>worker</code> 线程处理</li><li><code>worker</code> 线程池分配独立的 <code>worker</code> 线程进行业务处理，并返回结果</li><li><code>handler</code> 收到响应的结果后，再通过 <code>send</code> 将结果返回给 <code>client</code></li><li><code>Reactor</code> 主线程可以对应多个 <code>Reactor</code> 子线程，即 <code>MainRecator</code> 可以关联多个 <code>SubReactor</code></li></ol><h3 id="5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解："><a href="#5-6-3-Scalable-IO-in-Java-对-Multiple-Reactors-的原理图解：" class="headerlink" title="5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解："></a>5.6.3 Scalable IO in Java 对 Multiple Reactors 的原理图解：</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_07.png" alt="img"></p><h3 id="5-6-4-方案优缺点说明"><a href="#5-6-4-方案优缺点说明" class="headerlink" title="5.6.4 方案优缺点说明"></a>5.6.4 方案优缺点说明</h3><ol><li>优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理。</li><li>优点：父线程与子线程的数据交互简单，<code>Reactor</code> 主线程只需要把新连接传给子线程，子线程无需返回数据。</li><li>缺点：编程复杂度较高</li><li>结合实例：这种模型在许多项目中广泛使用，包括 <code>Nginx</code> 主从 <code>Reactor</code> 多进程模型，<code>Memcached</code> 主从多线程，<code>Netty</code> 主从多线程模型的支持</li></ol><h2 id="5-7-Reactor-模式小结"><a href="#5-7-Reactor-模式小结" class="headerlink" title="5.7 Reactor 模式小结"></a>5.7 Reactor 模式小结</h2><h3 id="5-7-1-3-种模式用生活案例来理解"><a href="#5-7-1-3-种模式用生活案例来理解" class="headerlink" title="5.7.1 3 种模式用生活案例来理解"></a>5.7.1 3 种模式用生活案例来理解</h3><ol><li>单 <code>Reactor</code> 单线程，前台接待员和服务员是同一个人，全程为顾客服务</li><li>单 <code>Reactor</code> 多线程，<code>1</code> 个前台接待员，多个服务员，接待员只负责接待</li><li>主从 <code>Reactor</code> 多线程，多个前台接待员，多个服务生</li></ol><h3 id="5-7-2-Reactor-模式具有如下的优点"><a href="#5-7-2-Reactor-模式具有如下的优点" class="headerlink" title="5.7.2 Reactor 模式具有如下的优点"></a>5.7.2 Reactor 模式具有如下的优点</h3><ol><li>响应快，不必为单个同步时间所阻塞，虽然 <code>Reactor</code> 本身依然是同步的</li><li>可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销</li><li>扩展性好，可以方便的通过增加 <code>Reactor</code> 实例个数来充分利用 <code>CPU</code> 资源</li><li>复用性好，<code>Reactor</code> 模型本身与具体事件处理逻辑无关，具有很高的复用性</li></ol><h2 id="5-8-Netty-模型"><a href="#5-8-Netty-模型" class="headerlink" title="5.8 Netty 模型"></a>5.8 Netty 模型</h2><h3 id="5-8-1-工作原理示意图1-简单版"><a href="#5-8-1-工作原理示意图1-简单版" class="headerlink" title="5.8.1 工作原理示意图1 - 简单版"></a>5.8.1 工作原理示意图1 - 简单版</h3><pre><code>Netty` 主要基于主从 `Reactors` 多线程模型（如图）做了一定的改进，其中主从 `Reactor` 多线程模型有多个 `Reactor</code></pre><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_08.png" alt="img " style="zoom:50%;" /><h3 id="5-8-2-对上图说明"><a href="#5-8-2-对上图说明" class="headerlink" title="5.8.2 对上图说明"></a>5.8.2 对上图说明</h3><ol><li><code>BossGroup</code> 线程维护 <code>Selector</code>，只关注 <code>Accecpt</code></li><li>当接收到 <code>Accept</code> 事件，获取到对应的 <code>SocketChannel</code>，封装成 <code>NIOScoketChannel</code> 并注册到 <code>Worker</code> 线程（事件循环），并进行维护</li><li>当 <code>Worker</code> 线程监听到 <code>Selector</code> 中通道发生自己感兴趣的事件后，就进行处理（就由 <code>handler</code>），注意 <code>handler</code> 已经加入到通道</li></ol><h3 id="5-8-3-工作原理示意图2-进阶版"><a href="#5-8-3-工作原理示意图2-进阶版" class="headerlink" title="5.8.3 工作原理示意图2 - 进阶版"></a>5.8.3 工作原理示意图2 - 进阶版</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_09.png" alt="img"></p><h3 id="5-8-4-工作原理示意图-详细版"><a href="#5-8-4-工作原理示意图-详细版" class="headerlink" title="5.8.4 工作原理示意图 - 详细版"></a>5.8.4 工作原理示意图 - 详细版</h3><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_10.png" alt="img " style="zoom:80%;" /><h3 id="5-8-5-对上图的说明小结"><a href="#5-8-5-对上图的说明小结" class="headerlink" title="5.8.5 对上图的说明小结"></a>5.8.5 对上图的说明小结</h3><ol><li><p><code>Netty</code> 抽象出两组线程池 <code>BossGroup</code> 专门负责接收客户端的连接，<code>WorkerGroup</code> 专门负责网络的读写</p></li><li><p><code>BossGroup</code> 和 <code>WorkerGroup</code> 类型都是 <code>NioEventLoopGroup</code></p></li><li><p><code>NioEventLoopGroup</code> 相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是 <code>NioEventLoop</code></p></li><li><p><code>NioEventLoop</code> 表示一个不断循环的执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code> 的网络通讯</p></li><li><p><code>NioEventLoopGroup</code> 可以有多个线程，即可以含有多个 <code>NioEventLoop</code></p></li><li><p>每个BossNioEventLoop循环执行的步骤有3步</p><ul><li>轮询 <code>accept</code> 事件</li><li>处理 <code>accept</code> 事件，与 <code>client</code> 建立连接，生成 <code>NioScocketChannel</code>，并将其注册到某个 <code>worker</code> <code>NIOEventLoop</code> 上的 <code>Selector</code></li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li><p>每个Worker  NIOEventLoop循环执行的步骤</p><ul><li>轮询 <code>read</code>，<code>write</code> 事件</li><li>处理 <code>I/O</code> 事件，即 <code>read</code>，<code>write</code> 事件，在对应 <code>NioScocketChannel</code> 处理</li><li>处理任务队列的任务，即 <code>runAllTasks</code></li></ul></li><li><p>每个 <code>Worker</code> <code>NIOEventLoop</code> 处理业务时，会使用 <code>pipeline</code>（管道），<code>pipeline</code> 中包含了 <code>channel</code>，即通过 <code>pipeline</code> 可以获取到对应通道，管道中维护了很多的处理器</p></li></ol><h3 id="5-8-6-Netty-快速入门实例-TCP-服务"><a href="#5-8-6-Netty-快速入门实例-TCP-服务" class="headerlink" title="5.8.6 Netty 快速入门实例 - TCP 服务"></a>5.8.6 Netty 快速入门实例 - TCP 服务</h3><p>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</p><ol><li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，客户端能发送消息给服务器”hello,服务器~”</li><li>服务器可以回复消息给客户端”hello,客户端~”</li><li>目的：对 <code>Netty</code> 线程模型有一个初步认识，便于理解 <code>Netty</code> 模型理论</li><li>看老师代码演示 5.1 编写服务端 5.2 编写客户端 5.3 对 <code>netty</code> 程序进行分析，看看 <code>netty</code> 模型特点 说明：创建 <code>Maven</code> 项目，并引入 <code>Netty</code> 包</li><li>代码如下</li></ol><pre><code class="java">NettyServer.javapackage com.demo.netty.simple;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelFutureListener;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;public class NettyServer &#123;        public static void main(String[] args) throws Exception &#123;                //创建BossGroup 和 WorkerGroup        //说明        //1. 创建两个线程组 bossGroup 和 workerGroup        //2. bossGroup 只是处理连接请求 , 真正的和客户端业务处理，会交给 workerGroup完成        //3. 两个都是无限循环        //4. bossGroup 和 workerGroup 含有的子线程(NioEventLoop)的个数        //   默认实际 cpu核数 * 2        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup(); //8                try &#123;            //创建服务器端的启动对象，配置参数            ServerBootstrap bootstrap = new ServerBootstrap();            //使用链式编程来进行设置            bootstrap.group(bossGroup, workerGroup) //设置两个线程组                    .channel(NioServerSocketChannel.class) //使用NioSocketChannel 作为服务器的通道实现                    .option(ChannelOption.SO_BACKLOG, 128) // 设置线程队列得到连接个数                    .childOption(ChannelOption.SO_KEEPALIVE, true) //设置保持活动连接状态            //          .handler(null) // 该 handler对应 bossGroup , childHandler 对应 workerGroup                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;//创建一个通道初始化对象(匿名对象)                        //给pipeline 设置处理器                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            System.out.println(&quot;客户socketchannel hashcode=&quot; + ch.hashCode()); //可以使用一个集合管理 SocketChannel， 再推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue                            ch.pipeline().addLast(new NettyServerHandler());                        &#125;                    &#125;); // 给我们的workerGroup 的 EventLoop 对应的管道设置处理器            System.out.println(&quot;.....服务器 is ready...&quot;);            //绑定一个端口并且同步, 生成了一个 ChannelFuture 对象            //启动服务器(并绑定端口)            ChannelFuture cf = bootstrap.bind(6668).sync();            //给cf 注册监听器，监控我们关心的事件            cf.addListener(new ChannelFutureListener() &#123;                @Override                public void operationComplete(ChannelFuture future) throws Exception &#123;                    if (cf.isSuccess()) &#123;                        System.out.println(&quot;监听端口 6668 成功&quot;);                    &#125; else &#123;                        System.out.println(&quot;监听端口 6668 失败&quot;);                    &#125;                &#125;            &#125;);            //对关闭通道进行监听            cf.channel().closeFuture().sync();        &#125;finally &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;NettyServerHandler.javapackage com.demo.netty.simple;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.Channel;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.channel.ChannelPipeline;import io.netty.util.CharsetUtil;/** * 说明 * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范) * 2. 这时我们自定义一个Handler , 才能称为一个handler */public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;    //读取数据实际(这里我们可以读取客户端发送的消息)    /**     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址     * 2. Object msg: 就是客户端发送的数据 默认Object     */    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;                System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());        System.out.println(&quot;server ctx =&quot; + ctx);        System.out.println(&quot;看看channel 和 pipeline的关系&quot;);        Channel channel = ctx.channel();        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站                //将 msg 转成一个 ByteBuf        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.        ByteBuf buf = (ByteBuf) msg;        System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));        System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress());    &#125;    //数据读取完毕    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;        //writeAndFlush 是 write + flush        //将数据写入到缓存，并刷新        //一般讲，我们对这个发送的数据进行编码        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;, CharsetUtil.UTF_8));    &#125;        //处理异常, 一般是需要关闭通道    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        ctx.close();    &#125;&#125;NettyClient.javapackage com.demo.netty.simple;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;public class NettyClient &#123;        public static void main(String[] args) throws Exception &#123;        //客户端需要一个事件循环组        EventLoopGroup group = new NioEventLoopGroup();        try &#123;                        //创建客户端启动对象            //注意客户端使用的不是 ServerBootstrap 而是 Bootstrap            Bootstrap bootstrap = new Bootstrap();            //设置相关参数            bootstrap.group(group) //设置线程组                    .channel(NioSocketChannel.class) // 设置客户端通道的实现类(反射)                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            ch.pipeline().addLast(new NettyClientHandler()); //加入自己的处理器                        &#125;                    &#125;);                        System.out.println(&quot;客户端 ok..&quot;);            //启动客户端去连接服务器端            //关于 ChannelFuture 要分析，涉及到netty的异步模型            ChannelFuture channelFuture = bootstrap.connect(&quot;127.0.0.1&quot;, 6668).sync();            //给关闭通道进行监听            channelFuture.channel().closeFuture().sync();        &#125; finally &#123;            group.shutdownGracefully();        &#125;    &#125;&#125;NettyClientHandler.javapackage com.demo.netty.simple;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;public class NettyClientHandler extends ChannelInboundHandlerAdapter &#123;        //当通道就绪就会触发该方法    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        System.out.println(&quot;client &quot; + ctx);        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, server: (&gt;^ω^&lt;)喵&quot;, CharsetUtil.UTF_8));    &#125;    //当通道有读取事件时，会触发    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;        ByteBuf buf = (ByteBuf) msg;        System.out.println(&quot;服务器回复的消息:&quot; + buf.toString(CharsetUtil.UTF_8));        System.out.println(&quot;服务器的地址： &quot; + ctx.channel().remoteAddress());    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><h3 id="5-8-7-任务队列中的-Task-有-3-种典型使用场景"><a href="#5-8-7-任务队列中的-Task-有-3-种典型使用场景" class="headerlink" title="5.8.7 任务队列中的 Task 有 3 种典型使用场景"></a>5.8.7 任务队列中的 Task 有 3 种典型使用场景</h3><ol><li>用户程序自定义的普通任务【举例说明】</li><li>用户自定义定时任务</li><li>非当前 <code>Reactor</code> 线程调用 <code>Channel</code> 的各种方法 例如在推送系统的业务线程里面，根据用户的标识，找到对应的 <code>Channel</code> 引用，然后调用 <code>Write</code> 类方法向该用户推送消息，就会进入到这种场景。最终的 <code>Write</code> 会提交到任务队列中后被异步消费</li><li>代码演示</li></ol><pre><code class="java">package com.demo.netty.simple;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.util.CharsetUtil;import java.util.concurrent.TimeUnit;/** * 说明 * 1. 我们自定义一个Handler 需要继续netty 规定好的某个HandlerAdapter(规范) * 2. 这时我们自定义一个Handler , 才能称为一个handler */public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;    //读取数据实际(这里我们可以读取客户端发送的消息)    /**     * 1. ChannelHandlerContext ctx:上下文对象, 含有 管道pipeline , 通道channel, 地址     * 2. Object msg: 就是客户端发送的数据 默认Object     */    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;        // 比如这里我们有一个非常耗时长的业务-&gt; 异步执行 -&gt; 提交该channel 对应的        // NIOEventLoop 的 taskQueue中,        // 解决方案1 用户程序自定义的普通任务        ctx.channel().eventLoop().execute(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    Thread.sleep(5 * 1000);                    ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵2&quot;, CharsetUtil.UTF_8));                    System.out.println(&quot;channel code=&quot; + ctx.channel().hashCode());                &#125; catch (Exception ex) &#123;                    System.out.println(&quot;发生异常&quot; + ex.getMessage());                &#125;            &#125;        &#125;);        ctx.channel().eventLoop().execute(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    Thread.sleep(5 * 1000);                    ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵3&quot;, CharsetUtil.UTF_8));                    System.out.println(&quot;channel code=&quot; + ctx.channel().hashCode());                &#125; catch (Exception ex) &#123;                    System.out.println(&quot;发生异常&quot; + ex.getMessage());                &#125;            &#125;        &#125;);        //解决方案2 : 用户自定义定时任务 -》 该任务是提交到 scheduleTaskQueue中        ctx.channel().eventLoop().schedule(new Runnable() &#123;            @Override            public void run() &#123;                try &#123;                    Thread.sleep(5 * 1000);                    ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵4&quot;, CharsetUtil.UTF_8));                    System.out.println(&quot;channel code=&quot; + ctx.channel().hashCode());                &#125; catch (Exception ex) &#123;                    System.out.println(&quot;发生异常&quot; + ex.getMessage());                &#125;            &#125;        &#125;, 5, TimeUnit.SECONDS);        System.out.println(&quot;go on ...&quot;);//        System.out.println(&quot;服务器读取线程 &quot; + Thread.currentThread().getName() + &quot; channle =&quot; + ctx.channel());//        System.out.println(&quot;server ctx =&quot; + ctx);//        System.out.println(&quot;看看channel 和 pipeline的关系&quot;);//        Channel channel = ctx.channel();//        ChannelPipeline pipeline = ctx.pipeline(); //本质是一个双向链接, 出站入站//        //        //将 msg 转成一个 ByteBuf//        //ByteBuf 是 Netty 提供的，不是 NIO 的 ByteBuffer.//        ByteBuf buf = (ByteBuf) msg;//        System.out.println(&quot;客户端发送消息是:&quot; + buf.toString(CharsetUtil.UTF_8));//        System.out.println(&quot;客户端地址:&quot; + channel.remoteAddress());    &#125;    //数据读取完毕    @Override    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception &#123;        //writeAndFlush 是 write + flush        //将数据写入到缓存，并刷新        //一般讲，我们对这个发送的数据进行编码        ctx.writeAndFlush(Unpooled.copiedBuffer(&quot;hello, 客户端~(&gt;^ω^&lt;)喵1&quot;, CharsetUtil.UTF_8));    &#125;    //处理异常, 一般是需要关闭通道    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        ctx.close();    &#125;&#125;</code></pre><h3 id="5-8-8-方案再说明"><a href="#5-8-8-方案再说明" class="headerlink" title="5.8.8 方案再说明"></a>5.8.8 方案再说明</h3><ol><li><code>Netty</code> 抽象出两组线程池，<code>BossGroup</code> 专门负责接收客户端连接，<code>WorkerGroup</code> 专门负责网络读写操作。</li><li><code>NioEventLoop</code> 表示一个不断循环执行处理任务的线程，每个 <code>NioEventLoop</code> 都有一个 <code>Selector</code>，用于监听绑定在其上的 <code>socket</code>网络通道。</li><li><code>NioEventLoop</code> 内部采用串行化设计，从消息的 <strong>读取-&gt;解码-&gt;处理-&gt;编码-&gt;发送</strong>，始终由 <code>IO</code> 线程 <code>NioEventLoop</code> 负责</li></ol><pre><code>NioEventLoopGroup` 下包含多个 `NioEventLoop</code></pre><ul><li>每个 <code>NioEventLoop</code> 中包含有一个 <code>Selector</code>，一个 <code>taskQueue</code></li><li>每个 <code>NioEventLoop</code> 的 <code>Selector</code> 上可以注册监听多个 <code>NioChannel</code></li><li>每个 <code>NioChannel</code> 只会绑定在唯一的 <code>NioEventLoop</code> 上</li><li>每个 <code>NioChannel</code> 都绑定有一个自己的 <code>ChannelPipeline</code></li></ul><h2 id="5-9-异步模型"><a href="#5-9-异步模型" class="headerlink" title="5.9 异步模型"></a>5.9 异步模型</h2><h3 id="5-9-1-基本介绍"><a href="#5-9-1-基本介绍" class="headerlink" title="5.9.1 基本介绍"></a>5.9.1 基本介绍</h3><ol><li>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</li><li><code>Netty</code> 中的 <code>I/O</code> 操作是异步的，包括 <code>Bind、Write、Connect</code> 等操作会简单的返回一个 <code>ChannelFuture</code>。</li><li>调用者并不能立刻获得结果，而是通过 <code>Future-Listener</code> 机制，用户可以方便的主动获取或者通过通知机制获得 <code>IO</code> 操作结果。</li><li><code>Netty</code> 的异步模型是建立在 <code>future</code> 和 <code>callback</code> 的之上的。<code>callback</code> 就是回调。重点说 <code>Future</code>，它的核心思想是：假设一个方法 <code>fun</code>，计算过程可能非常耗时，等待 <code>fun</code> 返回显然不合适。那么可以在调用 <code>fun</code> 的时候，立马返回一个 <code>Future</code>，后续可以通过 <code>Future</code> 去监控方法 <code>fun</code> 的处理过程（即：<code>Future-Listener</code> 机制）</li></ol><h3 id="5-9-2-Future-说明"><a href="#5-9-2-Future-说明" class="headerlink" title="5.9.2 Future 说明"></a>5.9.2 Future 说明</h3><ol><li>表示异步的执行结果,可以通过它提供的方法来检测执行是否完成，比如检索计算等等。</li><li><code>ChannelFuture</code> 是一个接口：<code>public interface ChannelFuture extends Future&lt;Void&gt;</code> 我们可以添加监听器，当监听的事件发生时，就会通知到监听器。案例说明</li></ol><h3 id="5-9-3-工作原理示意图"><a href="#5-9-3-工作原理示意图" class="headerlink" title="5.9.3 工作原理示意图"></a>5.9.3 工作原理示意图</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_11.png" alt="img"></p><img src="https://dongzl.github.io/netty-handbook/_media/chapter05/chapter05_12.png" alt="img " style="zoom:50%;" /><p>说明：</p><ol><li>在使用 <code>Netty</code> 进行编程时，拦截操作和转换出入站数据只需要您提供 <code>callback</code> 或利用 <code>future</code> 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。</li><li><code>Netty</code> 框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来。</li></ol><h3 id="5-9-4-Future-Listener-机制"><a href="#5-9-4-Future-Listener-机制" class="headerlink" title="5.9.4 Future-Listener 机制"></a>5.9.4 Future-Listener 机制</h3><ol><li>当 <code>Future</code> 对象刚刚创建时，处于非完成状态，调用者可以通过返回的 <code>ChannelFuture</code> 来获取操作执行的状态，注册监听函数来执行完成后的操作。</li><li>常见有如下操作<ul><li>通过 <code>isDone</code> 方法来判断当前操作是否完成；</li><li>通过 <code>isSuccess</code> 方法来判断已完成的当前操作是否成功；</li><li>通过 <code>getCause</code> 方法来获取已完成的当前操作失败的原因；</li><li>通过 <code>isCancelled</code> 方法来判断已完成的当前操作是否被取消；</li><li>通过 <code>addListener</code> 方法来注册监听器，当操作已完成（<code>isDone</code>方法返回完成），将会通知指定的监听器；如果 <code>Future</code> 对象已完成，则通知指定的监听器</li></ul></li></ol><p>举例说明 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑</p><pre><code class="java">//绑定一个端口并且同步,生成了一个ChannelFuture对象//启动服务器(并绑定端口)ChannelFuture cf = bootstrap.bind(6668).sync();//给cf注册监听器，监控我们关心的事件cf.addListener(new ChannelFutureListener() &#123;   @Override   public void operationComplete (ChannelFuture future) throws Exception &#123;      if (cf.isSuccess()) &#123;         System.out.println(&quot;监听端口6668成功&quot;);      &#125; else &#123;         System.out.println(&quot;监听端口6668失败&quot;);      &#125;   &#125;&#125;);</code></pre><h2 id="5-10-快速入门实例-HTTP服务"><a href="#5-10-快速入门实例-HTTP服务" class="headerlink" title="5.10 快速入门实例 - HTTP服务"></a>5.10 快速入门实例 - HTTP服务</h2><ol><li>实例要求：使用 <code>IDEA</code> 创建 <code>Netty</code> 项目</li><li><code>Netty</code> 服务器在 <code>6668</code> 端口监听，浏览器发出请求 <code>http://localhost:6668/</code></li><li>服务器可以回复消息给客户端”Hello!我是服务器5”,并对特定请求资源进行过滤。</li><li>目的：<code>Netty</code> 可以做 <code>Http</code> 服务开发，并且理解 <code>Handler</code> 实例和客户端及其请求的关系。</li><li>看老师代码演示</li></ol><pre><code class="java">TestServer.javapackage com.demo.netty.http;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.nio.NioServerSocketChannel;public class TestServer &#123;        public static void main(String[] args) throws Exception &#123;        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup();        try &#123;            ServerBootstrap serverBootstrap = new ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).childHandler(new TestServerInitializer());            ChannelFuture channelFuture = serverBootstrap.bind(6668).sync();            channelFuture.channel().closeFuture().sync();        &#125; finally &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;TestServerInitializer.javapackage com.demo.netty.http;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.socket.SocketChannel;import io.netty.handler.codec.http.HttpServerCodec;public class TestServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;    @Override    protected void initChannel(SocketChannel ch) throws Exception &#123;        //向管道加入处理器        //得到管道        ChannelPipeline pipeline = ch.pipeline();        //加入一个netty 提供的httpServerCodec codec =&gt;[coder - decoder]        //HttpServerCodec 说明        //1. HttpServerCodec 是netty 提供的处理http的 编-解码器        pipeline.addLast(&quot;MyHttpServerCodec&quot;, new HttpServerCodec());        //2. 增加一个自定义的handler        pipeline.addLast(&quot;MyTestHttpServerHandler&quot;, new TestHttpServerHandler());        System.out.println(&quot;ok~~~~&quot;);    &#125;&#125;TestHttpServerHandler.javapackage com.demo.netty.http;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.*;import io.netty.util.CharsetUtil;import java.net.URI;/** * 说明 * 1. SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter * 2. HttpObject 客户端和服务器端相互通讯的数据被封装成 HttpObject */public class TestHttpServerHandler extends SimpleChannelInboundHandler&lt;HttpObject&gt; &#123;    //channelRead0 读取客户端数据    @Override    protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception &#123;        System.out.println(&quot;对应的channel=&quot; + ctx.channel() + &quot; pipeline=&quot; + ctx                .pipeline() + &quot; 通过pipeline获取channel&quot; + ctx.pipeline().channel());        System.out.println(&quot;当前ctx的handler=&quot; + ctx.handler());        //判断 msg 是不是 httprequest请求        if (msg instanceof HttpRequest) &#123;            System.out.println(&quot;ctx 类型=&quot; + ctx.getClass());            System.out.println(&quot;pipeline hashcode&quot; + ctx.pipeline().hashCode() + &quot; TestHttpServerHandler hash=&quot; + this.hashCode());            System.out.println(&quot;msg 类型=&quot; + msg.getClass());            System.out.println(&quot;客户端地址&quot; + ctx.channel().remoteAddress());            //获取到            HttpRequest httpRequest = (HttpRequest) msg;            //获取uri, 过滤指定的资源            URI uri = new URI(httpRequest.uri());            if (&quot;/favicon.ico&quot;.equals(uri.getPath())) &#123;                System.out.println(&quot;请求了 favicon.ico, 不做响应&quot;);                return;            &#125;            //回复信息给浏览器 [http协议]            ByteBuf content = Unpooled.copiedBuffer(&quot;hello, 我是服务器&quot;, CharsetUtil.UTF_8);            //构造一个http的相应，即 httpresponse            FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);            response.headers().set(HttpHeaderNames.CONTENT_TYPE, &quot;text/plain&quot;);            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());            //将构建好 response返回            ctx.writeAndFlush(response);        &#125;    &#125;&#125;</code></pre><h1 id="第-6-章-Netty-核心模块组件"><a href="#第-6-章-Netty-核心模块组件" class="headerlink" title="第 6 章 Netty 核心模块组件"></a>第 6 章 Netty 核心模块组件</h1><h2 id="6-1-Bootstrap、ServerBootstrap"><a href="#6-1-Bootstrap、ServerBootstrap" class="headerlink" title="6.1 Bootstrap、ServerBootstrap"></a>6.1 Bootstrap、ServerBootstrap</h2><ol><li><code>Bootstrap</code> 意思是引导，一个 <code>Netty</code> 应用通常由一个 <code>Bootstrap</code> 开始，主要作用是配置整个 <code>Netty</code> 程序，串联各个组件，<code>Netty</code> 中 <code>Bootstrap</code> 类是客户端程序的启动引导类，<code>ServerBootstrap</code> 是服务端启动引导类。</li><li>常见的方法有<ul><li><code>public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)</code>，该方法用于服务器端，用来设置两个 <code>EventLoop</code></li><li><code>public B group(EventLoopGroup group)</code>，该方法用于客户端，用来设置一个 <code>EventLoop</code></li><li><code>public B channel(Class&lt;? extends C&gt; channelClass)</code>，该方法用来设置一个服务器端的通道实现</li><li><code>public &lt;T&gt; B option(ChannelOption&lt;T&gt; option, T value)</code>，用来给 <code>ServerChannel</code> 添加配置</li><li><code>public &lt;T&gt; ServerBootstrap childOption(ChannelOption&lt;T&gt; childOption, T value)</code>，用来给接收到的通道添加配置</li><li><code>public ServerBootstrap childHandler(ChannelHandler childHandler)</code>，该方法用来设置业务处理类（自定义的<code>handler</code>）</li><li><code>public ChannelFuture bind(int inetPort)</code>，该方法用于服务器端，用来设置占用的端口号</li><li><code>public ChannelFuture connect(String inetHost, int inetPort)</code>，该方法用于客户端，用来连接服务器端</li></ul></li></ol><h2 id="6-2-Future、ChannelFuture"><a href="#6-2-Future、ChannelFuture" class="headerlink" title="6.2 Future、ChannelFuture"></a>6.2 Future、ChannelFuture</h2><p><code>Netty</code> 中所有的 <code>IO</code> 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 <code>Future</code> 和 <code>ChannelFutures</code>，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件</p><p>常见的方法有</p><ul><li><code>Channel channel()</code>，返回当前正在进行 <code>IO</code> 操作的通道</li><li><code>ChannelFuture sync()</code>，等待异步操作执行完毕</li></ul><h2 id="6-3-Channel"><a href="#6-3-Channel" class="headerlink" title="6.3 Channel"></a>6.3 Channel</h2><ol><li><p><code>Netty</code> 网络通信的组件，能够用于执行网络 <code>I/O</code> 操作。</p></li><li><p>通过 <code>Channel</code> 可获得当前网络连接的通道的状态</p></li><li><p>通过 <code>Channel</code> 可获得网络连接的配置参数（例如接收缓冲区大小）</p></li><li><p><code>Channel</code> 提供异步的网络 <code>I/O</code> 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 <code>I/O</code> 调用都将立即返回，并且不保证在调用结束时所请求的 <code>I/O</code> 操作已完成</p></li><li><p>调用立即返回一个 <code>ChannelFuture</code> 实例，通过注册监听器到 <code>ChannelFuture</code> 上，可以 <code>I/O</code> 操作成功、失败或取消时回调通知调用方</p></li><li><p>支持关联 <code>I/O</code> 操作与对应的处理程序</p></li><li><p>不同协议、不同的阻塞类型的连接都有不同的Channel类型与之对应，常用的Channel类型：</p><ul><li><code>NioSocketChannel</code>，异步的客户端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioServerSocketChannel</code>，异步的服务器端 <code>TCP</code> <code>Socket</code> 连接。</li><li><code>NioDatagramChannel</code>，异步的 <code>UDP</code> 连接。</li><li><code>NioSctpChannel</code>，异步的客户端 <code>Sctp</code> 连接。</li><li><code>NioSctpServerChannel</code>，异步的 <code>Sctp</code> 服务器端连接，这些通道涵盖了 <code>UDP</code> 和 <code>TCP</code> 网络 <code>IO</code> 以及文件 <code>IO</code>。</li></ul></li></ol><h2 id="6-4-Selector"><a href="#6-4-Selector" class="headerlink" title="6.4 Selector"></a>6.4 Selector</h2><ol><li><code>Netty</code> 基于 <code>Selector</code> 对象实现 <code>I/O</code> 多路复用，通过 <code>Selector</code> 一个线程可以监听多个连接的 <code>Channel</code> 事件。</li><li>当向一个 <code>Selector</code> 中注册 <code>Channel</code> 后，<code>Selector</code> 内部的机制就可以自动不断地查询（<code>Select</code>）这些注册的 <code>Channel</code> 是否有已就绪的 <code>I/O</code> 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 <code>Channel</code></li></ol><h2 id="6-5-ChannelHandler-及其实现类"><a href="#6-5-ChannelHandler-及其实现类" class="headerlink" title="6.5 ChannelHandler 及其实现类"></a>6.5 ChannelHandler 及其实现类</h2><ol><li><code>ChannelHandler</code> 是一个接口，处理 <code>I/O</code> 事件或拦截 <code>I/O</code> 操作，并将其转发到其 <code>ChannelPipeline</code>（业务处理链）中的下一个处理程序。</li><li><code>ChannelHandler</code> 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类</li><li><code>ChannelHandler</code> 及其实现类一览图（后）</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_01.png" alt="img"></p><ol><li>我们经常需要自定义一个 <code>Handler</code> 类去继承 <code>ChannelInboundHandlerAdapter</code>，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方法</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_02.png" alt="img"></p><h2 id="6-6-Pipeline-和-ChannelPipeline"><a href="#6-6-Pipeline-和-ChannelPipeline" class="headerlink" title="6.6 Pipeline 和 ChannelPipeline"></a>6.6 Pipeline 和 ChannelPipeline</h2><p><code>ChannelPipeline</code> 是一个重点：</p><ol><li><code>ChannelPipeline</code> 是一个 <code>Handler</code> 的集合，它负责处理和拦截 <code>inbound</code> 或者 <code>outbound</code> 的事件和操作，相当于一个贯穿 <code>Netty</code> 的链。（也可以这样理解：<code>ChannelPipeline</code> 是保存 <code>ChannelHandler</code> 的 <code>List</code>，用于处理或拦截 <code>Channel</code> 的入站事件和出站操作）</li><li><code>ChannelPipeline</code> 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 <code>Channel</code> 中各个的 <code>ChannelHandler</code> 如何相互交互</li><li>在 <code>Netty</code> 中每个 <code>Channel</code> 都有且仅有一个 <code>ChannelPipeline</code> 与之对应，它们的组成关系如下</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_03.png" alt="img"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_04.png" alt="img"></p><ol><li>常用方法 <code>ChannelPipeline addFirst(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的第一个位置<code>ChannelPipeline addLast(ChannelHandler... handlers)</code>，把一个业务处理类（<code>handler</code>）添加到链中的最后一个位置</li></ol><h2 id="6-7-ChannelHandlerContext"><a href="#6-7-ChannelHandlerContext" class="headerlink" title="6.7 ChannelHandlerContext"></a>6.7 ChannelHandlerContext</h2><ol><li>保存 <code>Channel</code> 相关的所有上下文信息，同时关联一个 <code>ChannelHandler</code> 对象</li><li>即 <code>ChannelHandlerContext</code> 中包含一个具体的事件处理器 <code>ChannelHandler</code>，同时 <code>ChannelHandlerContext</code> 中也绑定了对应的 <code>pipeline</code> 和 <code>Channel</code> 的信息，方便对 <code>ChannelHandler</code> 进行调用。</li><li>常用方法<ul><li><code>ChannelFuture close()</code>，关闭通道</li><li><code>ChannelOutboundInvoker flush()</code>，刷新</li><li><code>ChannelFuture writeAndFlush(Object msg)</code>，将数据写到</li><li><code>ChannelPipeline</code> 中当前 <code>ChannelHandler</code> 的下一个 <code>ChannelHandler</code> 开始处理（出站）</li></ul></li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_05.png" alt="img"></p><h2 id="6-8-ChannelOption"><a href="#6-8-ChannelOption" class="headerlink" title="6.8 ChannelOption"></a>6.8 ChannelOption</h2><ol><li><code>Netty</code> 在创建 <code>Channel</code> 实例后，一般都需要设置 <code>ChannelOption</code> 参数。</li><li><code>ChannelOption</code> 参数如下：</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_06.png" alt="img"></p><h2 id="6-9-EventLoopGroup-和其实现类-NioEventLoopGroup"><a href="#6-9-EventLoopGroup-和其实现类-NioEventLoopGroup" class="headerlink" title="6.9 EventLoopGroup 和其实现类 NioEventLoopGroup"></a>6.9 EventLoopGroup 和其实现类 NioEventLoopGroup</h2><ol><li><code>EventLoopGroup</code> 是一组 <code>EventLoop</code> 的抽象，<code>Netty</code> 为了更好的利用多核 <code>CPU</code> 资源，一般会有多个 <code>EventLoop</code> 同时工作，每个 <code>EventLoop</code> 维护着一个 <code>Selector</code> 实例。</li><li><code>EventLoopGroup</code> 提供 <code>next</code> 接口，可以从组里面按照一定规则获取其中一个 <code>EventLoop</code> 来处理任务。在 <code>Netty</code> 服务器端编程中，我们一般都需要提供两个 <code>EventLoopGroup</code>，例如：<code>BossEventLoopGroup</code> 和 <code>WorkerEventLoopGroup</code>。</li><li>通常一个服务端口即一个 <code>ServerSocketChannel</code> 对应一个 <code>Selector</code> 和一个 <code>EventLoop</code> 线程。<code>BossEventLoop</code> 负责接收客户端的连接并将 <code>SocketChannel</code> 交给 <code>WorkerEventLoopGroup</code> 来进行 <code>IO</code> 处理，如下图所示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_07.png" alt="img"></p><ol><li>常用方法 <code>public NioEventLoopGroup()</code>，构造方法 <code>public Future&lt;?&gt; shutdownGracefully()</code>，断开连接，关闭线程</li></ol><h2 id="6-10-Unpooled-类"><a href="#6-10-Unpooled-类" class="headerlink" title="6.10 Unpooled 类"></a>6.10 Unpooled 类</h2><ol><li><code>Netty</code> 提供一个专门用来操作缓冲区（即 <code>Netty</code> 的数据容器）的工具类</li><li>常用方法如下所示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_08.png" alt="img"></p><ol><li>举例说明 <code>Unpooled</code> 获取 <code>Netty</code> 的数据容器 <code>ByteBuf</code> 的基本使用【案例演示】</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_09.png" alt="img"></p><p>案例 1</p><pre><code class="java">package com.demo.netty.buf;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;public class NettyByteBuf01 &#123;    public static void main(String[] args) &#123;                //创建一个ByteBuf        //说明        //1. 创建 对象，该对象包含一个数组arr , 是一个byte[10]        //2. 在netty 的buffer中，不需要使用flip 进行反转        //   底层维护了 readerindex 和 writerIndex        //3. 通过 readerindex 和  writerIndex 和  capacity， 将buffer分成三个区域        // 0---readerindex 已经读取的区域        // readerindex---writerIndex ， 可读的区域        // writerIndex -- capacity, 可写的区域        ByteBuf buffer = Unpooled.buffer(10);        for (int i = 0; i &lt; 10; i++) &#123;            buffer.writeByte(i);        &#125;        System.out.println(&quot;capacity=&quot; + buffer.capacity());//10        //输出//        for(int i = 0; i&lt;buffer.capacity(); i++) &#123;//            System.out.println(buffer.getByte(i));//        &#125;        for (int i = 0; i &lt; buffer.capacity(); i++) &#123;            System.out.println(buffer.readByte());        &#125;        System.out.println(&quot;执行完毕&quot;);    &#125;&#125;</code></pre><p>案例 2</p><pre><code class="java">package com.demo.netty.buf;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import java.nio.charset.Charset;public class NettyByteBuf02 &#123;        public static void main(String[] args) &#123;        //创建ByteBuf        ByteBuf byteBuf = Unpooled.copiedBuffer(&quot;hello,world!&quot;, Charset.forName(&quot;utf-8&quot;));        //使用相关的方法        if (byteBuf.hasArray()) &#123; // true            byte[] content = byteBuf.array();            //将 content 转成字符串            System.out.println(new String(content, Charset.forName(&quot;utf-8&quot;)));            System.out.println(&quot;byteBuf=&quot; + byteBuf);            System.out.println(byteBuf.arrayOffset()); // 0            System.out.println(byteBuf.readerIndex()); // 0            System.out.println(byteBuf.writerIndex()); // 12            System.out.println(byteBuf.capacity()); // 36            //System.out.println(byteBuf.readByte()); //            System.out.println(byteBuf.getByte(0)); // 104            int len = byteBuf.readableBytes(); //可读的字节数  12            System.out.println(&quot;len=&quot; + len);            //使用for取出各个字节            for (int i = 0; i &lt; len; i++) &#123;                System.out.println((char) byteBuf.getByte(i));            &#125;            //按照某个范围读取            System.out.println(byteBuf.getCharSequence(0, 4, Charset.forName(&quot;utf-8&quot;)));            System.out.println(byteBuf.getCharSequence(4, 6, Charset.forName(&quot;utf-8&quot;)));        &#125;    &#125;&#125;</code></pre><h2 id="6-11-Netty-应用实例-群聊系统"><a href="#6-11-Netty-应用实例-群聊系统" class="headerlink" title="6.11 Netty 应用实例-群聊系统"></a>6.11 Netty 应用实例-群聊系统</h2><p>实例要求：</p><ol><li>编写一个 <code>Netty</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>Netty</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_10.png" alt="img"></p><p>代码如下：</p><pre><code class="java">package com.demo.netty.groupchat;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;public class GroupChatServer &#123;    private int port; //监听端口    public GroupChatServer(int port) &#123;        this.port = port;    &#125;    //编写run方法，处理客户端的请求    public void run() throws Exception &#123;        //创建两个线程组        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup(); //8个NioEventLoop        try &#123;            ServerBootstrap b = new ServerBootstrap();            b.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .option(ChannelOption.SO_BACKLOG, 128)                    .childOption(ChannelOption.SO_KEEPALIVE, true)                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            //获取到pipeline                            ChannelPipeline pipeline = ch.pipeline();                            //向pipeline加入解码器                            pipeline.addLast(&quot;decoder&quot;, new StringDecoder());                            //向pipeline加入编码器                            pipeline.addLast(&quot;encoder&quot;, new StringEncoder());                            //加入自己的业务处理handler                            pipeline.addLast(new GroupChatServerHandler());                        &#125;                    &#125;);            System.out.println(&quot;netty 服务器启动&quot;);            ChannelFuture channelFuture = b.bind(port).sync();            //监听关闭            channelFuture.channel().closeFuture().sync();        &#125; finally &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        new GroupChatServer(7000).run();    &#125;&#125;package com.demo.netty.groupchat;import io.netty.channel.Channel;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.channel.group.ChannelGroup;import io.netty.channel.group.DefaultChannelGroup;import io.netty.util.concurrent.GlobalEventExecutor;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;public class GroupChatServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;    //public static List&lt;Channel&gt; channels = new ArrayList&lt;Channel&gt;();    //使用一个hashmap 管理    //public static Map&lt;String, Channel&gt; channels = new HashMap&lt;String,Channel&gt;();    //定义一个channle 组，管理所有的channel    //GlobalEventExecutor.INSTANCE) 是全局的事件执行器，是一个单例    private static ChannelGroup channelGroup = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);    SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);    //handlerAdded 表示连接建立，一旦连接，第一个被执行    //将当前channel 加入到  channelGroup    @Override    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;        Channel channel = ctx.channel();        //将该客户加入聊天的信息推送给其它在线的客户端        /*        该方法会将 channelGroup 中所有的channel 遍历，并发送 消息，        我们不需要自己遍历         */        channelGroup.writeAndFlush(&quot;[客户端]&quot; + channel.remoteAddress() + &quot; 加入聊天&quot; + sdf.format(new java.util.Date()) + &quot; \n&quot;);        channelGroup.add(channel);    &#125;    //断开连接, 将xx客户离开信息推送给当前在线的客户    @Override    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;        Channel channel = ctx.channel();        channelGroup.writeAndFlush(&quot;[客户端]&quot; + channel.remoteAddress() + &quot; 离开了\n&quot;);        System.out.println(&quot;channelGroup size&quot; + channelGroup.size());    &#125;    //表示channel 处于活动状态, 提示 xx上线    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        System.out.println(ctx.channel().remoteAddress() + &quot; 上线了~&quot;);    &#125;    //表示channel 处于不活动状态, 提示 xx离线了    @Override    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;        System.out.println(ctx.channel().remoteAddress() + &quot; 离线了~&quot;);    &#125;    //读取数据    @Override    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;        //获取到当前channel        Channel channel = ctx.channel();        //这时我们遍历channelGroup, 根据不同的情况，回送不同的消息        channelGroup.forEach(ch -&gt; &#123;            if (channel != ch) &#123; //不是当前的channel,转发消息                ch.writeAndFlush(&quot;[客户]&quot; + channel.remoteAddress() + &quot; 发送了消息&quot; + msg + &quot;\n&quot;);            &#125; else &#123;//回显自己发送的消息给自己                ch.writeAndFlush(&quot;[自己]发送了消息&quot; + msg + &quot;\n&quot;);            &#125;        &#125;);    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        //关闭通道        ctx.close();    &#125;&#125;package com.demo.netty.groupchat;import io.netty.bootstrap.Bootstrap;import io.netty.channel.*;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import java.util.Scanner;public class GroupChatClient &#123;        //属性    private final String host;    private final int port;    public GroupChatClient(String host, int port) &#123;        this.host = host;        this.port = port;    &#125;    public void run() throws Exception &#123;        EventLoopGroup group = new NioEventLoopGroup();        try &#123;                        Bootstrap bootstrap = new Bootstrap()                    .group(group)                    .channel(NioSocketChannel.class)                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        protected void initChannel(SocketChannel ch) throws Exception &#123;                            //得到pipeline                            ChannelPipeline pipeline = ch.pipeline();                            //加入相关handler                            pipeline.addLast(&quot;decoder&quot;, new StringDecoder());                            pipeline.addLast(&quot;encoder&quot;, new StringEncoder());                            //加入自定义的handler                            pipeline.addLast(new GroupChatClientHandler());                        &#125;                    &#125;);            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();            //得到channel            Channel channel = channelFuture.channel();            System.out.println(&quot;-------&quot; + channel.localAddress() + &quot;--------&quot;);            //客户端需要输入信息，创建一个扫描器            Scanner scanner = new Scanner(System.in);            while (scanner.hasNextLine()) &#123;                String msg = scanner.nextLine();                //通过channel 发送到服务器端                channel.writeAndFlush(msg + &quot;\r\n&quot;);            &#125;        &#125; finally &#123;            group.shutdownGracefully();        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        new GroupChatClient(&quot;127.0.0.1&quot;, 7000).run();    &#125;&#125;package com.demo.netty.groupchat;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;public class GroupChatClientHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;        @Override    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;        System.out.println(msg.trim());    &#125;&#125;</code></pre><h2 id="6-12-Netty-心跳检测机制案例"><a href="#6-12-Netty-心跳检测机制案例" class="headerlink" title="6.12 Netty 心跳检测机制案例"></a>6.12 Netty 心跳检测机制案例</h2><ol><li>编写一个 <code>Netty</code> 心跳检测机制案例,当服务器超过 <code>3</code> 秒没有读时，就提示读空闲</li><li>当服务器超过 <code>5</code> 秒没有写操作时，就提示写空闲</li><li>实现当服务器超过 <code>7</code> 秒没有读或者写操作时，就提示读写空闲</li><li>代码如下：</li></ol><pre><code class="java">package com.demo.netty.heartbeat;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.timeout.IdleStateHandler;import java.util.concurrent.TimeUnit;public class MyServer &#123;    public static void main(String[] args) throws Exception &#123;                //创建两个线程组        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup(); //8个NioEventLoop        try &#123;            ServerBootstrap serverBootstrap = new ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup);            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.handler(new LoggingHandler(LogLevel.INFO));            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ChannelPipeline pipeline = ch.pipeline();                    //加入一个netty 提供 IdleStateHandler                    /*                    说明                    1. IdleStateHandler 是netty 提供的处理空闲状态的处理器                    2. long readerIdleTime : 表示多长时间没有读, 就会发送一个心跳检测包检测是否连接                    3. long writerIdleTime : 表示多长时间没有写, 就会发送一个心跳检测包检测是否连接                    4. long allIdleTime : 表示多长时间没有读写, 就会发送一个心跳检测包检测是否连接                    5. 文档说明                    triggers an &#123;@link IdleStateEvent&#125; when a &#123;@link Channel&#125; has not performed * read, write, or both operation for a while. *                  6. 当 IdleStateEvent 触发后 , 就会传递给管道 的下一个handler去处理 *                  通过调用(触发)下一个handler 的 userEventTiggered , 在该方法中去处理 IdleStateEvent(读空闲，写空闲，读写空闲)                     */                    pipeline.addLast(new IdleStateHandler(7000, 7000, 10, TimeUnit.SECONDS));                    //加入一个对空闲检测进一步处理的handler(自定义)                    pipeline.addLast(new MyServerHandler());                &#125;            &#125;);            //启动服务器            ChannelFuture channelFuture = serverBootstrap.bind(7000).sync();            channelFuture.channel().closeFuture().sync();        &#125; finally &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;package com.demo.netty.heartbeat;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import io.netty.handler.timeout.IdleStateEvent;public class MyServerHandler extends ChannelInboundHandlerAdapter &#123;    /**     * @param ctx 上下文     * @param evt 事件     * @throws Exception     */    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;        if (evt instanceof IdleStateEvent) &#123;            //将  evt 向下转型 IdleStateEvent            IdleStateEvent event = (IdleStateEvent) evt;            String eventType = null;            switch (event.state()) &#123;                case READER_IDLE:                    eventType = &quot;读空闲&quot;;                    break;                case WRITER_IDLE:                    eventType = &quot;写空闲&quot;;                    break;                case ALL_IDLE:                    eventType = &quot;读写空闲&quot;;                    break;            &#125;            System.out.println(ctx.channel().remoteAddress() + &quot;--超时时间--&quot; + eventType);            System.out.println(&quot;服务器做相应处理..&quot;);            //如果发生空闲，我们关闭通道            // ctx.channel().close();        &#125;    &#125;&#125;</code></pre><h2 id="6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接"><a href="#6-13-Netty-通过-WebSocket-编程实现服务器和客户端长连接" class="headerlink" title="6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接"></a>6.13 Netty 通过 WebSocket 编程实现服务器和客户端长连接</h2><p>实例要求：</p><ol><li><code>Http</code> 协议是无状态的，浏览器和服务器间的请求响应一次，下一次会重新创建连接。</li><li>要求：实现基于 <code>WebSocket</code> 的长连接的全双工的交互</li><li>改变 <code>Http</code> 协议多次请求的约束，实现长连接了，服务器可以发送消息给浏览器</li><li>客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知</li><li>运行界面</li></ol><img src="https://dongzl.github.io/netty-handbook/_media/chapter06/chapter06_11.png" alt="img " style="zoom:67%;" /><pre><code class="java">package com.demo.netty.websocket;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.http.HttpObjectAggregator;import io.netty.handler.codec.http.HttpServerCodec;import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.stream.ChunkedWriteHandler;public class MyServer &#123;        public static void main(String[] args) throws Exception &#123;        //创建两个线程组        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup(); //8个NioEventLoop        try &#123;            ServerBootstrap serverBootstrap = new ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup);            serverBootstrap.channel(NioServerSocketChannel.class);            serverBootstrap.handler(new LoggingHandler(LogLevel.INFO));            serverBootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                @Override                protected void initChannel(SocketChannel ch) throws Exception &#123;                    ChannelPipeline pipeline = ch.pipeline();                    //因为基于http协议，使用http的编码和解码器                    pipeline.addLast(new HttpServerCodec());                    //是以块方式写，添加ChunkedWriteHandler处理器                    pipeline.addLast(new ChunkedWriteHandler());                    /*                    说明                    1. http数据在传输过程中是分段, HttpObjectAggregator ，就是可以将多个段聚合                    2. 这就就是为什么，当浏览器发送大量数据时，就会发出多次http请求                     */                    pipeline.addLast(new HttpObjectAggregator(8192));                    /*                    说明                    1. 对应websocket ，它的数据是以 帧(frame) 形式传递                    2. 可以看到WebSocketFrame 下面有六个子类                    3. 浏览器请求时 ws://localhost:7000/hello 表示请求的uri                    4. WebSocketServerProtocolHandler 核心功能是将 http协议升级为 ws协议 , 保持长连接                    5. 是通过一个 状态码 101                     */                    pipeline.addLast(new WebSocketServerProtocolHandler(&quot;/hello2&quot;));                    //自定义的handler ，处理业务逻辑                    pipeline.addLast(new MyTextWebSocketFrameHandler());                &#125;            &#125;);            //启动服务器            ChannelFuture channelFuture = serverBootstrap.bind(7000).sync();            channelFuture.channel().closeFuture().sync();        &#125; finally &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;package com.demo.netty.websocket;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import io.netty.handler.codec.http.websocketx.TextWebSocketFrame;import java.time.LocalDateTime;//这里 TextWebSocketFrame 类型，表示一个文本帧(frame)public class MyTextWebSocketFrameHandler extends SimpleChannelInboundHandler&lt;TextWebSocketFrame&gt; &#123;    @Override    protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception &#123;        System.out.println(&quot;服务器收到消息 &quot; + msg.text());        //回复消息        ctx.channel().writeAndFlush(new TextWebSocketFrame(&quot;服务器时间&quot; + LocalDateTime.now() + &quot; &quot; + msg.text()));    &#125;    //当web客户端连接后， 触发方法    @Override    public void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;        //id 表示唯一的值，LongText 是唯一的 ShortText 不是唯一        System.out.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asLongText());        System.out.println(&quot;handlerAdded 被调用&quot; + ctx.channel().id().asShortText());    &#125;    @Override    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception &#123;        System.out.println(&quot;handlerRemoved 被调用&quot; + ctx.channel().id().asLongText());    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        System.out.println(&quot;异常发生 &quot; + cause.getMessage());        ctx.close(); //关闭连接    &#125;&#125;hello.html&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script&gt;    var socket;    //判断当前浏览器是否支持websocket    if(window.WebSocket) &#123;        //go on        socket = new WebSocket(&quot;ws://localhost:7000/hello2&quot;);        //相当于channelReado, ev 收到服务器端回送的消息        socket.onmessage = function (ev) &#123;            var rt = document.getElementById(&quot;responseText&quot;);            rt.value = rt.value + &quot;\n&quot; + ev.data;        &#125;        //相当于连接开启(感知到连接开启)        socket.onopen = function (ev) &#123;            var rt = document.getElementById(&quot;responseText&quot;);            rt.value = &quot;连接开启了..&quot;        &#125;        //相当于连接关闭(感知到连接关闭)        socket.onclose = function (ev) &#123;            var rt = document.getElementById(&quot;responseText&quot;);            rt.value = rt.value + &quot;\n&quot; + &quot;连接关闭了..&quot;        &#125;    &#125; else &#123;        alert(&quot;当前浏览器不支持websocket&quot;)    &#125;    //发送消息到服务器    function send(message) &#123;        if(!window.socket) &#123; //先判断socket是否创建好            return;        &#125;        if(socket.readyState == WebSocket.OPEN) &#123;            //通过socket 发送消息            socket.send(message)        &#125; else &#123;            alert(&quot;连接没有开启&quot;);        &#125;    &#125;&lt;/script&gt;    &lt;form onsubmit=&quot;return false&quot;&gt;        &lt;textarea name=&quot;message&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt;        &lt;input type=&quot;button&quot; value=&quot;发生消息&quot; onclick=&quot;send(this.form.message.value)&quot;&gt;        &lt;textarea id=&quot;responseText&quot; style=&quot;height: 300px; width: 300px&quot;&gt;&lt;/textarea&gt;        &lt;input type=&quot;button&quot; value=&quot;清空内容&quot; onclick=&quot;document.getElementById(&#39;responseText&#39;).value=&#39;&#39;&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h1 id="第-7-章-Google-Protobuf"><a href="#第-7-章-Google-Protobuf" class="headerlink" title="第 7 章 Google Protobuf"></a>第 7 章 Google Protobuf</h1><h2 id="7-1-编码和解码的基本介绍"><a href="#7-1-编码和解码的基本介绍" class="headerlink" title="7.1 编码和解码的基本介绍"></a>7.1 编码和解码的基本介绍</h2><ol><li>编写网络应用程序时，因为数据在网络中传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码[示意图]</li><li><code>codec</code>（编解码器）的组成部分有两个：<code>decoder</code>（解码器）和 <code>encoder</code>（编码器）。<code>encoder</code> 负责把业务数据转换成字节码数据，<code>decoder</code> 负责把字节码数据转换成业务数据</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_01.png" alt="img"></p><h2 id="7-2-Netty-本身的编码解码的机制和问题分析"><a href="#7-2-Netty-本身的编码解码的机制和问题分析" class="headerlink" title="7.2 Netty 本身的编码解码的机制和问题分析"></a>7.2 Netty 本身的编码解码的机制和问题分析</h2><ol><li><code>Netty</code> 自身提供了一些 <code>codec</code>(编解码器)</li><li><code>Netty</code> 提供的编码器 <code>StringEncoder</code>，对字符串数据进行编码 <code>ObjectEncoder</code>，对Java对象进行编码…</li><li><code>Netty</code> 提供的解码器 <code>StringDecoder</code>,对字符串数据进行解码 <code>ObjectDecoder</code>，对 <code>Java</code> 对象进行解码…</li><li><code>Netty</code> 本身自带的 <code>ObjectDecoder</code> 和 <code>ObjectEncoder</code> 可以用来实现 <code>POJO</code> 对象或各种业务对象的编码和解码，底层使用的仍是Java序列化技术,而Java序列化技术本身效率就不高，存在如下问题<ul><li>无法跨语言</li><li>序列化后的体积太大，是二进制编码的5倍多。</li><li>序列化性能太低</li></ul></li><li>=&gt;引出新的解决方案[<code>Google</code> 的 <code>Protobuf</code>]</li></ol><h2 id="7-3-ProtobufProtobuf-基本介绍和使用示意图"><a href="#7-3-ProtobufProtobuf-基本介绍和使用示意图" class="headerlink" title="7.3 ProtobufProtobuf 基本介绍和使用示意图"></a>7.3 Protobuf<code>Protobuf</code> 基本介绍和使用示意图</h2><ol start="2"><li><code>Protobuf</code> 是 <code>Google</code> 发布的开源项目，全称 <code>Google Protocol Buffers</code>，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 <code>RPC</code> [远程过程调用 <code>remote procedure call</code> ]数据交换格式。目前很多公司 <code>http + json tcp + protobuf</code></li><li>参考文档：<a href="https://developers.google.com/protocol-buffers/docs/proto">https://developers.google.com/protocol-buffers/docs/proto</a> 语言指南</li><li><code>Protobuf</code> 是以 <code>message</code> 的方式来管理数据的.</li><li>支持跨平台、跨语言，即[客户端和服务器端可以是不同的语言编写的]（支持目前绝大多数语言，例如 <code>C++</code>、<code>C#</code>、<code>Java</code>、<code>python</code> 等）</li><li>高性能，高可靠性</li><li>使用 <code>protobuf</code> 编译器能自动生成代码，<code>Protobuf</code> 是将类的定义使用 <code>.proto</code> 文件进行描述。说明，在 <code>idea</code> 中编写 <code>.proto</code> 文件时，会自动提示是否下载 <code>.ptoto</code> 编写插件.可以让语法高亮。</li><li>然后通过 <code>protoc.exe</code> 编译器根据 <code>.proto</code> 自动生成 <code>.java</code> 文件</li><li><code>protobuf</code> 使用示意图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter07/chapter07_02.png" alt="img"></p><h2 id="7-4-Protobuf-快速入门实例"><a href="#7-4-Protobuf-快速入门实例" class="headerlink" title="7.4 Protobuf 快速入门实例"></a>7.4 Protobuf 快速入门实例</h2><p>编写程序，使用 <code>Protobuf</code> 完成如下功能</p><ol><li>客户端可以发送一个 <code>StudentPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li><li>服务端能接收 <code>StudentPoJo</code> 对象，并显示信息(通过 <code>Protobuf</code> 解码)</li><li>具体看老师演示步骤</li></ol><pre><code class="java">Student.protosyntax = &quot;proto3&quot;; //版本option java_outer_classname = &quot;StudentPOJO&quot;;//生成的外部类名，同时也是文件名//protobuf 使用message 管理数据message Student &#123; //会在 StudentPOJO 外部类生成一个内部类 Student， 他是真正发送的POJO对象    int32 id = 1; // Student 类中有 一个属性 名字为 id 类型为int32(protobuf类型) 1表示属性序号，不是值    string name = 2;&#125;编译protoc.exe--java_out=.Student.proto将生成的 StudentPOJO 放入到项目使用</code></pre><h2 id="7-5-Protobuf-快速入门实例-2"><a href="#7-5-Protobuf-快速入门实例-2" class="headerlink" title="7.5 Protobuf 快速入门实例 2"></a>7.5 Protobuf 快速入门实例 2</h2><ol><li>编写程序，使用 <code>Protobuf</code> 完成如下功能</li><li>客户端可以随机发送 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象到服务器(通过 <code>Protobuf</code> 编码)</li><li>服务端能接收 <code>StudentPoJo</code> / <code>WorkerPoJo</code> 对象(需要判断是哪种类型)，并显示信息(通过 <code>Protobuf</code> 解码)</li><li>具体看老师演示步骤</li></ol><pre><code class="java">Student.protosyntax = &quot;proto3&quot;;option optimize_for = SPEED; // 加快解析option java_package=&quot;com.demo.netty.codec2&quot;;   //指定生成到哪个包下option java_outer_classname=&quot;MyDataInfo&quot;; // 外部类名, 文件名//protobuf 可以使用message 管理其他的messagemessage MyMessage &#123;    //定义一个枚举类型    enum DataType &#123;        StudentType = 0; //在proto3 要求enum的编号从0开始        WorkerType = 1;    &#125;    //用data_type 来标识传的是哪一个枚举类型    DataType data_type = 1;    //表示每次枚举类型最多只能出现其中的一个, 节省空间    oneof dataBody &#123;        Student student = 2;        Worker worker = 3;    &#125;&#125;message Student &#123;    int32 id = 1;//Student类的属性    string name = 2; //&#125;message Worker &#123;    string name=1;    int32 age=2;&#125;</code></pre><h1 id="第-8-章-Netty-编解码器和-Handler-调用机制"><a href="#第-8-章-Netty-编解码器和-Handler-调用机制" class="headerlink" title="第 8 章 Netty 编解码器和 Handler 调用机制"></a>第 8 章 Netty 编解码器和 Handler 调用机制</h1><h2 id="8-1-基本说明"><a href="#8-1-基本说明" class="headerlink" title="8.1 基本说明"></a>8.1 基本说明</h2><ol><li><code>Netty</code> 的组件设计：<code>Netty</code> 的主要组件有 <code>Channel</code>、<code>EventLoop</code>、<code>ChannelFuture</code>、<code>ChannelHandler</code>、<code>ChannelPipe</code> 等</li><li><code>ChannelHandler</code> 充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现 <code>ChannelInboundHandler</code> 接口（或 <code>ChannelInboundHandlerAdapter</code>），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从 <code>ChannelInboundHandler</code> 冲刷数据。业务逻辑通常写在一个或者多个 <code>ChannelInboundHandler</code> 中。<code>ChannelOutboundHandler</code> 原理一样，只不过它是用来处理出站数据的</li><li><code>ChannelPipeline</code> 提供了 <code>ChannelHandler</code> 链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过 <code>pipeline</code> 中的一系列 <code>ChannelOutboundHandler</code>，并被这些 <code>Handler</code> 处理，反之则称为入站的</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_01.png" alt="img"></p><h2 id="8-2编码解码器"><a href="#8-2编码解码器" class="headerlink" title="8.2编码解码器"></a>8.2编码解码器</h2><ol><li>当 <code>Netty</code> 发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如 <code>java</code> 对象）；如果是出站消息，它会被编码成字节。</li><li><code>Netty</code> 提供一系列实用的编解码器，他们都实现了 <code>ChannelInboundHadnler</code> 或者 <code>ChannelOutboundHandler</code> 接口。在这些类中，<code>channelRead</code> 方法已经被重写了。以入站为例，对于每个从入站 <code>Channel</code> 读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的 <code>decode()</code> 方法进行解码，并将已经解码的字节转发给 <code>ChannelPipeline</code> 中的下一个 <code>ChannelInboundHandler</code>。</li></ol><h2 id="8-3-解码器-ByteToMessageDecoder"><a href="#8-3-解码器-ByteToMessageDecoder" class="headerlink" title="8.3 解码器 - ByteToMessageDecoder"></a>8.3 解码器 - ByteToMessageDecoder</h2><ol><li>关系继承图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_02.png" alt="img"></p><ol><li>由于不可能知道远程节点是否会一次性发送一个完整的信息，<code>tcp</code> 有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理.</li><li>一个关于 <code>ByteToMessageDecoder</code> 实例分析</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_03.png" alt="img"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_04.png" alt="img"></p><h2 id="8-4-Netty-的-handler-链的调用机制"><a href="#8-4-Netty-的-handler-链的调用机制" class="headerlink" title="8.4 Netty 的 handler 链的调用机制"></a>8.4 Netty 的 handler 链的调用机制</h2><p>实例要求:</p><ol><li>使用自定义的编码器和解码器来说明 <code>Netty</code> 的 <code>handler</code> 调用机制 客户端发送 <code>long</code> -&gt; 服务器 服务端发送 <code>long</code> -&gt; 客户端</li><li>案例演示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_05.png" alt="img"></p><ol><li>结论<ul><li>不论解码器 <code>handler</code> 还是编码器 <code>handler</code> 即接收的消息类型必须与待处理的消息类型一致，否则该 <code>handler</code> 不会被执行</li><li>在解码器进行数据解码时，需要判断缓存区（<code>ByteBuf</code>）的数据是否足够，否则接收到的结果会期望结果可能不一致</li></ul></li></ol><h2 id="8-5-解码器-ReplayingDecoder"><a href="#8-5-解码器-ReplayingDecoder" class="headerlink" title="8.5 解码器 - ReplayingDecoder"></a>8.5 解码器 - ReplayingDecoder</h2><ol><li><code>public abstract class ReplayingDecoder&lt;S&gt; extends ByteToMessageDecoder</code></li><li><code>ReplayingDecoder</code> 扩展了 <code>ByteToMessageDecoder</code> 类，使用这个类，我们不必调用 <code>readableBytes()</code> 方法。参数 <code>S</code> 指定了用户状态管理的类型，其中 <code>Void</code> 代表不需要状态管理</li><li>应用实例：使用 <code>ReplayingDecoder</code> 编写解码器，对前面的案例进行简化[案例演示]</li></ol><pre><code class="java">package com.demo.netty.inboundhandlerandoutboundhandler;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ReplayingDecoder;import java.util.List;public class MyByteToLongDecoder2 extends ReplayingDecoder&lt;Void&gt; &#123;        @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;        System.out.println(&quot;MyByteToLongDecoder2 被调用&quot;);        //在 ReplayingDecoder 不需要判断数据是否足够读取，内部会进行处理判断        out.add(in.readLong());    &#125;&#125;</code></pre><ol><li>ReplayingDecoder使用方便，但它也有一些局限性：<ul><li>并不是所有的 <code>ByteBuf</code> 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 <code>UnsupportedOperationException</code>。</li><li><code>ReplayingDecoder</code> 在某些情况下可能稍慢于 <code>ByteToMessageDecoder</code>，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢</li></ul></li></ol><h2 id="8-6-其它编解码器"><a href="#8-6-其它编解码器" class="headerlink" title="8.6 其它编解码器"></a>8.6 其它编解码器</h2><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_06.png" alt="img"></p><h3 id="8-6-1-其它解码器"><a href="#8-6-1-其它解码器" class="headerlink" title="8.6.1 其它解码器"></a>8.6.1 其它解码器</h3><ol><li><code>LineBasedFrameDecoder</code>：这个类在 <code>Netty</code> 内部也有使用，它使用行尾控制字符（\n或者\r\n）作为分隔符来解析数据。</li><li><code>DelimiterBasedFrameDecoder</code>：使用自定义的特殊字符作为消息的分隔符。</li><li><code>HttpObjectDecoder</code>：一个 <code>HTTP</code> 数据的解码器</li><li><code>LengthFieldBasedFrameDecoder</code>：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息。</li></ol><h3 id="8-6-2-其它编码器"><a href="#8-6-2-其它编码器" class="headerlink" title="8.6.2 其它编码器"></a>8.6.2 其它编码器</h3><h2 id="8-7-Log4j-整合到-Netty"><a href="#8-7-Log4j-整合到-Netty" class="headerlink" title="8.7 Log4j 整合到 Netty"></a>8.7 Log4j 整合到 Netty</h2><ol><li>在 <code>Maven</code> 中添加对 <code>Log4j</code> 的依赖在 <code>pom.xml</code></li></ol><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;log4j&lt;/groupId&gt;    &lt;artifactId&gt;log4j&lt;/artifactId&gt;    &lt;version&gt;1.2.17&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;    &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;    &lt;version&gt;1.7.25&lt;/version&gt;    &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;</code></pre><ol><li>配置 <code>Log4j</code>，在 <code>resources/log4j.properties</code></li></ol><pre><code class="xml">log4j.rootLogger=DEBUG,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=[%p]%C&#123;1&#125;-%m%n</code></pre><ol><li>演示整合</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter08/chapter08_07.png" alt="img"></p><h1 id="第-9-章-TCP-粘包和拆包及解决方案"><a href="#第-9-章-TCP-粘包和拆包及解决方案" class="headerlink" title="第 9 章 TCP 粘包和拆包及解决方案"></a>第 9 章 TCP 粘包和拆包及解决方案</h1><h2 id="9-1-TCP-粘包和拆包基本介绍"><a href="#9-1-TCP-粘包和拆包基本介绍" class="headerlink" title="9.1 TCP 粘包和拆包基本介绍"></a>9.1 TCP 粘包和拆包基本介绍</h2><ol><li><code>TCP</code> 是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的 <code>socket</code>，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（<code>Nagle</code> 算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的</li><li>由于 <code>TCP</code> 无消息保护边界,需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题,看一张图</li><li>示意图 <code>TCP</code> 粘包、拆包图解</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter09/chapter09_01.png" alt="img"></p><p>对图的说明: 假设客户端分别发送了两个数据包 <code>D1</code> 和 <code>D2</code> 给服务端，由于服务端一次读取到字节数是不确定的，故可能存在以下四种情况：</p><ol><li>服务端分两次读取到了两个独立的数据包，分别是 <code>D1</code> 和 <code>D2</code>，没有粘包和拆包</li><li>服务端一次接受到了两个数据包，<code>D1</code> 和 <code>D2</code> 粘合在一起，称之为 <code>TCP</code> 粘包</li><li>服务端分两次读取到了数据包，第一次读取到了完整的 <code>D1</code> 包和 <code>D2</code> 包的部分内容，第二次读取到了 <code>D2</code> 包的剩余内容，这称之为 <code>TCP</code> 拆包</li><li>服务端分两次读取到了数据包，第一次读取到了 <code>D1</code> 包的部分内容 <code>D1_1</code>，第二次读取到了 <code>D1</code> 包的剩余部分内容 <code>D1_2</code> 和完整的 <code>D2</code> 包。</li></ol><h2 id="9-2-TCP-粘包和拆包现象实例"><a href="#9-2-TCP-粘包和拆包现象实例" class="headerlink" title="9.2 TCP 粘包和拆包现象实例"></a>9.2 TCP 粘包和拆包现象实例</h2><p>在编写 <code>Netty</code> 程序时，如果没有做处理，就会发生粘包和拆包的问题</p><p>看一个具体的实例：</p><pre><code class="java">// 核心代码MyClientHandler.javapackage com.demo.netty.tcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;public class MyClientHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;    private int count;    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        //使用客户端发送10条数据 hello,server 编号        for (int i = 0; i &lt; 10; ++i) &#123;            ByteBuf buffer = Unpooled.copiedBuffer(&quot;hello,server &quot; + i, Charset.forName(&quot;utf-8&quot;));            ctx.writeAndFlush(buffer);        &#125;    &#125;    @Override    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;        byte[] buffer = new byte[msg.readableBytes()];        msg.readBytes(buffer);        String message = new String(buffer, Charset.forName(&quot;utf-8&quot;));        System.out.println(&quot;客户端接收到消息=&quot; + message);        System.out.println(&quot;客户端接收消息数量=&quot; + (++this.count));    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        cause.printStackTrace();        ctx.close();    &#125;&#125;MyServerHandler.javapackage com.demo.netty.tcp;import io.netty.buffer.ByteBuf;import io.netty.buffer.Unpooled;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;import java.util.UUID;public class MyServerHandler extends SimpleChannelInboundHandler&lt;ByteBuf&gt; &#123;        private int count;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        //cause.printStackTrace();        ctx.close();    &#125;    @Override    protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception &#123;        byte[] buffer = new byte[msg.readableBytes()];        msg.readBytes(buffer);        //将buffer转成字符串        String message = new String(buffer, Charset.forName(&quot;utf-8&quot;));        System.out.println(&quot;服务器接收到数据 &quot; + message);        System.out.println(&quot;服务器接收到消息量=&quot; + (++this.count));        //服务器回送数据给客户端, 回送一个随机id ,        ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + &quot; &quot;, Charset.forName(&quot;utf-8&quot;));        ctx.writeAndFlush(responseByteBuf);    &#125;&#125;</code></pre><h2 id="9-3-TCP-粘包和拆包解决方案"><a href="#9-3-TCP-粘包和拆包解决方案" class="headerlink" title="9.3 TCP 粘包和拆包解决方案"></a>9.3 TCP 粘包和拆包解决方案</h2><ol><li>使用自定义协议+编解码器来解决</li><li>关键就是要解决服务器端每次读取数据长度的问题，这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的 <code>TCP</code> 粘包、拆包。</li></ol><h2 id="9-4-看一个具体的实例"><a href="#9-4-看一个具体的实例" class="headerlink" title="9.4 看一个具体的实例"></a>9.4 看一个具体的实例</h2><ol><li>要求客户端发送 <code>5</code> 个 <code>Message</code> 对象，客户端每次发送一个 <code>Message</code> 对象</li><li>服务器端每次接收一个 <code>Message</code>，分 <code>5</code> 次进行解码，每读取到一个 <code>Message</code>，会回复一个 <code>Message</code> 对象给客户端。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter09/chapter09_02.png" alt="img"></p><ol><li>代码演示，全部代码核心</li></ol><pre><code class="java">// 核心package com.demo.netty.protocoltcp;//协议包public class MessageProtocol &#123;        private int len; //关键        private byte[] content;    public int getLen() &#123;        return len;    &#125;    public void setLen(int len) &#123;        this.len = len;    &#125;    public byte[] getContent() &#123;        return content;    &#125;    public void setContent(byte[] content) &#123;        this.content = content;    &#125;&#125;package com.demo.netty.protocoltcp;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;public class MyClientHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; &#123;    private int count;    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        //使用客户端发送10条数据 &quot;今天天气冷，吃火锅&quot; 编号        for (int i = 0; i &lt; 5; i++) &#123;            String mes = &quot;今天天气冷，吃火锅&quot;;            byte[] content = mes.getBytes(Charset.forName(&quot;utf-8&quot;));            int length = mes.getBytes(Charset.forName(&quot;utf-8&quot;)).length;            //创建协议包对象            MessageProtocol messageProtocol = new MessageProtocol();            messageProtocol.setLen(length);            messageProtocol.setContent(content);            ctx.writeAndFlush(messageProtocol);        &#125;    &#125;    //    @Override    protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception &#123;        int len = msg.getLen();        byte[] content = msg.getContent();        System.out.println(&quot;客户端接收到消息如下&quot;);        System.out.println(&quot;长度=&quot; + len);        System.out.println(&quot;内容=&quot; + new String(content, Charset.forName(&quot;utf-8&quot;)));        System.out.println(&quot;客户端接收消息数量=&quot; + (++this.count));    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        System.out.println(&quot;异常消息=&quot; + cause.getMessage());        ctx.close();    &#125;&#125;package com.demo.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.MessageToByteEncoder;public class MyMessageEncoder extends MessageToByteEncoder&lt;MessageProtocol&gt; &#123;        @Override    protected void encode(ChannelHandlerContext ctx, MessageProtocol msg, ByteBuf out) throws Exception &#123;        System.out.println(&quot;MyMessageEncoder encode 方法被调用&quot;);        out.writeInt(msg.getLen());        out.writeBytes(msg.getContent());    &#125;&#125;package com.demo.netty.protocoltcp;import io.netty.buffer.ByteBuf;import io.netty.channel.ChannelHandlerContext;import io.netty.handler.codec.ReplayingDecoder;import java.util.List;public class MyMessageDecoder extends ReplayingDecoder&lt;Void&gt; &#123;        @Override    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out) throws Exception &#123;        System.out.println(&quot;MyMessageDecoder decode 被调用&quot;);        //需要将得到二进制字节码-&gt; MessageProtocol 数据包(对象)        int length = in.readInt();        byte[] content = new byte[length];        in.readBytes(content);        //封装成 MessageProtocol 对象，放入 out， 传递下一个handler业务处理        MessageProtocol messageProtocol = new MessageProtocol();        messageProtocol.setLen(length);        messageProtocol.setContent(content);        out.add(messageProtocol);    &#125;&#125;package com.demo.netty.protocoltcp;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.SimpleChannelInboundHandler;import java.nio.charset.Charset;import java.util.UUID;//处理业务的handlerpublic class MyServerHandler extends SimpleChannelInboundHandler&lt;MessageProtocol&gt; &#123;        private int count;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        //cause.printStackTrace();        ctx.close();    &#125;    @Override    protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception &#123;        //接收到数据，并处理        int len = msg.getLen();        byte[] content = msg.getContent();        System.out.println();        System.out.println();        System.out.println();        System.out.println(&quot;服务器接收到信息如下&quot;);        System.out.println(&quot;长度=&quot; + len);        System.out.println(&quot;内容=&quot; + new String(content, Charset.forName(&quot;utf-8&quot;)));        System.out.println(&quot;服务器接收到消息包数量=&quot; + (++this.count));        //回复消息        String responseContent = UUID.randomUUID().toString();        int responseLen = responseContent.getBytes(&quot;utf-8&quot;).length;        byte[] responseContent2 = responseContent.getBytes(&quot;utf-8&quot;);        //构建一个协议包        MessageProtocol messageProtocol = new MessageProtocol();        messageProtocol.setLen(responseLen);        messageProtocol.setContent(responseContent2);        ctx.writeAndFlush(messageProtocol);    &#125;&#125;</code></pre><h1 id="第-10-章-Netty-核心源码剖析"><a href="#第-10-章-Netty-核心源码剖析" class="headerlink" title="第 10 章 Netty 核心源码剖析"></a>第 10 章 Netty 核心源码剖析</h1><h2 id="10-1-基本说明"><a href="#10-1-基本说明" class="headerlink" title="10.1 基本说明"></a>10.1 基本说明</h2><ol><li>只有看过 <code>Netty</code> 源码，才能说是真的掌握了 <code>Netty</code> 框架。</li><li>在 <code>io.netty.example</code> 包下，有很多 <code>Netty</code> 源码案例，可以用来分析。</li><li>源码分析章节是针对有 <code>Java</code> 项目经验，并且玩过框架源码的人员讲的，否则你听起来会有相当的难度。</li></ol><h2 id="10-2-Netty-启动过程源码剖析"><a href="#10-2-Netty-启动过程源码剖析" class="headerlink" title="10.2 Netty 启动过程源码剖析"></a>10.2 Netty 启动过程源码剖析</h2><h3 id="10-2-1-源码剖析目的"><a href="#10-2-1-源码剖析目的" class="headerlink" title="10.2.1 源码剖析目的"></a>10.2.1 源码剖析目的</h3><p>用源码分析的方式走一下 <code>Netty</code>（服务器）的启动过程，更好的理解 <code>Netty</code> 的整体设计和运行机制。</p><h3 id="10-2-2-源码剖析"><a href="#10-2-2-源码剖析" class="headerlink" title="10.2.2 源码剖析"></a>10.2.2 源码剖析</h3><p>说明：</p><ol><li>源码需要剖析到 <code>Netty</code> 调用 <code>doBind</code> 方法，追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>。</li><li>并且要 <code>Debug</code> 程序到 <code>NioEventLoop</code> 类的 <code>run</code> 代码，无限循环，在服务器端运行。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_01.png" alt="img"></p><h3 id="10-2-3-源码剖析过程"><a href="#10-2-3-源码剖析过程" class="headerlink" title="10.2.3 源码剖析过程"></a>10.2.3 源码剖析过程</h3><p><strong>1. <code>demo</code> 源码的基本理解</strong></p><pre><code class="java">// 服务器启动类源码/* * Copyright 2012 The Netty Project * * The Netty Project licenses this file to you under the Apache License, * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance * with the License. You may obtain a copy of the License at: * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. */package demo.netty.example.echo2;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;import io.netty.handler.ssl.SslContext;import io.netty.handler.ssl.SslContextBuilder;import io.netty.handler.ssl.util.SelfSignedCertificate;/** * Echoes back any received data from a client. */public final class EchoServer &#123;    static final boolean SSL = System.getProperty(&quot;ssl&quot;) != null;    static final int PORT = Integer.parseInt(System.getProperty(&quot;port&quot;, &quot;8007&quot;));    public static void main(String[] args) throws Exception &#123;        // Configure SSL.        final SslContext sslCtx;        if (SSL) &#123;            SelfSignedCertificate ssc = new SelfSignedCertificate();            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();        &#125; else &#123;            sslCtx = null;        &#125;        // Configure the server.        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup();        try &#123;            ServerBootstrap b = new ServerBootstrap();            b.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .option(ChannelOption.SO_BACKLOG, 100)                    .handler(new LoggingHandler(LogLevel.INFO))                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                        @Override                        public void initChannel(SocketChannel ch) throws Exception &#123;                            ChannelPipeline p = ch.pipeline();                            if (sslCtx != null) &#123;                                p.addLast(sslCtx.newHandler(ch.alloc()));                            &#125;                            //p.addLast(new LoggingHandler(LogLevel.INFO));                            p.addLast(new EchoServerHandler());                        &#125;                    &#125;);            // Start the server.            ChannelFuture f = b.bind(PORT).sync();            // Wait until the server socket is closed.            f.channel().closeFuture().sync();        &#125; finally &#123;            // Shut down all event loops to terminate all threads.            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;</code></pre><p>说明：</p><ol><li>先看启动类：<code>main</code> 方法中，首先创建了关于 SSL 的配置类。</li><li>重点分析下创建了两个 <code>EventLoopGroup</code> 对象：</li></ol><pre><code class="java">EventLoopGroup bossGroup = new NioEventLoopGroup(1);EventLoopGroup workerGroup = new NioEventLoopGroup();</code></pre><p>(1) 这两个对象是整个 <code>Netty</code> 的核心对象，可以说，整个 <code>Netty</code> 的运作都依赖于他们。<code>bossGroup</code> 用于接受 <code>TCP</code> 请求，他会将请求交给 <code>workerGroup</code>，<code>workerGroup</code> 会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作。</p><p>(2) <code>EventLoopGroup</code> 是事件循环组（线程组）含有多个 <code>EventLoop</code>，可以注册 <code>channel</code>，用于在事件循环中去进行选择（和选择器相关）。【debug看】</p><p>(3) <code>new NioEventLoopGroup(1);</code> 这个 <code>1</code> 表示 <code>bossGroup</code> 事件组有 <code>1</code> 个线程你可以指定，如果 <code>new NioEventLoopGroup()</code> 会含有默认个线程 <code>cpu核数 * 2</code>，即可以充分的利用多核的优势，【可以dubug一把】</p><pre><code class="java">DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(&quot;io.netty.eventLoopThreads&quot;, NettyRuntime.availableProcessors() * 2));</code></pre><p>会创建 <code>EventExecutor</code> 数组 <code>children = new EventExecutor[nThreads];</code> // <code>debug</code> 一下每个元素的类型就是 <code>NIOEventLoop</code>，<code>NIOEventLoop</code> 实现了 <code>EventLoop</code> 接口和 <code>Executor</code> 接口 <code>try</code> 块中创建了一个 <code>ServerBootstrap</code> 对象，他是一个引导类，用于启动服务器和引导整个程序的初始化（看下源码 <code>allowseasybootstrapof&#123;@linkServerChannel&#125;</code>）。它和 <code>ServerChannel</code> 关联，而 <code>ServerChannel</code> 继承了 <code>Channel</code>，有一些方法 <code>remoteAddress</code> 等[可以Debug下]随后，变量 <code>b</code> 调用了 <code>group</code> 方法将两个 <code>group</code> 放入了自己的字段中，用于后期引导使用【<code>debug</code> 下 <code>group</code> 方法</p><pre><code class="java">/** *Set the &#123;@link EventLoopGroup&#125; for the parent (acceptor) and the child (client) . These *&#123;@link EventLoopGroup&#125;&#39;s are used to handle all the events and IO for &#123;@link ServerChannel&#125; and  *&#123;@link Channel&#125;&#39;s. */</code></pre><p>】。</p><p>(4) 然后添加了一个 <code>channel</code>，其中参数一个 <code>Class</code> 对象，引导类将通过这个 <code>Class</code> 对象反射创建 <code>ChannelFactory</code>。然后添加了一些 <code>TCP</code> 的参数。【说明：<code>Channel</code> 的创建在 <code>bind</code> 方法，可以 <code>Debug</code> 下 <code>bind</code>，会找到 <code>channel = channelFactory.newChannel();</code> 】</p><p>(5) 再添加了一个服务器专属的日志处理器 <code>handler</code> 。</p><p>(6) 再添加一个 <code>SocketChannel</code>（不是 <code>ServerSocketChannel</code>）的 <code>handler</code>。</p><p>(7) 然后绑定端口并阻塞至连接成功。</p><p>(8) 最后 <code>main</code> 线程阻塞等待关闭。</p><p>(9) <code>finally</code> 块中的代码将在服务器关闭时优雅关闭所有资源。</p><pre><code class="java">/* * Copyright 2012 The Netty Project * * The Netty Project licenses this file to you under the Apache License, * version 2.0 (the &quot;License&quot;); you may not use this file except in compliance * with the License. You may obtain a copy of the License at: * *   http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. */package demo.netty.example.echo2;import io.netty.channel.ChannelHandler.Sharable;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;/** * Handler implementation for the echo server. */@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123;    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;        ctx.write(msg);    &#125;    @Override    public void channelReadComplete(ChannelHandlerContext ctx) &#123;        ctx.flush();    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;        // Close the connection when an exception is raised.        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><p>说明:</p><ol><li>这是一个普通的处理器类，用于处理客户端发送来的消息，在我们这里，我们简单的解析出客户端传过来的内容，然后打印，最后发送字符串给客户端。</li><li>大致讲解了我们的 <code>demo</code> 源码的作用。后面的 <code>debug</code> 的时候会详细。</li></ol><p><strong>2. 分析 EventLoopGroup 的过程</strong></p><p>2.1 构造器方法</p><pre><code class="java">public NioEventLoopGroup (int nThreads) &#123;     this(nThreads, (Executor) null);&#125;</code></pre><p>2.2 上面的 <code>this(nThreads, (Executor) null);</code> 调用构造器（通过 <code>alt + d</code> 看即可）</p><pre><code class="java">public NioEventLoopGroup (int nThreads, Executor executor) &#123;    this(nThreads, executor, SelectorProvider.provider());&#125;</code></pre><p>2.3 上面的 <code>this(nThreads, executor, SelectorProvider.provider());</code> 调用下面构造器</p><pre><code class="java">public NioEventLoopGroup (int nThreads, Executor executor, final SelectorProvider selectorProvider) &#123;    this(nThreads, executor, selectorProvider,DefaultSelectStrategyFactory.INSTANCE);&#125;</code></pre><p>2.4 上面的 <code>this()...</code> 调用构造器（<code>alt + d</code>）</p><pre><code class="java">public NioEventLoopGroup (int nThreads, Executor executor, final SelectorProvider selectorProvider,final SelectStrategyFactory selectStrategyFactory) &#123;    super(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());&#125;</code></pre><p>2.5 上面的 <code>super()..</code> 的方法是父类：<code>MultithreadEventLoopGroup</code></p><pre><code class="java">protected MultithreadEventLoopGroup (int nThreads, Executor executor, Object...args) &#123;    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);&#125;</code></pre><p>2.6 追踪到源码抽象类 <code>MultithreadEventExecutorGroup</code> 的构造器方法 <code>MultithreadEventExecutorGroup</code> 才是 <code>NioEventLoopGroup</code> 真正的构造方法，这里可以看成是一个模板方法，使用了设计模式的模板模式（可看我录制视频），所以，我们就需要好好分析 <code>MultithreadEventExecutorGroup</code> 方法了</p><p>2.7 分析 <code>MultithreadEventExecutorGroup</code></p><p>参数说明：</p><ul><li><code>@param nThreads</code> 使用的线程数，默认为 <code>core * 2</code>【可以追踪源码】</li><li><code>@param executor</code> 执行器:如果传入 <code>null</code>, 则采用 <code>Netty</code> 默认的线程工厂和默认的执行器 <code>ThreadPerTaskExecutor</code></li><li><code>@param chooserFactory</code> 单例 <code>new DefaultEventExecutorChooserFactory()</code></li><li><code>@param args args</code> 在创建执行器的时候传入固定参数</li></ul><pre><code class="java">protected MultithreadEventExecutorGroup(int nThreads, Executor executor,                                        EventExecutorChooserFactory chooserFactory, Object... args) &#123;    if (nThreads &lt;= 0) &#123;        throw new IllegalArgumentException(String.format(&quot;nThreads: %d (expected: &gt; 0)&quot;, nThreads));    &#125;    if (executor == null) &#123; // 如果传入的执行器是空的则采用默认的线程工厂和默认的执行器        executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());    &#125;    // 创建指定线程数的执行器数组    children = new EventExecutor[nThreads];    // 初始化线程数组    for (int i = 0; i &lt; nThreads; i ++) &#123;        boolean success = false;        try &#123;            // 创建 new NioEventLoop            children[i] = newChild(executor, args);            success = true;        &#125; catch (Exception e) &#123;            // TODO: Think about if this is a good exception type            throw new IllegalStateException(&quot;failed to create a child event loop&quot;, e);        &#125; finally &#123;            // 如果创建失败，优雅关闭            if (!success) &#123;                for (int j = 0; j &lt; i; j ++) &#123;                    children[j].shutdownGracefully();                &#125;                for (int j = 0; j &lt; i; j ++) &#123;                    EventExecutor e = children[j];                    try &#123;                        while (!e.isTerminated()) &#123;                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);                        &#125;                    &#125; catch (InterruptedException interrupted) &#123;                        // Let the caller handle the interruption.                        Thread.currentThread().interrupt();                        break;                    &#125;                &#125;            &#125;        &#125;    &#125;    chooser = chooserFactory.newChooser(children);    final FutureListener&lt;Object&gt; terminationListener = new FutureListener&lt;Object&gt;() &#123;        @Override        public void operationComplete(Future&lt;Object&gt; future) throws Exception &#123;            if (terminatedChildren.incrementAndGet() == children.length) &#123;                terminationFuture.setSuccess(null);            &#125;        &#125;    &#125;;        // 为每一个单例线程池添加一个关闭监听器    for (EventExecutor e: children) &#123;        e.terminationFuture().addListener(terminationListener);    &#125;    Set&lt;EventExecutor&gt; childrenSet = new LinkedHashSet&lt;EventExecutor&gt;(children.length);    //将所有的单例线程池添加到一个 HashSet 中。    Collections.addAll(childrenSet, children);    readonlyChildren = Collections.unmodifiableSet(childrenSet);&#125;</code></pre><p>说明：</p><ol><li>如果 <code>executor</code> 是 <code>null</code>，创建一个默认的 <code>ThreadPerTaskExecutor</code>，使用 <code>Netty</code> 默认的线程工厂。</li><li>根据传入的线程数（<code>CPU * 2</code>）创建一个线程池（单例线程池）数组。</li><li>循环填充数组中的元素。如果异常，则关闭所有的单例线程池。</li><li>根据线程选择工厂创建一个线程选择器。</li><li>为每一个单例线程池添加一个关闭监听器。</li><li>将所有的单例线程池添加到一个 <code>HashSet</code> 中。</li></ol><p><strong>3. ServerBootstrap 创建和构造过程</strong></p><p>3.1 <code>ServerBootstrap</code> 是个空构造，但是有默认的成员变量</p><pre><code class="java">private final Map&lt;ChannelOption&lt;?&gt;, Object&gt; childOptions = new LinkedHashMap&lt;ChannelOption&lt;?&gt;, Object&gt;();private final Map&lt;AttributeKey&lt;?&gt;, Object&gt; childAttrs = new ConcurrentHashMap&lt;AttributeKey&lt;?&gt;, Object&gt;();// config 对象，会在后面起很大作用private final ServerBootstrapConfig config = new ServerBootstrapConfig(this);private volatile EventLoopGroup childGroup;private volatile ChannelHandler childHandler;</code></pre><p>3.2 分析一下 <code>ServerBootstrap</code> 基本使用情况</p><pre><code class="java">ServerBootstrap b = new ServerBootstrap();b.group(bossGroup, workerGroup)        .channel(NioServerSocketChannel.class)        .option(ChannelOption.SO_BACKLOG, 100)        .handler(new LoggingHandler(LogLevel.INFO))        .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;            @Override            public void initChannel(SocketChannel ch) throws Exception &#123;                ChannelPipeline p = ch.pipeline();                if (sslCtx != null) &#123;                    p.addLast(sslCtx.newHandler(ch.alloc()));                &#125;                //p.addLast(new LoggingHandler(LogLevel.INFO));                p.addLast(new EchoServerHandler());            &#125;        &#125;);</code></pre><p>说明:</p><ol><li>链式调用：<code>group</code> 方法，将 <code>boss</code> 和 <code>worker</code> 传入，<code>boss</code> 赋值给 <code>parentGroup</code> 属性, <code>worker</code> 赋值给 <code>childGroup</code> 属性。</li><li><code>channel</code> 方法传入 <code>NioServerSocketChannelclass</code> 对象。会根据这个 <code>class</code> 创建 <code>channel</code> 对象。</li><li><code>option</code> 方法传入 <code>TCP</code> 参数，放在一个 <code>LinkedHashMap</code> 中。</li><li><code>handler</code> 方法传入一个 <code>handler</code> 中，这个 <code>hanlder</code> 只专属于 <code>ServerSocketChannel</code> 而不是 <code>SocketChannel</code>。</li><li><code>childHandler</code> 传入一个 <code>hanlder</code>，这个 <code>handler</code> 将会在每个客户端连接的时候调用。供 <code>SocketChannel</code> 使用。</li></ol><p><strong>4. 绑定端口的分析</strong></p><p>4.1 服务器就是在这个 <code>bind</code> 方法里启动完成的 4.2 <code>bind</code> 方法代码,追踪到创建了一个端口对象，并做了一些空判断，核心代码 <code>doBind</code>，我们看看</p><pre><code class="java">public ChannelFuture bind(SocketAddress localAddress) &#123;    validate();    if (localAddress == null) &#123;        throw new NullPointerException(&quot;localAddress&quot;);    &#125;    return doBind(localAddress);&#125;</code></pre><p>4.3 <code>doBind</code> 源码剖析，核心是两个方法 <code>initAndRegister</code> 和 <code>doBind0</code></p><pre><code class="java">private ChannelFuture doBind(final SocketAddress localAddress) &#123;    final ChannelFuture regFuture = initAndRegister();    final Channel channel = regFuture.channel();    if (regFuture.cause() != null) &#123;        return regFuture;    &#125;    if (regFuture.isDone()) &#123;        // At this point we know that the registration was complete and successful.        ChannelPromise promise = channel.newPromise();        //============================================        //说明:执行doBind0方法，完成对端口的绑定        //============================================        doBind0(regFuture, channel, localAddress, promise);        return promise;    &#125; else &#123;        // Registration future is almost always fulfilled already, but just in case it&#39;s not.        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);        regFuture.addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuture future) throws Exception &#123;                Throwable cause = future.cause();                if (cause != null) &#123;                    // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an                    // IllegalStateException once we try to access the EventLoop of the Channel.                    promise.setFailure(cause);                &#125; else &#123;                    // Registration was successful, so set the correct executor to use.                    // See https://github.com/netty/netty/issues/2586                    promise.registered();                    doBind0(regFuture, channel, localAddress, promise);                &#125;            &#125;        &#125;);        return promise;    &#125;&#125;</code></pre><p>4.4 分析说明 <code>initAndRegister</code></p><pre><code class="java">final ChannelFuture initAndRegister() &#123;    Channel channel = null;    try &#123;        channel = channelFactory.newChannel();        /**         * 说明：channelFactory.newChannel() 方法的作用通过 ServerBootstrap 的通道工厂反射创建一个 NioServerSocketChannel,具体追踪源码可以得到下面结论         * (1)通过 NIO 的 SelectorProvider 的 openServerSocketChannel 方法得到 JDK 的 channel。目的是让 Netty 包装 JDK 的 channel。         * (2)创建了一个唯一的 ChannelId，创建了一个 NioMessageUnsafe，用于操作消息，创建了一个 DefaultChannelPipeline 管道，是个双向链表结构，用于过滤所有的进出的消息。         * (3)创建了一个 NioServerSocketChannelConfig 对象，用于对外展示一些配置。                   * channel = channelFactory.newChannel();//NioServerSocketChannel         * 说明：init 初始化这个 NioServerSocketChannel，具体追踪源码可以得到如下结论         * (1) init 方法，这是个抽象方法 (AbstractBootstrap类的），由ServerBootstrap实现（可以追一下源码//setChannelOptions(channel,options,logger);）。         * (2)设置 NioServerSocketChannel 的 TCP 属性。         * (3)由于 LinkedHashMap 是非线程安全的，使用同步进行处理。         * (4)对 NioServerSocketChannel 的 ChannelPipeline 添加 ChannelInitializer 处理器。         * (5)可以看出，init 的方法的核心作用在和 ChannelPipeline 相关。         * (6)从 NioServerSocketChannel 的初始化过程中，我们知道，pipeline 是一个双向链表，并且，他本身就初始化了 head 和 tail，这里调用了他的 addLast 方法，也就是将整个 handler 插入到 tail 的前面，因为 tail 永远会在后面，需要做一些系统的固定工作。         */        init(channel);    &#125; catch (Throwable t) &#123;        if (channel != null) &#123;            channel.unsafe().closeForcibly();            return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);        &#125;        return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);    &#125;    ChannelFuture regFuture = config().group().register(channel);    if (regFuture.cause() != null) &#123;        if (channel.isRegistered()) &#123;            channel.close();        &#125; else &#123;            channel.unsafe().closeForcibly();        &#125;    &#125;    return regFuture;&#125;</code></pre><p>说明：</p><ol><li>基本说明：<code>initAndRegister()</code> 初始化 <code>NioServerSocketChannel</code> 通道并注册各个 <code>handler</code>，返回一个 <code>future</code>。</li><li>通过 <code>ServerBootstrap</code> 的通道工厂反射创建一个 <code>NioServerSocketChannel</code>。</li><li><code>init</code> 初始化这个 <code>NioServerSocketChannel</code>。</li><li><code>config().group().register(channel)</code> 通过 <code>ServerBootstrap</code> 的 <code>bossGroup</code> 注册 <code>NioServerSocketChannel</code>。</li><li>最后，返回这个异步执行的占位符即 <code>regFuture</code>。</li></ol><p>4.5 <code>init</code> 方法会调用 <code>addLast</code>，现在进入到 <code>addLast</code> 方法内查看</p><pre><code class="java">@Overridepublic final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;    final AbstractChannelHandlerContext newCtx;    synchronized (this) &#123;        checkMultiplicity(handler);        newCtx = newContext(group, filterName(name, handler), handler);        addLast0(newCtx);        if (!registered) &#123;            newCtx.setAddPending();            callHandlerCallbackLater(newCtx, true);            return this;        &#125;        EventExecutor executor = newCtx.executor();        if (!executor.inEventLoop()) &#123;            callHandlerAddedInEventLoop(newCtx, executor);            return this;        &#125;    &#125;    callHandlerAdded0(newCtx);    return this;&#125;</code></pre><p>说明：</p><ol><li><code>addLast</code> 方法，在 <code>DefaultChannelPipeline</code> 类中</li><li><code>addLast</code> 方法这就是 <code>pipeline</code> 方法的核心</li><li>检查该 <code>handler</code> 是否符合标准。</li><li>创建一个 <code>AbstractChannelHandlerContext</code> 对象，这里说一下，<code>ChannelHandlerContext</code> 对象是 <code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关联，每当有 <code>ChannelHandler</code> 添加到 <code>Pipeline</code> 中时，都会创建 <code>Context</code>。<code>Context</code> 的主要功能是管理他所关联的 <code>Handler</code> 和同一个 <code>Pipeline</code> 中的其他 <code>Handler</code> 之间的交互。</li><li>将 <code>Context</code> 添加到链表中。也就是追加到 <code>tail</code> 节点的前面。</li><li>最后，同步或者异步或者晚点异步的调用 <code>callHandlerAdded0</code> 方法</li></ol><p>4.6 前面说了 <code>dobind</code> 方法有 <code>2</code> 个重要的步骤，<code>initAndRegister</code> 说完，接下来看 <code>doBind0</code> 方法，代码如下</p><pre><code class="java">private static void doBind0(        final ChannelFuture regFuture, final Channel channel,        final SocketAddress localAddress, final ChannelPromise promise) &#123;    // This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up    // the pipeline in its channelRegistered() implementation.    channel.eventLoop().execute(new Runnable() &#123;        @Override        public void run() &#123;            if (regFuture.isSuccess()) &#123;                //bind方法这里下断点，这里下断点，来玩!!                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);            &#125; else &#123;                promise.setFailure(regFuture.cause());            &#125;        &#125;    &#125;);&#125;</code></pre><p>说明：</p><ol><li>该方法的参数为 <code>initAndRegister</code> 的 <code>future</code>，<code>NioServerSocketChannel</code>，端口地址，<code>NioServerSocketChannel</code> 的 <code>promise</code></li><li>这里就可以根据前面下的断点，一直 <code>debug</code>：</li></ol><pre><code class="java">// 将调用 LoggingHandler 的 invokeBind 方法,最后会追到// DefaultChannelPipeline 类的 bind// 然后进入到 unsafe.bind 方法 debug，注意要追踪到// unsafe.bind，要 debug 第二圈的时候，才能看到。@Overridepublic void bind (ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise) throws Exception &#123;    unsafe.bind(localAddress,promise);&#125;// 继续追踪 AbstractChannel 的 public final void bind (final SocketAddress localAddress, final ChannelPromise promise) &#123;    //....    try&#123;        //!!!! 小红旗可以看到，这里最终的方法就是 doBind 方法，执行成功后，执行通道的 fireChannelActive 方法，告诉所有的 handler，已经成功绑定。        doBind(localAddress);//    &#125; catch (Throwable t) &#123;        safeSetFailure(promise, t);        closeIfClosed();        return;    &#125;&#125;</code></pre><ol><li>最终 <code>doBind</code> 就会追踪到 <code>NioServerSocketChannel</code> 的 <code>doBind</code>，说明 <code>Netty</code> 底层使用的是 <code>NIO</code></li></ol><pre><code class="java">@Overrideprotected void doBind (SocketAddress localAddress) throws Exception &#123;    if (PlatformDependent.javaVersion() &gt;= 7) &#123;        javaChannel().bind(localAddress, config.getBacklog());    &#125; else &#123;        javaChannel().socket().bind(localAddress, config.getBacklog());    &#125;&#125;</code></pre><ol><li>回到 <code>bind</code> 方法（<code>alt + v</code>），最后一步：<code>safeSetSuccess(promise)</code>，告诉 <code>promise</code> 任务成功了。其可以执行监听器的方法了。到此整个启动过程已经结束了，ok 了</li><li>继续 <code>atl + v</code> 服务器就回进入到（<code>NioEventLoop</code> 类）一个循环代码，进行监听</li></ol><pre><code class="java">@Overrideprotected void run() &#123;    for(;;) &#123;        try&#123;        &#125;    &#125;&#125;</code></pre><h3 id="10-2-4-Netty-启动过程梳理"><a href="#10-2-4-Netty-启动过程梳理" class="headerlink" title="10.2.4 Netty 启动过程梳理"></a>10.2.4 Netty 启动过程梳理</h3><ol><li>创建 <code>2</code> 个 <code>EventLoopGroup</code> 线程池数组。数组默认大小 <code>CPU * 2</code>，方便 <code>chooser</code> 选择线程池时提高性能</li><li><code>BootStrap</code> 将 <code>boss</code> 设置为 <code>group</code> 属性，将 <code>worker</code> 设置为 <code>childer</code> 属性</li><li>通过 <code>bind</code> 方法启动，内部重要方法为 <code>initAndRegister</code> 和 <code>dobind</code> 方法</li><li><code>initAndRegister</code> 方法会反射创建 <code>NioServerSocketChannel</code> 及其相关的 <code>NIO</code> 的对象，<code>pipeline</code>，<code>unsafe</code>，同时也为 <code>pipeline</code> 初始了 <code>head</code> 节点和 <code>tail</code> 节点。</li><li>在 <code>register0</code> 方法成功以后调用在 <code>dobind</code> 方法中调用 <code>doBind0</code> 方法，该方法会调用 <code>NioServerSocketChannel</code> 的 <code>doBind</code> 方法对 <code>JDK</code> 的 <code>channel</code> 和端口进行绑定，完成 <code>Netty</code> 服务器的所有启动，并开始监听连接事件。</li></ol><h2 id="10-3-Netty-接受请求过程源码剖析"><a href="#10-3-Netty-接受请求过程源码剖析" class="headerlink" title="10.3 Netty 接受请求过程源码剖析"></a>10.3 Netty 接受请求过程源码剖析</h2><h3 id="10-3-1-源码剖析目的"><a href="#10-3-1-源码剖析目的" class="headerlink" title="10.3.1 源码剖析目的"></a>10.3.1 源码剖析目的</h3><ol><li>服务器启动后肯定是要接受客户端请求并返回客户端想要的信息的，下面源码分析 <code>Netty</code> 在启动之后是如何接受客户端请求的</li><li>在 <code>io.netty.example</code> 包下</li></ol><h3 id="10-3-2-源码剖析"><a href="#10-3-2-源码剖析" class="headerlink" title="10.3.2 源码剖析"></a>10.3.2 源码剖析</h3><p>说明：</p><ol><li>从之前服务器启动的源码中，我们得知，服务器最终注册了一个 <code>Accept</code> 事件等待客户端的连接。我们也知道，<code>NioServerSocketChannel</code> 将自己注册到了 <code>boss</code> 单例线程池（<code>reactor</code> 线程）上，也就是 <code>EventLoop</code>。</li><li>先简单说下 <code>EventLoop</code> 的逻辑(后面我们详细讲解 <code>EventLoop</code>)</li></ol><p><code>EventLoop</code> 的作用是一个死循环，而这个循环中做 3 件事情：</p><ol><li><p>有条件的等待 <code>NIO</code> 事件。</p></li><li><p>处理 <code>NIO</code> 事件。</p></li><li><p>处理消息队列中的任务。</p></li><li><p>仍用前面的项目来分析：进入到 <code>NioEventLoop</code> 源码中后，在 <code>private void processSelectedKey(SelectionKey k, AbstractNioChannel ch)</code> 方法开始调试最终我们要分析到 <code>AbstractNioChannel</code> 的 <code>doBeginRead</code> 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</p><p>源码分析过程</p></li><li><p>断点位置 <code>NioEventLoop</code> 的如下方法 <code>processSelectedKey</code></p></li></ol><pre><code class="java">if((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;    unsafe.read();//断点位置&#125;</code></pre><ol><li>执行浏览器 <code>http://localhost:8007/</code> ，客户端发出请求</li><li>从的断点我们可以看到，<code>readyOps</code> 是 <code>16</code>，也就是 <code>Accept</code> 事件。说明浏览器的请求已经进来了。</li><li>这个 <code>unsafe</code> 是 <code>boss</code> 线程中 <code>NioServerSocketChannel</code> 的 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 对象。我们进入到 <code>AbstractNioMessageChannel$NioMessageUnsafe</code> 的 <code>read</code> 方法中</li><li><code>read</code> 方法代码并分析:</li></ol><pre><code class="java">@Overridepublic void read() &#123;    asserteventLoop().inEventLoop();    final ChannelConfig config = config();    final ChannelPipeline pipeline = pipeline();    final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();    allocHandle.reset(config);    booleanclosed = false;    Throwable exception = null;    try &#123;        try &#123;            do &#123;                int localRead = doReadMessages(readBuf);                if (localRead == 0) &#123;                    break;                &#125;                if (localRead &lt; 0) &#123;                    closed = true;                    break;                &#125;                                allocHandle.incMessagesRead(localRead);            &#125; while (allocHandle.continueReading());        &#125; catch (Throwable t) &#123;            exception = t;        &#125;                int size = readBuf.size();        for (int i = 0; i &lt; size; i++) &#123;            readPending = false;            pipeline.fireChannelRead(readBuf.get(i));        &#125;        readBuf.clear();        allocHandle.readComplete();        pipeline.fireChannelReadComplete();                if (exception != null) &#123;            closed = closeOnReadError(exception);            pipeline.fireExceptionCaught(exception);        &#125;                if (closed) &#123;            inputShutdown = true;            if(isOpen()) &#123;                close(voidPromise());            &#125;        &#125;    &#125; finally &#123;        //Check if there is a readPending which was not processed yet.        //This could be for two reasons:        //* The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method        //* The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method        //        // See https://github.com/netty/netty/issues/2254        if (!readPending &amp;&amp; !config.isAutoRead()) &#123;            removeReadOp();        &#125;    &#125;&#125;</code></pre><p>说明： 1)检查该 <code>eventloop</code> 线程是否是当前线程。<code>asserteventLoop().inEventLoop()</code></p><p>2)执行 <code>doReadMessages</code> 方法，并传入一个 <code>readBuf</code> 变量，这个变量是一个 <code>List</code>，也就是容器。</p><p>3)循环容器，执行 <code>pipeline.fireChannelRead(readBuf.get(i));</code></p><p>4)<code>doReadMessages</code> 是读取 <code>boss</code> 线程中的 <code>NioServerSocketChannel</code> 接受到的请求。并把这些请求放进容器，一会我们 <code>debug</code> 下 <code>doReadMessages</code> 方法。</p><p>5)循环遍历容器中的所有请求，调用 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法，用于处理这些接受的请求或者其他事件，在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p><ol><li>追踪一下 <code>doReadMessages</code> 方法，就可以看得更清晰</li></ol><pre><code class="java">protected int doReadMessages (List&lt;Object&gt; buf) throws Exception &#123;    SocketChannel ch = SocketUtils.accept(javaChannel());    buf.add(newNioSocketChannel(this, ch));    return 1;&#125;</code></pre><p>说明： 1)通过工具类，调用 <code>NioServerSocketChannel</code> 内部封装的 <code>serverSocketChannel</code> 的 <code>accept</code> 方法，这是 <code>NIO</code> 做法。</p><p>2)获取到一个 <code>JDK</code> 的 <code>SocketChannel</code>，然后，使用 <code>NioSocketChannel</code> 进行封装。最后添加到容器中</p><p>3)这样容器 <code>buf</code> 中就有了 <code>NioSocketChannel</code> 【如果有兴趣可以追一下 <code>NioSocketChannel</code> 是如何创建的，我就不追了】</p><ol><li>回到 <code>read</code> 方法，继续分析循环执行 <code>pipeline.fireChannelRead</code> 方法</li></ol><p>1)前面分析 <code>doReadMessages</code> 方法的作用是通过 <code>ServerSocket</code> 的 <code>accept</code> 方法获取到 <code>TCP</code> 连接，然后封装成 <code>Netty</code> 的 <code>NioSocketChannel</code> 对象。最后添加到容器中</p><p>2)在 <code>read</code> 方法中，循环调用 <code>ServerSocket</code> 的 <code>pipeline</code> 的 <code>fireChannelRead</code> 方法,开始执行管道中的 <code>handler</code> 的 <code>ChannelRead</code> 方法（<code>debug</code> 进入）</p><p>3)经过 <code>dubug</code>（多次），可以看到会反复执行多个 <code>handler</code> 的 <code>ChannelRead</code>，我们知道，<code>pipeline</code> 里面又 <code>4</code> 个 <code>handler</code>，分别是 <code>Head</code>，<code>LoggingHandler</code>，<code>ServerBootstrapAcceptor</code>，<code>Tail</code>。</p><p>4)我们重点看看 <code>ServerBootstrapAcceptor</code>。<code>debug</code> 之后，断点会进入到 <code>ServerBootstrapAcceptor</code> 中来。我们来看看 <code>ServerBootstrapAcceptor</code> 的 <code>channelRead</code> 方法（要多次 <code>debug</code> 才可以）</p><p>5)<code>channelRead</code> 方法</p><pre><code class="java">public void channelRead (ChannelHandlerContext ctx, Object msg) &#123;    final Channelchild = (Channel)msg;    child.pipeline().addLast(childHandler);    setChannelOptions(child, childOptions, logger);    for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e : childAttrs) &#123;        child.attr((AttributeKey&lt;Object&gt;)e.getKey()).set(e.getValue());    &#125;    try &#123;//将客户端连接注册到 worker 线程池        childGroup.register(child).addListener(new ChannelFutureListener() &#123;            @Override            public void operationComplete(ChannelFuturefuture) throws Exception &#123;                if (!future.isSuccess()) &#123;                    forceClose(child, future.cause());                &#125;            &#125;        &#125;);    &#125; catch (Throwable t) &#123;        forceClose(child, t);    &#125;&#125;</code></pre><p>说明： 1)<code>msg</code> 强转成 <code>Channel</code>，实际上就是 <code>NioSocketChannel</code>。</p><p>2)添加 <code>NioSocketChannel</code> 的 <code>pipeline</code> 的 <code>handler</code>，就是我们 <code>main</code> 方法里面设置的 <code>childHandler</code> 方法里的。</p><p>3)设置 <code>NioSocketChannel</code> 的各种属性。</p><p>4)将该 <code>NioSocketChannel</code> 注册到 <code>childGroup</code> 中的一个 <code>EventLoop</code> 上，并添加一个监听器。</p><p>5)这个 <code>childGroup</code> 就是我们 <code>main</code> 方法创建的数组 <code>workerGroup</code>。</p><ol><li>进入 <code>register</code> 方法查看(步步追踪会到)</li></ol><pre><code class="java">@Overridepublic final void register (EventLoop eventLoop, final ChannelPromise promise) &#123;    AbstractChannel.this.eventLoop = eventLoop;    if (eventLoop.inEventLoop()) &#123;        register0(promise);    &#125; else &#123;        eventLoop.execute(new Runnable()&#123;            @Override            public void run() &#123;                register0(promise);//进入到这里            &#125;        &#125;);    &#125;&#125;// 继续进入到下面方法，执行管道中可能存在的任务,这里我们就不追了</code></pre><ol><li>最终会调用 <code>doBeginRead</code> 方法，也就是 <code>AbstractNioChannel</code> 类的方法</li></ol><pre><code class="java">@Overrideprotected void doBeginRead() throws Exception &#123;    //Channel.read() or ChannelHandlerContext.read() was called    final SelectionKey selectionKey = this.selectionKey;//断点    if (!selectionKey.isValid()) &#123;        return;    &#125;    readPending = true;    final int interestOps = selectionKey.interestOps();    if ((interestOps&amp;readInterestOp) == 0) &#123;        selectionKey.interestOps(interestOps | readInterestOp);    &#125;&#125;</code></pre><ol><li>这个地方调试时，请把前面的断点都去掉，然后启动服务器就会停止在 <code>doBeginRead</code>（需要先放过该断点，然后浏览器请求，才能看到效果）</li><li>执行到这里时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了</li></ol><h3 id="10-3-3-Netty-接受请求过程梳理"><a href="#10-3-3-Netty-接受请求过程梳理" class="headerlink" title="10.3.3 Netty 接受请求过程梳理"></a>10.3.3 Netty 接受请求过程梳理</h3><p>总体流程：接受连接 –&gt; 创建一个新的 <code>NioSocketChannel</code> –&gt; 注册到一个 <code>workerEventLoop</code> 上 –&gt; 注册 <code>selecotRead</code> 事件。</p><ol><li>服务器轮询 <code>Accept</code> 事件，获取事件后调用 <code>unsafe</code> 的 <code>read</code> 方法，这个 <code>unsafe</code> 是 <code>ServerSocket</code> 的内部类，该方法内部由 <code>2</code> 部分组成</li><li><code>doReadMessages</code> 用于创建 <code>NioSocketChannel</code> 对象，该对象包装 <code>JDK</code> 的 <code>NioChannel</code> 客户端。该方法会像创建 <code>ServerSocketChanel</code> 类似创建相关的 <code>pipeline</code>，<code>unsafe</code>，<code>config</code></li><li>随后执行执行 <code>pipeline.fireChannelRead</code> 方法，并将自己绑定到一个 <code>chooser</code> 选择器选择的 <code>workerGroup</code> 中的一个 <code>EventLoop</code>。并且注册一个 <code>0</code>，表示注册成功，但并没有注册读（1）事件</li></ol><h2 id="10-4-Pipeline-Handler-HandlerContext-创建源码剖析"><a href="#10-4-Pipeline-Handler-HandlerContext-创建源码剖析" class="headerlink" title="10.4 Pipeline Handler HandlerContext 创建源码剖析"></a>10.4 Pipeline Handler HandlerContext 创建源码剖析</h2><h3 id="10-4-1-源码剖析目的"><a href="#10-4-1-源码剖析目的" class="headerlink" title="10.4.1 源码剖析目的"></a>10.4.1 源码剖析目的</h3><p><code>Netty</code> 中的 <code>ChannelPipeline</code>、<code>ChannelHandler</code> 和 <code>ChannelHandlerContext</code> 是非常核心的组件，我们从源码来分析 <code>Netty</code> 是如何设计这三个核心组件的，并分析是如何创建和协调工作的.</p><h3 id="10-4-2-源码剖析说明"><a href="#10-4-2-源码剖析说明" class="headerlink" title="10.4.2 源码剖析说明"></a>10.4.2 源码剖析说明</h3><p>说明 分析过程中，有很多的图形，所以我们准备了一个文档，在文档的基础上来做源码剖析</p><h3 id="10-4-3-源码剖析"><a href="#10-4-3-源码剖析" class="headerlink" title="10.4.3 源码剖析"></a>10.4.3 源码剖析</h3><ol><li>ChannelPipeline | ChannelHandler | ChannelHandlerContext介绍</li><li>1 三者关系</li></ol><p>1)每当 <code>ServerSocket</code> 创建一个新的连接，就会创建一个 <code>Socket</code>，对应的就是目标客户端。</p><p>2)每一个新创建的 <code>Socket</code> 都将会分配一个全新的 <code>ChannelPipeline</code>（以下简称 <code>pipeline</code>）</p><p>3)每一个 <code>ChannelPipeline</code> 内部都含有多个 <code>ChannelHandlerContext</code>（以下简称 <code>Context</code>）</p><p>4)他们一起组成了双向链表，这些 <code>Context</code> 用于包装我们调用 <code>addLast</code> 方法时添加的 <code>ChannelHandler</code>（以下简称 <code>handler</code>）</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_02.png" alt="img"></p><p>1)上图中：<code>ChannelSocket</code> 和 <code>ChannelPipeline</code> 是一对一的关联关系，而 <code>pipeline</code> 内部的多个 <code>Context</code> 形成了链表，<code>Context</code> 只是对 <code>Handler</code> 的封装。 2)当一个请求进来的时候，会进入 <code>Socket</code> 对应的 <code>pipeline</code>，并经过 <code>pipeline</code> 所有的 <code>handler</code>，对，就是设计模式中的过滤器模式。</p><p>1.2 ChannelPipeline 作用及设计</p><p>1)<code>pipeline</code> 的接口设计</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_03.png" alt="img"></p><p>部分源码</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_04.png" alt="img"></p><p>可以看到该接口继承了 <code>inBound</code>，<code>outBound</code>，<code>Iterable</code> 接口，表示他可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，看看他的几个代表性的方法，基本上都是针对 <code>handler</code> 链表的插入，追加，删除，替换操作，类似是一个 <code>LinkedList</code>。同时，也能返回 <code>channel</code>（也就是 <code>socket</code>）</p><p>1)在 <code>pipeline</code> 的接口文档上，提供了一幅图</p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_05.png" alt="img " style="zoom:80%;" /><p>对上图的解释说明： *这是一个 <code>handler</code> 的 <code>list</code>，<code>handler</code> 用于处理或拦截入站事件和出站事件，<code>pipeline</code> 实现了过滤器的高级形式，以便用户控制事件如何处理以及 <code>handler</code> 在 <code>pipeline</code> 中如何交互。</p><p>*上图描述了一个典型的 <code>handler</code> 在 <code>pipeline</code> 中处理 <code>I/O</code> 事件的方式，<code>IO</code> 事件由 <code>inboundHandler</code> 或者 <code>outBoundHandler</code> 处理，并通过调用 <code>ChannelHandlerContext.fireChannelRead</code> 方法转发给其最近的处理程序。</p><p>*入站事件由入站处理程序以自下而上的方向处理，如图所示。入站处理程序通常处理由图底部的 <code>I/O</code> 线程生成入站数据。入站数据通常从如 <code>SocketChannel.read(ByteBuffer)</code> 获取。</p><p>*通常一个 <code>pipeline</code> 有多个 <code>handler</code>，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序协议解码器-将二进制数据转换为 <code>Java</code> 对象。协议编码器-将 <code>Java</code> 对象转换为二进制数据。业务逻辑处理程序-执行实际业务逻辑（例如数据库访问）</p><p>*你的业务程序不能将线程阻塞，会影响 <code>IO</code> 的速度，进而影响整个 <code>Netty</code> 程序的性能。如果你的业务程序很快，就可以放在 <code>IO</code> 线程中，反之，你需要异步执行。或者在添加 <code>handler</code> 的时候添加一个线程池，例如：</p><p>// 下面这个任务执行的时候，将不会阻塞 <code>IO</code> 线程，执行的线程来自 <code>group</code> 线程池</p><pre><code>pipeline.addLast(group, &quot;handler&quot;, new MyBusinessLogicHandler());</code></pre><p>1.3 <code>ChannelHandler</code> 作用及设计</p><p>1)源码</p><pre><code class="java">public interface ChannelHandler &#123;    //当把 ChannelHandler 添加到 pipeline 时被调用    void handlerAdded(ChannelHandlerContext ctx) throws Exception;    //当从 pipeline 中移除时调用    void handlerRemoved(ChannelHandlerContext ctx) throws Exception;    //当处理过程中在 pipeline 发生异常时调用    @Deprecated    void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception;&#125;</code></pre><p>2)<code>ChannelHandler</code> 的作用就是处理 <code>IO</code> 事件或拦截 <code>IO</code> 事件，并将其转发给下一个处理程序 <code>ChannelHandler</code>。<code>Handler</code> 处理事件时分入站和出站的，两个方向的操作都是不同的，因此，<code>Netty</code> 定义了两个子接口继承 <code>ChannelHandler</code></p><p>2)<code>ChannelInboundHandler</code> 入站事件接口</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_06.png" alt="img"></p><p>*<code>channelActive</code> 用于当 <code>Channel</code> 处于活动状态时被调用；</p><p>*<code>channelRead</code> 当从 <code>Channel</code> 读取数据时被调用等等方法。</p><p>*程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因为当事件发生时，<code>Netty</code> 会回调对应的方法。</p><p>3)`ChannelOutboundHandler 出站事件接口</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_07.png" alt="img"></p><p>*<code>bind</code> 方法，当请求将 <code>Channel</code> 绑定到本地地址时调用</p><p>*<code>close</code> 方法，当请求关闭 <code>Channel</code> 时调用等等</p><p>*出站操作都是一些连接和写出数据类似的方法。</p><p>4)<code>ChannelDuplexHandler</code> 处理出站和入站事件</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_08.png" alt="img"></p><p>*<code>ChannelDuplexHandler</code> 间接实现了入站接口并直接实现了出站接口。</p><p>*是一个通用的能够同时处理入站事件和出站事件的类。</p><p>1.4 <code>ChannelHandlerContext</code> 作用及设计</p><p>1)<code>ChannelHandlerContext</code> <code>UML</code> 图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_09.png" alt="img"></p><p><code>ChannelHandlerContext</code> 继承了出站方法调用接口和入站方法调用接口</p><p>1)<code>ChannelOutboundInvoker</code> 和 <code>ChannelInboundInvoker</code> 部分源码</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_10.png" alt="img"></p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_11.png" alt="img"></p><p>*这两个 <code>invoker</code> 就是针对入站或出站方法来的，就是在入站或出站 <code>handler</code> 的外层再包装一层，达到在方法前后拦截并做一些特定操作的目的</p><p>2)<code>ChannelHandlerContext</code> 部分源码</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_12.png" alt="img"></p><p>*<code>ChannelHandlerContext</code> 不仅仅时继承了他们两个的方法，同时也定义了一些自己的方法</p><p>*这些方法能够获取 <code>Context</code> 上下文环境中对应的比如 <code>channel</code>，<code>executor</code>，<code>handler</code>，<code>pipeline</code>，内存分配器，关联的 <code>handler</code> 是否被删除。</p><p>*<code>Context</code> 就是包装了 <code>handler</code> 相关的一切，以方便 <code>Context</code> 可以在 <code>pipeline</code> 方便的操作 <code>handler</code></p><p>2.ChannelPipeline | ChannelHandler | ChannelHandlerContext</p><p>创建过程分为 <code>3</code> 个步骤来看创建的过程：</p><p>*任何一个 <code>ChannelSocket</code> 创建的同时都会创建一个 <code>pipeline</code>。</p><p>*当用户或系统内部调用 <code>pipeline</code> 的 <code>add</code></p><p>*** 方法添加 <code>handler</code> 时，都会创建一个包装这 <code>handler</code> 的 <code>Context</code>。</p><p>*这些 <code>Context</code> 在 <code>pipeline</code> 中组成了双向链表。</p><p>2.1 <code>Socket</code> 创建的时候创建 <code>pipeline</code> 在 <code>SocketChannel</code> 的抽象父类 <code>AbstractChannel</code> 的构造方法中</p><pre><code class="java">protected AbstractChannel(Channel parent) &#123;    this.parent=parent;//断点测试    id = newId();    unsafe = new Unsafe();    pipeline = new ChannelPipeline();&#125;</code></pre><p><code>Debug</code> 一下，可以看到代码会执行到这里，然后继续追踪到</p><pre><code class="java">protected DefaultChannelPipeline(Channel channel) &#123;    this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);    succeededFuture = new SucceededChannelFuture(channel, null);    voidPromise = new VoidChannelPromise(channel, true);    tail = new TailContext(this);    head = new HeadContext(this);    head.next = tail;    tail.prev = head;&#125;</code></pre><p>说明：</p><p>1）将 <code>channel</code> 赋值给 <code>channel</code> 字段，用于 <code>pipeline</code> 操作 <code>channel</code>。</p><p>2）创建一个 <code>future</code> 和 <code>promise</code>，用于异步回调使用。</p><p>3）创建一个 <code>inbound</code> 的 <code>tailContext</code>，创建一个既是 <code>inbound</code> 类型又是 <code>outbound</code> 类型的 <code>headContext</code>。</p><p>4）最后，将两个 <code>Context</code> 互相连接，形成双向链表。</p><p>5）<code>tailContext</code> 和 <code>HeadContext</code> 非常的重要，所有 <code>pipeline</code> 中的事件都会流经他们，</p><p>2.2 在 add<strong>添加处理器的时候创建Context</strong>看下 <code>DefaultChannelPipeline</code> 的 <code>addLast</code> 方法如何创建的 <code>Context</code>，代码如下</p><pre><code class="java">@Overridepublic final ChannelPipeline addLast(EventExecutorGroup executor, ChannelHandler... handlers) &#123;    if (handlers == null) &#123;//断点        throw new NullPointerException(&quot;handlers&quot;);    &#125;    for (ChannelHandler h : handlers) &#123;        if (h == null) &#123;            break;        &#125;        addLast(executor, null, h);    &#125;    return this;&#125;</code></pre><p>继续 Debug</p><pre><code class="java">public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) &#123;    final AbstractChannelHandlerContext newCtx;    synchronized(this) &#123;        checkMultiplicity(handler);        newCtx = newContext(group, filterName(name, handler), handler);        addLast0(newCtx);        //If the registered is false it means that the channel was not registered on an eventloop yet.        //In this case we add the context to the pipeline and add a task that will call        //ChannelHandler.handlerAdded(...) once the channel is registered.        if (!registered) &#123;            newCtx.setAddPending();            callHandlerCallbackLater(newCtx, true);            return this;        &#125;        EventExecutor executor = newCtx.executor();        if (!executor.inEventLoop()) &#123;            newCtx.setAddPending();            executor.execute(new Runnable() &#123;                @Override                public void run () &#123;                    callHandlerAdded0(newCtx);                &#125;            &#125;);            return this;        &#125;    &#125;    callHandlerAdded0(newCtx);    return this;&#125;</code></pre><p>说明 1)<code>pipeline</code> 添加 <code>handler</code>，参数是线程池，<code>name</code> 是 <code>null</code>，<code>handler</code> 是我们或者系统传入的 <code>handler</code>。<code>Netty</code> 为了防止多个线程导致安全问题，同步了这段代码，步骤如下：</p><p>2)检查这个 <code>handler</code> 实例是否是共享的，如果不是，并且已经被别的 <code>pipeline</code> 使用了，则抛出异常。</p><p>3)调用 <code>new Context(group, filterName(name, handler), handler)</code> 方法，创建一个 <code>Context</code>。从这里可以看出来了，每次添加一个 <code>handler</code> 都会创建一个关联 <code>Context</code>。</p><p>4)调用 <code>addLast</code> 方法，将 <code>Context</code> 追加到链表中。</p><p>5)如果这个通道还没有注册到 <code>selecor</code> 上，就将这个 <code>Context</code> 添加到这个 <code>pipeline</code> 的待办任务中。当注册好了以后，就会调用 <code>callHandlerAdded0</code> 方法（默认是什么都不做，用户可以实现这个方法）。</p><p>6)到这里，针对三对象创建过程，了解的差不多了，和最初说的一样，每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。<code>tail</code> 是入站 <code>inbound</code> 类型的 <code>handler</code>，<code>head</code> 既是 <code>inbound</code> 也是 <code>outbound</code> 类型的 <code>handler</code>。在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。到此就 <code>OK</code> 了。</p><h3 id="10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理"><a href="#10-4-4-Pipeline-Handler-HandlerContext-创建过程梳理" class="headerlink" title="10.4.4 Pipeline Handler HandlerContext 创建过程梳理"></a>10.4.4 Pipeline Handler HandlerContext 创建过程梳理</h3><ol><li>每当创建 <code>ChannelSocket</code> 的时候都会创建一个绑定的 <code>pipeline</code>，一对一的关系，创建 <code>pipeline</code> 的时候也会创建 <code>tail</code> 节点和 <code>head</code> 节点，形成最初的链表。</li><li>在调用 <code>pipeline</code> 的 <code>addLast</code> 方法的时候，会根据给定的 <code>handler</code> 创建一个 <code>Context</code>，然后，将这个 <code>Context</code> 插入到链表的尾端（<code>tail</code> 前面）。</li><li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表</li><li>入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始</li></ol><h2 id="10-5-ChannelPipeline-调度-handler-的源码剖析"><a href="#10-5-ChannelPipeline-调度-handler-的源码剖析" class="headerlink" title="10.5 ChannelPipeline 调度 handler 的源码剖析"></a>10.5 ChannelPipeline 调度 handler 的源码剖析</h2><h3 id="10-5-1-源码剖析目的"><a href="#10-5-1-源码剖析目的" class="headerlink" title="10.5.1 源码剖析目的"></a>10.5.1 源码剖析目的</h3><ol><li><p>当一个请求进来的时候，<code>ChannelPipeline</code> 是如何调用内部的这些 <code>handler</code> 的呢？我们一起来分析下。</p></li><li><p>首先，当一个请求进来的时候，会第一个调用 <code>pipeline</code> 的相关方法，如果是入站事件，这些方法由 <code>fire</code> 开头，表示开始管道的流动。让后面的 <code>handler</code> 继续处理</p><h3 id="10-5-2-源码剖析"><a href="#10-5-2-源码剖析" class="headerlink" title="10.5.2 源码剖析"></a>10.5.2 源码剖析</h3></li></ol><p>说明</p><p>当浏览器输入 <code>http://localhost:8007</code> 。可以看到会执行 <code>handler</code> 在 <code>Debug</code> 时，可以将断点下在 <code>DefaultChannelPipeline</code> 类的</p><pre><code class="java">public final ChannelPipeline fireChannelActive() &#123;    AbstractChannelHandlerContext.invokeChannelActive(head);//断点    return this;&#125;</code></pre><p>源码分析</p><ol><li><code>DefaultChannelPipeline</code> 是如何实现这些 <code>fire</code> 方法的 3.1 <code>DefaultChannelPipeline</code> 源码</li></ol><pre><code class="java">public class DefaultChannelPipeline implements ChannelPipeline &#123;    @Override    public final ChannelPipeline fireChannelActive() &#123;        AbstractChannelHandlerContext.invokeChannelActive(head);        return this;    &#125;        @Override    public final ChannelPipelinefireChannelInactive() &#123;        AbstractChannelHandlerContext.invokeChannelInactive(head);        return this;    &#125;        @Override    public final ChannelPipeline fireExceptionCaught(Throwable cause) &#123;        AbstractChannelHandlerContext.invokeExceptionCaught(head, cause);        return this;    &#125;        @Override    public final ChannelPipeline fireUserEventTriggered(Object event) &#123;        AbstractChannelHandlerContext.invokeUserEventTriggered(head, event);        return this;    &#125;        @Override    public final ChannelPipeline fireChannelRead(Objectmsg) &#123;        AbstractChannelHandlerContext.invokeChannelRead(head, msg);        return this;    &#125;        @Override    public final ChannelPipeline fireChannelReadComplete() &#123;        AbstractChannelHandlerContext.invokeChannelReadComplete(head);        return this;    &#125;        @Override    public final ChannelPipeline fireChannelWritabilityChanged() &#123;        AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head);        return this;    &#125;&#125;</code></pre><p>说明： 可以看出来，这些方法都是 <code>inbound</code> 的方法，也就是入站事件，调用静态方法传入的也是 <code>inbound</code> 的类型 <code>head</code> <code>handler</code>。这些静态方法则会调用 <code>head</code> 的 <code>ChannelInboundInvoker</code> 接口的方法，再然后调用 <code>handler</code> 的真正方法</p><p>3.2再看下 <code>piepline</code> 的 <code>outbound</code> 的 <code>fire</code> 方法实现源码</p><pre><code class="java">public class DefaultChannelPipeline implements ChannelPipeline &#123;    @Override    public final ChannelFuture bind(SocketAddress localAddress) &#123;        return tail.bind(localAddress);    &#125;        @Override    public final ChannelFuture connect(SocketAddress remoteAddress) &#123;        return tail.connect(remoteAddress);    &#125;        @Override    public final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) &#123;        return tail.connect(remoteAddress, localAddress);    &#125;        @Override    public final ChannelFuture disconnect()&#123;        return tail.disconnect();    &#125;        @Override    public final ChannelFuture close() &#123;        return tail.close();    &#125;        @Override    public final ChannelFuture deregister() &#123;        return tail.deregister();    &#125;        @Override    public final ChannelPipeline flush() &#123;        tail.flush();        return this;    &#125;        @Override    public final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;        return tail.bind(localAddress, promise);    &#125;        @Override    public final ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;        return tail.connect(remoteAddress, promise);    &#125;        @Override    public final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) &#123;        return tail.connect(remoteAddress, localAddress, promise);    &#125;        @Override    public final ChannelFuture disconnect(ChannelPromise promise) &#123;        return tail.disconnect(promise);    &#125;&#125;</code></pre><p>说明：</p><p>1)这些都是出站的实现，但是调用的是 <code>outbound</code> 类型的 <code>tailhandler</code> 来进行处理，因为这些都是 <code>outbound</code> 事件。</p><p>2)出站是 <code>tail</code> 开始，入站从 <code>head</code> 开始。因为出站是从内部向外面写，从 <code>tail</code> 开始，能够让前面的 <code>handler</code> 进行处理，防止 <code>handler</code> 被遗漏，比如编码。反之，入站当然是从 <code>head</code> 往内部输入，让后面的 <code>handler</code> 能够处理这些输入的数据。比如解码。因此虽然 <code>head</code> 也实现了 <code>outbound</code> 接口，但不是从 head 开始执行出站任务</p><p>4.关于如何调度，用一张图来表示:</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_13.png" alt="img"></p><p>说明：</p><p> 1)<code>pipeline</code> 首先会调用 <code>Context</code> 的静态方法 <code>fireXXX</code>，并传入 <code>Context</code></p><p>2)然后，静态方法调用 <code>Context</code> 的 <code>invoker</code> 方法，而 <code>invoker</code> 方法内部会调用该 <code>Context</code> 所包含的 <code>Handler</code> 的真正的 <code>XXX</code> 方法，调用结束后，如果还需要继续向后传递，就调用 <code>Context</code> 的 <code>fireXXX2</code> 方法，循环往复。</p><h3 id="10-5-3-ChannelPipeline-调度-handler-梳理"><a href="#10-5-3-ChannelPipeline-调度-handler-梳理" class="headerlink" title="10.5.3 ChannelPipeline 调度 handler 梳理"></a>10.5.3 ChannelPipeline 调度 handler 梳理</h3><ol><li><code>Context</code> 包装 <code>handler</code>，多个 <code>Context</code> 在 <code>pipeline</code> 中形成了双向链表，入站方向叫 <code>inbound</code>，由 <code>head</code> 节点开始，出站方法叫 <code>outbound</code>，由 <code>tail</code> 节点开始。</li><li>而节点中间的传递通过 <code>Abstract ChannelHandlerContext</code> 类内部的 <code>fire</code> 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对 <code>handler</code> 的调度</li></ol><h2 id="10-6-Netty-心跳-heartbeat-服务源码剖析"><a href="#10-6-Netty-心跳-heartbeat-服务源码剖析" class="headerlink" title="10.6 Netty 心跳(heartbeat)服务源码剖析"></a>10.6 Netty 心跳(heartbeat)服务源码剖析</h2><h3 id="10-6-1-源码剖析目的"><a href="#10-6-1-源码剖析目的" class="headerlink" title="10.6.1 源码剖析目的"></a>10.6.1 源码剖析目的</h3><p><code>Netty</code> 作为一个网络框架，提供了诸多功能，比如编码解码等，<code>Netty</code> 还提供了非常重要的一个服务 – 心跳机制 <code>heartbeat</code>。通过心跳检查对方是否有效，这是 <code>RPC</code> 框架中是必不可少的功能。下面我们分析一下 <code>Netty</code> 内部心跳服务源码实现。</p><h3 id="10-6-2-源码剖析"><a href="#10-6-2-源码剖析" class="headerlink" title="10.6.2 源码剖析"></a>10.6.2 源码剖析</h3><p>5.<code>Netty</code> 提供的心跳介绍</p><p>1)<code>Netty</code> 提供了 <code>IdleStateHandler</code>，<code>ReadTimeoutHandler</code>，<code>WriteTimeoutHandler</code> 三个 <code>Handler</code> 检测连接的有效性。</p><p>2)如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_15.png" alt="img"></p><p>3)<code>ReadTimeout</code> 事件和 <code>WriteTimeout</code> 事件都会自动关闭连接，而且，属于异常处理，所以，这里只是介绍以下，我们重点看 <code>IdleStateHandler</code>。</p><p>6.<code>IdleStateHandler</code> 分析</p><p>6.1 <code>4</code> 个属性</p><pre><code class="java">private final boolean observeOutput; //是否考虑出站时较慢的情况。默认值是 falseprivate final long readerIdleTimeNanos; //读事件空闲时间，0 则禁用事件private final long writerIdleTimeNanos;//写事件空闲时间，0 则禁用事件private final long allIdleTimeNanos;//读或写空闲时间，0 则禁用事件</code></pre><p>6.2<code>handlerAdded</code> 方法</p><p>当该 <code>handler</code> 被添加到 <code>pipeline</code> 中时，则调用 <code>initialize</code> 方法</p><pre><code class="java">private void initialize(ChannelHandlerContext ctx) &#123;    //Avoid the case where destroy() is called before scheduling timeouts.    //See:https://github.com/netty/netty/issues/143    switch(state) &#123;        case1:        case2:            return;    &#125;        state=1;    initOutputChanged(ctx);        lastReadTime = lastWriteTime = ticksInNanos();        if(readerIdleTimeNanos &gt; 0) &#123;        //这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列中        readerIdleTimeout = schedule(ctx, new ReaderIdleTimeoutTask(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;        if(writerIdleTimeNanos &gt; 0) &#123;        writerIdleTimeout = schedule(ctx, new WriterIdleTimeoutTask(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;        if(allIdleTimeNanos &gt; 0) &#123;        allIdleTimeout = schedule(ctx, new AllIdleTimeoutTask(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre><p>只要给定的参数大于 <code>0</code>，就创建一个定时任务，每个事件都创建。同时，将 <code>state</code> 状态设置为 <code>1</code>，防止重复初始化。调用 <code>initOutputChanged</code> 方法，初始化“监控出站数据属性”。</p><p>6.3该类内部的 <code>3</code> 个定时任务类</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_16.png" alt="img"></p><p>1)这 <code>3</code> 个定时任务分别对应读，写，读或者写事件。共有一个父类（<code>AbstractIdleTask</code>）。这个父类提供了一个模板方法</p><pre><code class="java">private abstract static class AbstractIdleTask implements Runnable &#123;        private final ChannelHandlerContext ctx;        AbstractIdleTask(ChannelHandlerContext ctx) &#123;        this.ctx = ctx;    &#125;        @Override    public void run() &#123;        if(!ctx.channel().isOpen()) &#123;            return;        &#125;        run(ctx);    &#125;        protected abstract void run(ChannelHandlerContext ctx);&#125;</code></pre><p>说明：当通道关闭了，就不执行任务了。反之，执行子类的 <code>run</code> 方法</p><p>7.读事件的 <code>run</code> 方法（即 <code>ReaderIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>1)代码及其说明</p><pre><code class="java">@Overrideprotected void run(ChannelHandlerContext ctx) &#123;    long nextDelay = readerIdleTimeNanos;    if(!reading) &#123;        nextDelay -= ticksInNanos() - lastReadTime;    &#125;        if(nextDelay &lt;= 0) &#123;        //Reader is idle-set a new timeout and notify the callback.        //用于取消任务 promise        readerIdleTimeout = schedule(ctx, this, readerIdleTimeNanos, TimeUnit.NANOSECONDS);        boolean first = firstReaderIdleEvent;        firstReaderIdleEvent = false;        try &#123;            //再次提交任务            IdleStateEvent event = new IdleStateEvent(IdleState.READER_IDLE, first);            //触发用户 handler use            channelIdle(ctx, event);        &#125; catch (Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; else &#123;        //Read occurred before the timeout - set a new timeout with shorter delay.        readerIdleTimeout = schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre><p>说明：</p><p>1)得到用户设置的超时时间。</p><p>2)如果读取操作结束了（执行了 <code>channelReadComplete</code> 方法设置），就用当前时间减去给定时间和最后一次读（执操作的时间行了 <code>channelReadComplete</code> 方法设置），如果小于 <code>0</code>，就触发事件。反之，继续放入队列。间隔时间是新的计算时间。</p><p>3)触发的逻辑是：首先将任务再次放到队列，时间是刚开始设置的时间，返回一个 <code>promise</code> 对象，用于做取消操作。然后，设置 <code>first</code> 属性为<code>false</code>，表示，下一次读取不再是第一次了，这个属性在 <code>channelRead</code> 方法会被改成 <code>true</code>。</p><p>4)创建一个 <code>IdleStateEvent</code> 类型的写事件对象，将此对象传递给用户的 <code>UserEventTriggered</code> 方法。完成触发事件的操作。</p><p>5)总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果间隔超过了设置的时间，就触发 <code>UserEventTriggered</code> 方法。//前面介绍 <code>IdleStateHandler</code> 说过,可以看一下</p><p>8.写事件的 <code>run</code> 方法（即 <code>WriterIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>1)<code>run</code> 代码和分析</p><pre><code class="java">@Overrideprotected void run(ChannelHandlerContext ctx) &#123;    long lastWriteTime = IdleStateHandler.this.lastWriteTime;    long nextDelay = writerIdleTimeNanos - (ticksInNanos()-lastWriteTime);    if (nextDelay &lt;=0 ) &#123;        //Writer is idle - set a new timeout and notify the callback.        writerIdleTimeout = schedule(ctx, this, writerIdleTimeNanos, TimeUnit.NANOSECONDS);        boolean first = firstWriterIdleEvent;        firstWriterIdleEvent = false;        try &#123;            if(hasOutputChanged(ctx, first)) &#123;                return;            &#125;                        IdleStateEvent event = new IdleStateEvent(IdleState.WRITER_IDLE, first);            channelIdle(ctx, event);        &#125; catch (Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; else &#123;        //Write occurred before the timeout - set a new timeout with shorter delay.        writerIdleTimeout = schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre><p>说明：写任务的 <code>run</code> 代码逻辑基本和读任务的逻辑一样，唯一不同的就是有一个针对出站较慢数据的判断 <code>hasOutputChanged</code></p><p>9.所有事件的 <code>run</code> 方法（即 <code>AllIdleTimeoutTask</code> 的 <code>run</code> 方法）分析</p><p>代码分析</p><pre><code class="java">@Overrideprotected void run(ChannelHandlerContext ctx) &#123;    long nextDelay = allIdleTimeNanos;    if(!reading) &#123;        nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);    &#125;        if(nextDelay &lt;= 0) &#123;        //Both reader and writer are idle - set a new timeout and        //notify the callback.        allIdleTimeout = schedule(ctx, this, allIdleTimeNanos, TimeUnit.NANOSECONDS);        boolean first = firstAllIdleEvent;        firstAllIdleEvent = false;        try &#123;            if(hasOutputChanged(ctx, first)) &#123;                return;            &#125;                        IdleStateEvent event = new IdleStateEvent(IdleState.ALL_IDLE, first);            channelIdle(ctx, event);        &#125; catch(Throwable t) &#123;            ctx.fireExceptionCaught(t);        &#125;    &#125; else &#123;        //Either read or write occurred before the timeout - set a new        //timeout with shorter delay.        allIdleTimeout = schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS);    &#125;&#125;</code></pre><p>说明：</p><p>1)表示这个监控着所有的事件。当读写事件发生时，都会记录。代码逻辑和写事件的的基本一致：</p><p>2)需要大家注意的地方是</p><pre><code class="java">long nextDelay = allIdleTimeNanos;if(!reading) &#123;    //当前时间减去最后一次写或读的时间，若大于 0，说明超时了    nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);&#125;</code></pre><p>3)这里的时间计算是取读写事件中的最大值来的。然后像写事件一样，判断是否发生了写的慢的情况。</p><p>10.小结 <code>Netty</code> 的心跳机制</p><p>1)<code>IdleStateHandler</code> 可以实现心跳功能，当服务器和客户端没有任何读写交互时，并超过了给定的时间，则会触发用户 <code>handler</code> 的 <code>userEventTriggered</code> 方法。用户可以在这个方法中尝试向对方发送信息，如果发送失败，则关闭连接。</p><p>2)<code>IdleStateHandler</code> 的实现基于 <code>EventLoop</code> 的定时任务，每次读写都会记录一个值，在定时任务运行的时候，通过计算当前时间和设置时间和上次事件发生时间的结果，来判断是否空闲。</p><p>3)内部有 <code>3</code> 个定时任务，分别对应读事件，写事件，读写事件。通常用户监听读写事件就足够了。</p><p>4)同时，<code>IdleStateHandler</code> 内部也考虑了一些极端情况：客户端接收缓慢，一次接收数据的速度超过了设置的空闲时间。<code>Netty</code> 通过构造方法中的 <code>observeOutput</code> 属性来决定是否对出站缓冲区的情况进行判断。</p><p>5)如果出站缓慢，<code>Netty</code> 不认为这是空闲，也就不触发空闲事件。但第一次无论如何也是要触发的。因为第一次无法判断是出站缓慢还是空闲。当然，出站缓慢的话，可能造成 <code>OOM</code>，<code>OOM</code> 比空闲的问题更大。</p><p>6)所以，当你的应用出现了内存溢出，<code>OOM</code> 之类，并且写空闲极少发生（使用了 <code>observeOutput</code> 为 <code>true</code>），那么就需要注意是不是数据出站速度过慢。</p><p>7)还有一个注意的地方：就是 <code>ReadTimeoutHandler</code>，它继承自 <code>IdleStateHandler</code>，当触发读空闲事件的时候，就触发 <code>ctx</code>. <code>fireExceptionCaught</code> 方法，并传入一个 <code>ReadTimeoutException</code>，然后关闭 <code>Socket</code>。</p><p>8)而 <code>WriteTimeoutHandler</code> 的实现不是基于 <code>IdleStateHandler</code> 的，他的原理是，当调用 <code>write</code> 方法的时候，会创建一个定时任务，任务内容是根据传入的 <code>promise</code> 的完成情况来判断是否超出了写的时间。当定时任务根据指定时间开始运行，发现 <code>promise</code> 的 <code>isDone</code> 方法返回 <code>false</code>，表明还没有写完，说明超时了，则抛出异常。当 <code>write</code> 方法完成后，会打断定时任务。</p><h2 id="10-7-Netty-核心组件-EventLoop-源码剖析"><a href="#10-7-Netty-核心组件-EventLoop-源码剖析" class="headerlink" title="10.7 Netty 核心组件 EventLoop 源码剖析"></a>10.7 Netty 核心组件 EventLoop 源码剖析</h2><h3 id="10-7-1-源码剖析目的"><a href="#10-7-1-源码剖析目的" class="headerlink" title="10.7.1 源码剖析目的"></a>10.7.1 源码剖析目的</h3><p><code>Echo</code> 第一行代码就是：<code>EventLoopGroup bossGroup = new NioEventLoopGroup(1)</code>; 下面分析其最核心的组件 <code>EventLoop</code>。</p><h3 id="10-7-2-源码剖析"><a href="#10-7-2-源码剖析" class="headerlink" title="10.7.2 源码剖析"></a>10.7.2 源码剖析</h3><p>源码剖析</p><p>1.<code>EventLoop</code>介绍 1.1首先看看 <code>NioEventLoop</code> 的继承图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_17.png" alt="img"></p><p>说明重点：</p><p> 1)<code>ScheduledExecutorService</code> 接口表示是一个定时任务接口，<code>EventLoop</code> 可以接受定时任务。</p><p>2)<code>EventLoop</code> 接口：<code>Netty</code> 接口文档说明该接口作用：一旦 <code>Channel</code> 注册了，就处理该 <code>Channel</code> 对应的所有 <code>I/O</code> 操作。</p><p>3)<code>SingleThreadEventExecutor</code> 表示这是一个单个线程的线程池</p><p>4)<code>EventLoop</code> 是一个单例的线程池，里面含有一个死循环的线程不断的做着 <code>3</code> 件事情：监听端口，处理端口事件，处理队列事件。每个 <code>EventLoop</code> 都可以绑定多个 <code>Channel</code>，而每个 <code>Channel</code> 始终只能由一个 <code>EventLoop</code> 来处理</p><ol><li><code>NioEventLoop</code> 的使用 - <code>execute</code> 方法</li></ol><p>2.1 <code>execute</code> 源码剖析</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_18.png" alt="img"></p><p>在 <code>EventLoop</code> 的使用，一般就是 <code>eventloop.execute(task);</code> 看下 <code>execute</code> 方法的实现(在 <code>SingleThreadEventExecutor</code> 类中)</p><pre><code class="java">@Overridepublic void execute(Runnable task) &#123;    if(task == null) &#123;        throw new NullPointerException(&quot;task&quot;);    &#125;    boolean inEventLoop = inEventLoop();    if(inEventLoop) &#123;        addTask(task);    &#125; else &#123;        startThread();        addTask(task);        if(isShutdown() &amp;&amp; removeTask(task)) &#123;            reject();        &#125;    &#125;        if(!addTaskWakesUp&amp;&amp;wakesUpForTask(task)) &#123;        wakeup(inEventLoop);    &#125;&#125;</code></pre><p>说明:</p><p> 1)首先判断该 <code>EventLoop</code> 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。</p><p>2)如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。</p><p>3)如果 <code>addTaskWakesUp</code> 是 <code>false</code>，并且任务不是 <code>NonWakeupRunnable</code> 类型的，就尝试唤醒 <code>selector</code>。这个时候，阻塞在 <code>selecor</code>的线程就会立即返回</p><p>4)可以下断点来追踪</p><p>2.2我们 <code>debugaddTask</code> 和 <code>offerTask</code> 方法源码</p><pre><code class="java">protected void addTask(Runnable task) &#123;    if(task == null) &#123;        throw new NullPointerException(&quot;task&quot;);    &#125;        if(!offerTask(task)) &#123;        reject(task);    &#125;&#125;final boolean offerTask(Runnable task) &#123;    if(isShutdown()) &#123;        reject();    &#125;    return taskQueue.offer(task);&#125;</code></pre><p>3.<code>NioEventLoop</code> 的父类 <code>SingleThreadEventExecutor</code> 的 <code>startThread</code> 方法 3.1当执行 <code>execute</code> 方法的时候，如果当前线程不是 <code>EventLoop</code> 所属线程，则尝试启动线程，也就是 <code>startThread</code> 方法，dubug 代码如下：</p><pre><code class="java">private void startThread() &#123;    if(state == ST_NOT_STARTED) &#123;        if(STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;            try&#123;                doStartThread();            &#125; catch(Throwable cause) &#123;                STATE_UPDATER.set(this, ST_NOT_STARTED);                PlatformDependent.throwException(cause);            &#125;        &#125;    &#125;&#125;</code></pre><p>说明:该方法首先判断是否启动过了，保证 <code>EventLoop</code> 只有一个线程，如果没有启动过，则尝试使用 <code>Cas</code> 将 <code>state</code> 状态改为 <code>ST_STARTED</code>，也就是已启动。然后调用 <code>doStartThread</code> 方法。如果失败，则进行回滚</p><p>看下 <code>doStartThread</code> 方法</p><pre><code class="java">private void doStartThread() &#123;    executor.execute(new Runnable() &#123;        @Override        public void run() &#123;            boolean success = false;            updateLastExecutionTime();            try&#123;                SingleThreadEventExecutor.this.run();                success=true;            &#125; finally &#123;                for( ; ; ) &#123;                    intoldState = state;                    if(oldState &gt;= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet(SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) &#123;                        break;                    &#125;                &#125;                try &#123;                    for( ; ; ) &#123;                        if(confirmShutdown()) &#123;                            break;                        &#125;                    &#125;                &#125; finally &#123;                    try &#123;                        cleanup();                    &#125; finally &#123;                        STATE_UPDATER.set(SingleThreadEventExecutor.this,ST_TERMINATED);                        threadLock.release();                        terminationFuture.setSuccess(null);                    &#125;                &#125;            &#125;        &#125;    &#125;);&#125;</code></pre><p>说明：</p><p> 1)首先调用 <code>executor</code> 的 <code>execute</code> 方法，这个 <code>executor</code> 就是在创建 <code>EventLoopGroup</code> 的时候创建的 <code>ThreadPerTaskExecutor</code> 类。该 <code>execute</code> 方法会将 <code>Runnable</code> 包装成 <code>Netty</code> 的 <code>FastThreadLocalThread</code>。</p><p>2)任务中，首先判断线程中断状态，然后设置最后一次的执行时间。</p><p>3)执行当前 <code>NioEventLoop</code> 的 <code>run</code> 方法，注意：这个方法是个死循环，是整个 <code>EventLoop</code> 的核心</p><p>4)在 <code>finally</code> 块中，使用 <code>CAS</code> 不断修改 <code>state</code> 状态，改成 <code>ST_SHUTTING_DOWN</code>。也就是当线程 <code>Loop</code> 结束的时候。关闭线程。最后还要死循环确认是否关闭，否则不会 <code>break</code>。然后，执行 <code>cleanup</code> 操作，更新状态为</p><p>5)<code>ST_TERMINATED</code>，并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调 <code>terminationFuture</code> 方法。</p><p>6)其实最核心的就是 <code>EventLoop</code> 自身的 <code>run</code> 方法。再继续深入 <code>run</code> 方法</p><p>4.<code>EventLoop</code> 中的 <code>Loop</code> 是靠 <code>run</code> 实现的，我们分析下 <code>run</code> 方法(该方法在 <code>NioEventLoop</code>)</p><pre><code class="java">@Overrideprotected void run() &#123;    for( ; ; ) &#123;        try &#123;            switch(selectStrategy.calculateStrategy(selectNowSupplier,hasTasks())) &#123;                case SelectStrategy.CONTINUE:                    continue;                case SelectStrategy.SELECT:                    select(wakenUp.getAndSet(false));                    if(wakenUp.get()) &#123;                        selector.wakeup();                    &#125;                    default:            &#125;                        cancelledKeys = 0;            needsToSelectAgain = false;            final int ioRatio = this.ioRatio;            if(ioRatio == 100) &#123;                try &#123;                    processSelectedKeys();                &#125; finally &#123;                    //Ensure we always run tasks.                    runAllTasks();                &#125;            &#125; else &#123;                final long ioStartTime = System.nanoTime();                try &#123;                    processSelectedKeys();                &#125; finally &#123;                    //Ensure we always runtasks.                    final long ioTime = System.nanoTime() - ioStartTime;                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);                &#125;            &#125;        &#125; catch(Throwable t) &#123;            handleLoopException(t);        &#125;        //Always handle shutdown even if the loop processing threw an exception.        try &#123;            if(isShuttingDown()) &#123;                closeAll();                if(confirmShutdown()) &#123;                    return;                &#125;            &#125;        &#125; catch (Throwable t) &#123;            handleLoopException(t);        &#125;    &#125;&#125;</code></pre><p>说明: </p><p>1)从上面的步骤可以看出，整个 <code>run</code> 方法做了 <code>3</code> 件事情： <code>select</code> 获取感兴趣的事件。 <code>processSelectedKeys</code> 处理事件。 <code>runAllTasks</code> 执行队列中的任务。</p><p>2)上面的三个方法，我们就追一下 <code>select</code> 方法(体现非阻塞)核心 <code>select</code> 方法解析</p><pre><code class="java">private void select(boolean oldWakenUp) throws IOException &#123;    Selector selector = this.selector;    try &#123;        int selectCnt = 0;        long currentTimeNanos = System.nanoTime();        long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);        for( ; ; ) &#123;            long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L)/1000000L;            if(timeoutMillis &lt;= 0) &#123;                if(selectCnt == 0) &#123;                    selector.selectNow();                    selectCnt=1;                &#125;                break;            &#125;            //If a task was submitted when wakenUp value was true, the task didn&#39;t get a chance to call            //Selector#wakeup. So we need to check task queue again before executing select operation.            //If wedon&#39;t, the task might be pended until select operation was timedout.            //It might be pended until idle timeout if IdleStateHandler existed inpipeline.            if(hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;                selector.selectNow();                selectCnt = 1;                break;            &#125;                        int selectedKeys = selector.select(timeoutMillis);//否则阻塞给定时间，默认一秒            selectCnt++;            //如果 1 秒后返回，有返回值||select被用户唤醒||任务队列有任务||有定时任务即将被执行；则跳出循环            if(selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;                //-Selected something,                //-waken up by user,or                //-the task queue has apending task.                //-a scheduled task is ready for processing                break;            &#125;                        if(Thread.interrupted()) &#123;                //Thread was interrupted so reset selected keys and break so we not run into a busy loop.                //As this is most likely a bug in the handler of the user or it&#39;s client library we will                //also log it.                //                //See https://github.com/netty/netty/issues/2426                if(logger.isDebugEnabled()) &#123;                    logger.debug(&quot;Selector.select() returned prematurely because &quot; + &quot; Thread.currentThread().interrupt() was called. Use &quot; + &quot; NioEventLoop.shutdownGracefully() to shutdowntheNioEventLoop.&quot;);                &#125;                selectCnt = 1;                break;            &#125;            long time = System.nanoTime();            if(time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;                //timeoutMillis elapsed without any thing selected.                selectCnt =1;            &#125; else if(SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;                //The selector returned prematurely many times in a row.                //Rebuild the selector to work around the problem.                logger.warn(&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;, selectCnt, selector);                rebuildSelector();                selector = this.selector;                //Select again to populate selectedKeys.                selector.selectNow();                selectCnt = 1;                break;            &#125;                        currentTimeNanos = time;        &#125;                if(selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;            if(logger.isDebugEnabled()) &#123;                logger.debug(&quot;Selector.select()returned prematurely &#123;&#125; times in a row for Selector&#123;&#125;.&quot;, selectCnt - 1, selector);            &#125;        &#125;    &#125; catch (CancelledKeyException e) &#123;        if(logger.isDebugEnabled()) &#123;            logger.debug(CancelledKeyException.class.getSimpleName() + &quot;raisedbyaSelector &#123;&#125; - JDKbug?&quot;, selector, e);        &#125;        //Harmless exception - log anyway    &#125;&#125;</code></pre><p>说明：</p><p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selector</code>，防止 <code>selector</code> 阻塞时间过长</p><p>5.<code>EventLoop</code> 作为 <code>Netty</code> 的核心的运行机制小结</p><p>1)每次执行 <code>execute</code> 方法都是向队列中添加任务。当第一次添加时就启动线程，执行 <code>run</code> 方法，而 <code>run</code> 方法是整个 <code>EventLoop</code> 的核心，就像 <code>EventLoop</code> 的名字一样，<code>LoopLoop</code>，不停的 <code>Loop</code>，<code>Loop</code> 做什么呢？做 <code>3</code> 件事情。</p><p>调用 <code>selector</code> 的 <code>select</code> 方法，默认阻塞一秒钟，如果有定时任务，则在定时任务剩余时间的基础上在加上 <code>0.5</code> 秒进行阻塞。当执行 <code>execute</code> 方法的时候，也就是添加任务的时候，唤醒 <code>selecor</code>，防止 <code>selector</code> 阻塞时间过长。</p><p>当 <code>selector</code> 返回的时候，回调用 <code>processSelectedKeys</code> 方法对 <code>selectKey</code> 进行处理。</p><p>当 <code>processSelectedKeys</code> 方法执行结束后，则按照 <code>ioRatio</code> 的比例执行 <code>runAllTasks</code> 方法，默认是 <code>IO</code> 任务时间和非 <code>IO</code> 任务时间是相同的，你也可以根据你的应用特点进行调优。比如非 <code>IO</code> 任务比较多，那么你就将</p><p><code>ioRatio</code> 调小一点，这样非 <code>IO</code> 任务就能执行的长一点。防止队列积攒过多的任务。</p><h2 id="10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析"><a href="#10-8-handler-中加入线程池和-Context-中添加线程池的源码剖析" class="headerlink" title="10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析"></a>10.8 handler 中加入线程池和 Context 中添加线程池的源码剖析</h2><h3 id="10-8-1-源码剖析目的"><a href="#10-8-1-源码剖析目的" class="headerlink" title="10.8.1 源码剖析目的"></a>10.8.1 源码剖析目的</h3><ol><li>在 <code>Netty</code> 中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响 <code>Netty</code> 对 <code>Socket</code> 的处理速度。</li><li>而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有 <code>2</code> 种方式，而且这 <code>2</code> 种方式实现的区别也蛮大的。</li><li>处理耗时业务的第一种方式 – <code>handler</code> 中加入线程池</li><li>处理耗时业务的第二种方式 – <code>Context</code> 中添加线程池</li><li>我们就来分析下两种方式</li></ol><h3 id="10-8-2-源码剖析"><a href="#10-8-2-源码剖析" class="headerlink" title="10.8.2 源码剖析"></a>10.8.2 源码剖析</h3><p>说明 演示两种方式的实现，以及从源码来追踪两种方式执行流程</p><ol><li>处理耗时业务的第一种方式 – handler种加入线程池</li><li>1对前面的 <code>Netty</code> <code>demo</code>源码进行修改，在 <code>EchoServerHandler</code> 的 <code>channelRead</code> 方法进行异步</li></ol><pre><code class="java">@Sharablepublic class EchoServerHandler extends ChannelInboundHandlerAdapter &#123;    static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws UnsupportedEncodingException, InterruptedException &#123;        final Object msgCop = msg;        final ChannelHandlerContext cxtCop = ctx;        group.submit(new Callable&lt;Object&gt;() &#123;            @Override            public Object call() throws Exception &#123;                ByteBuf buf = (ByteBuf)msgCop;                byte[] req = new byte[buf.readableBytes()];                buf.readBytes(req);                String body = new String(req, &quot;UTF-8&quot;);                Thread.sleep(10 * 1000);                System.err.println(body + &quot; &quot; + Thread.currentThread().getName());                String reqString = &quot;Helloiamserver~~~&quot;;                ByteBuf resp = Unpooled.copiedBuffer(reqString.getBytes());                cxtCop.writeAndFlush(resp);                return null;            &#125;        &#125;);        System.out.println(&quot;goon..&quot;);    &#125;        @Override    public void channelReadComplete(ChannelHandlerContext ctx) &#123;        ctx.flush();    &#125;        @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) &#123;        // Close the connection when an exception is raised.        cause.printStackTrace();        ctx.close();    &#125;&#125;</code></pre><p>说明： 1)在 <code>channelRead</code> 方法，模拟了一个耗时 <code>10</code> 秒的操作，这里，我们将这个任务提交到了一个自定义的业务线程池中，这样，就不会阻塞 <code>Netty</code> 的 <code>IO</code> 线程。</p><p>11.2这样处理之后，整个程序的逻辑如图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter10/chapter10_19.png" alt="img"></p><p>说明：</p><p>1)解释一下上图，当 <code>IO</code> 线程轮询到一个 <code>socket</code> 事件，然后，<code>IO</code> 线程开始处理，当走到耗时 <code>handler</code> 的时候，将耗时任务交给业务线程池。</p><p>2)当耗时任务执行完毕再执行 <code>pipeline write</code> 方法的时候，(代码中使用的是 <code>context</code> 的 <code>write</code> 方法，上图画的是执行 <code>pipeline</code> 方法，是一个意思)会将任务这个任务交给 <code>IO</code> 线程</p><p>11.3 <code>write</code> 方法的源码(在 <code>AbstractChannelHandlerContext</code> 类)</p><pre><code class="java">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;    AbstractChannelHandlerContext next = findContextOutbound();    final Object m = pipeline.touch(msg, next);    EventExecutor executor = next.executor();    if(executor.inEventLoop()) &#123;        if(flush) &#123;            next.invokeWriteAndFlush(m, promise);        &#125; else &#123;            next.invokeWrite(m, promise);        &#125;    &#125; else &#123;        AbstractWriteTask task;        if(flush) &#123;            task = WriteAndFlushTask.newInstance(next, m, promise);        &#125; else &#123;            task = WriteTask.newInstance(next, m, promise);        &#125;        safeExecute(executor, task, promise, m);    &#125;&#125;</code></pre><p>说明:</p><p>1)当判定下个 <code>outbound</code> 的 <code>executor</code> 线程不是当前线程的时候，会将当前的工作封装成 <code>task</code>，然后放入 <code>mpsc</code> 队列中，等待 <code>IO</code> 任务执行完毕后执行队列中的任务。</p><p>2)这里可以 Debug 来验证(提醒：Debug 时，服务器端 Debug, 客户端 <code>Run</code> 的方式)，当我们使用了 <code>group.submit(new Callable&lt;Object&gt; ()&#123;&#125;</code> 在 <code>handler</code> 中加入线程池，就会进入到 <code>safeExecute(executor, task, promise, m);</code> 如果去掉这段代码，而使用普通方式来执行耗时的业务，那么就不会进入到 <code>safeExecute(executor, task, promise, m);</code>（说明：普通方式执行耗时代码，看我准备好的案例即可）</p><p>12.处理耗时业务的第二种方式 -<code>Context</code> 中添加线程池 1.1在添加 <code>pipeline</code> 中的 <code>handler</code> 时候，添加一个线程池</p><p>//属性</p><pre><code class="java">static final EventExecutorGroup group = new DefaultEventExecutorGroup(16);ServerBootstrap b = new ServerBootstrap();                b.group(bossGroup, workerGroup)                 .channel(NioServerSocketChannel.class)                 .option(ChannelOption.SO_BACKLOG, 100)                 .handler(newLoggingHandler(LogLevel.INFO))                 .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                     @Override                     public void initChannel(SocketChannel ch) throws Exception &#123;                         ChannelPipeline p = ch.pipeline();                         if(sslCtx != null) &#123;                             p.addLast(sslCtx.newHandler(ch.alloc()));                         &#125;                         //p.addLast(new LoggingHandler(LogLevel.INFO));                         //p.addLast(new EchoServerHandler());                         p.addLast(group, new EchoServerHandler());                    &#125;                &#125;);</code></pre><p>说明：</p><p>1)<code>handler</code> 中的代码就使用普通的方式来处理耗时业务。</p><p>2)当我们在调用 <code>addLast</code> 方法添加线程池后，<code>handler</code> 将优先使用这个线程池，如果不添加，将使用 <code>IO</code> 线程</p><p>3)当走到 <code>AbstractChannelHandlerContext</code> 的 <code>invokeChannelRead</code> 方法的时候，<code>executor.inEventLoop()</code> 是不会通过的，因为当前线程是 <code>IO</code> 线程 <code>Context</code>（也就是 <code>Handler</code>）的 <code>executor</code> 是业务线程，所以会异步执行，debug 下源码</p><pre><code class="java">static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123;    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);    EventExecutor executor = next.executor();    if(executor.inEventLoop()) &#123;        next.invokeChannelRead(m);    &#125; else &#123;        executor.execute(new Runnable() &#123;//执行run            @Override            public void run() &#123;                next.invokeChannelRead(m);            &#125;        &#125;);    &#125;&#125;</code></pre><p>4)验证时，我们如果去掉 <code>p.addLast(group,newEchoServerHandler());</code> 改成 <code>p.addLastnewEchoServerHandler());</code> 你会发现代码不会进行异步执行。</p><p>5)后面的整个流程就变成和第一个方式一样了</p><p>13.两种方式的比较</p><p>1)第一种方式在 <code>handler</code> 中添加异步，可能更加的自由，比如如果需要访问数据库，那我就异步，如果不需要，就不异步，异步会拖长接口响应时间。因为需要将任务放进 <code>mpscTask</code> 中。如果 <code>IO</code> 时间很短，<code>task</code> 很多，可能一个循环下来，都没时间执行整个 <code>task</code>，导致响应时间达不到指标。</p><p>2)第二种方式是 <code>Netty</code> 标准方式(即加入到队列)，但是，这么做会将整个 <code>handler</code> 都交给业务线程池。不论耗时不耗时，都加入到队列里，不够灵活。</p><p>3)各有优劣，从灵活性考虑，第一种较好。</p><h1 id="第-11-章-用-Netty-自己实现-Dubbo-RPC"><a href="#第-11-章-用-Netty-自己实现-Dubbo-RPC" class="headerlink" title="第 11 章 用 Netty 自己实现 Dubbo RPC"></a>第 11 章 用 Netty 自己实现 Dubbo RPC</h1><h2 id="11-1-RPC-基本介绍"><a href="#11-1-RPC-基本介绍" class="headerlink" title="11.1 RPC 基本介绍"></a>11.1 RPC 基本介绍</h2><ol><li><code>RPC（Remote Procedure Call）</code>—远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程</li><li>两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图)</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_01.png" alt="img"></p><ol><li>常见的 <code>RPC</code> 框架有：比较知名的如阿里的 <code>Dubbo</code>、<code>Google</code> 的 <code>gRPC</code>、<code>Go</code> 语言的 <code>rpcx</code>、<code>Apache</code> 的 <code>thrift</code>，<code>Spring</code> 旗下的 <code>SpringCloud</code>。</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_02.png" alt="img"></p><h2 id="11-2-RPC-调用流程图"><a href="#11-2-RPC-调用流程图" class="headerlink" title="11.2 RPC 调用流程图"></a>11.2 RPC 调用流程图</h2><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_03.png" alt="img"></p><h2 id="11-3-PRC-调用流程说明"><a href="#11-3-PRC-调用流程说明" class="headerlink" title="11.3 PRC 调用流程说明"></a>11.3 PRC 调用流程说明</h2><ol><li>服务消费方（<code>client</code>）以本地调用方式调用服务</li><li><code>client stub</code> 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体</li><li><code>client stub</code> 将消息进行编码并发送到服务端</li><li><code>server stub</code> 收到消息后进行解码</li><li><code>server stub</code> 根据解码结果调用本地的服务</li><li>本地服务执行并将结果返回给 <code>server stub</code></li><li><code>server stub</code> 将返回导入结果进行编码并发送至消费方</li><li><code>client stub</code> 接收到消息并进行解码</li><li>服务消费方（<code>client</code>）得到结果</li></ol><p>小结：<code>RPC</code> 的目标就是将 <code>2 - 8</code> 这些步骤都封装起来，用户无需关心这些细节，可以像调用本地方法一样即可完成远程服务调用</p><h2 id="11-4-自己实现-Dubbo-RPC（基于-Netty）"><a href="#11-4-自己实现-Dubbo-RPC（基于-Netty）" class="headerlink" title="11.4 自己实现 Dubbo RPC（基于 Netty）"></a>11.4 自己实现 Dubbo RPC（基于 Netty）</h2><h3 id="11-4-1-需求说明"><a href="#11-4-1-需求说明" class="headerlink" title="11.4.1 需求说明"></a>11.4.1 需求说明</h3><ol><li><code>Dubbo</code> 底层使用了 <code>Netty</code> 作为网络通讯框架，要求用 <code>Netty</code> 实现一个简单的 <code>RPC</code> 框架</li><li>模仿 <code>Dubbo</code>，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 <code>Netty 4.1.20</code></li></ol><h3 id="11-4-2-设计说明"><a href="#11-4-2-设计说明" class="headerlink" title="11.4.2 设计说明"></a>11.4.2 设计说明</h3><ol><li>创建一个接口，定义抽象方法。用于消费者和提供者之间的约定。</li><li>创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据。</li><li>创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 <code>Netty</code> 请求提供者返回数据</li><li>开发的分析图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter11/chapter11_04.png" alt="img"></p><h3 id="11-4-3-代码实现"><a href="#11-4-3-代码实现" class="headerlink" title="11.4.3 代码实现"></a>11.4.3 代码实现</h3><pre><code class="java">package com.demo.netty.dubborpc.publicinterface;//这个是接口，是服务提供方和 服务消费方都需要public interface HelloService &#123;    String hello(String mes);&#125;package com.demo.netty.dubborpc.provider;import com.demo.netty.dubborpc.publicinterface.HelloService;public class HelloServiceImpl implements HelloService &#123;    private static int count = 0;    //当有消费方调用该方法时， 就返回一个结果    @Override    public String hello(String mes) &#123;        System.out.println(&quot;收到客户端消息=&quot; + mes);        //根据mes 返回不同的结果        if (mes != null) &#123;            return &quot;你好客户端, 我已经收到你的消息 [&quot; + mes + &quot;] 第&quot; + (++count) + &quot; 次&quot;;        &#125; else &#123;            return &quot;你好客户端, 我已经收到你的消息 &quot;;        &#125;    &#125;&#125;package com.demo.netty.dubborpc.provider;import com.demo.netty.dubborpc.netty.NettyServer;//ServerBootstrap 会启动一个服务提供者，就是 NettyServerpublic class ServerBootstrap &#123;        public static void main(String[] args) &#123;        //代码代填..        NettyServer.startServer(&quot;127.0.0.1&quot;, 7000);    &#125;&#125;package com.demo.netty.dubborpc.netty;import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelPipeline;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;public class NettyServer &#123;    public static void startServer(String hostName, int port) &#123;        startServer0(hostName, port);    &#125;    //编写一个方法，完成对NettyServer的初始化和启动    private static void startServer0(String hostname, int port) &#123;        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup();        try &#123;            ServerBootstrap serverBootstrap = new ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup)                    .channel(NioServerSocketChannel.class)                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;                                      @Override                                      protected void initChannel(SocketChannel ch) throws Exception &#123;                                          ChannelPipeline pipeline = ch.pipeline();                                          pipeline.addLast(new StringDecoder());                                          pipeline.addLast(new StringEncoder());                                          pipeline.addLast(new NettyServerHandler()); //业务处理器                                      &#125;                                  &#125;                    );            ChannelFuture channelFuture = serverBootstrap.bind(hostname, port).sync();            System.out.println(&quot;服务提供方开始提供服务~~&quot;);            channelFuture.channel().closeFuture().sync();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        &#125;    &#125;&#125;package com.demo.netty.dubborpc.netty;import com.demo.netty.dubborpc.customer.ClientBootstrap;import com.demo.netty.dubborpc.provider.HelloServiceImpl;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;//服务器这边handler比较简单public class NettyServerHandler extends ChannelInboundHandlerAdapter &#123;    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;        //获取客户端发送的消息，并调用服务        System.out.println(&quot;msg=&quot; + msg);        //客户端在调用服务器的api 时，我们需要定义一个协议        //比如我们要求 每次发消息是都必须以某个字符串开头 &quot;HelloService#hello#你好&quot;        if (msg.toString().startsWith(ClientBootstrap.providerName)) &#123;            String result = new HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(&quot;#&quot;) + 1));            ctx.writeAndFlush(result);        &#125;    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        ctx.close();    &#125;&#125;package com.demo.netty.dubborpc.netty;import io.netty.channel.ChannelHandlerContext;import io.netty.channel.ChannelInboundHandlerAdapter;import java.util.concurrent.Callable;public class NettyClientHandler extends ChannelInboundHandlerAdapter implements Callable &#123;    private ChannelHandlerContext context;//上下文    private String result; //返回的结果    private String para; //客户端调用方法时，传入的参数        //与服务器的连接创建后，就会被调用, 这个方法是第一个被调用(1)    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;        System.out.println(&quot; channelActive 被调用  &quot;);        context = ctx; //因为我们在其它方法会使用到 ctx    &#125;    //收到服务器的数据后，调用方法 (4)    //    @Override    public synchronized void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;        System.out.println(&quot; channelRead 被调用  &quot;);        result = msg.toString();        notify(); //唤醒等待的线程    &#125;    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;        ctx.close();    &#125;    //被代理对象调用, 发送数据给服务器，-&gt; wait -&gt; 等待被唤醒(channelRead) -&gt; 返回结果 (3)-》5    @Override    public synchronized Object call() throws Exception &#123;        System.out.println(&quot; call1 被调用  &quot;);        context.writeAndFlush(para);        //进行wait        wait(); //等待channelRead 方法获取到服务器的结果后，唤醒        System.out.println(&quot; call2 被调用  &quot;);        return result; //服务方返回的结果    &#125;    //(2)    void setPara(String para) &#123;        System.out.println(&quot; setPara  &quot;);        this.para = para;    &#125;&#125;package com.demo.netty.dubborpc.netty;import io.netty.bootstrap.Bootstrap;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.ChannelPipeline;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import java.lang.reflect.Proxy;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class NettyClient &#123;    //创建线程池    private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());    private static NettyClientHandler client;    private int count = 0;    //编写方法使用代理模式，获取一个代理对象    public Object getBean(final Class&lt;?&gt; serivceClass, final String providerName) &#123;        return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),                new Class&lt;?&gt;[]&#123;serivceClass&#125;, (proxy, method, args) -&gt; &#123;                    System.out.println(&quot;(proxy, method, args) 进入....&quot; + (++count) + &quot; 次&quot;);                    //&#123;&#125;  部分的代码，客户端每调用一次 hello, 就会进入到该代码                    if (client == null) &#123;                        initClient();                    &#125;                    //设置要发给服务器端的信息                    //providerName 协议头 args[0] 就是客户端调用api hello(???), 参数                    client.setPara(providerName + args[0]);                    //                    return executor.submit(client).get();                &#125;);    &#125;    //初始化客户端    private static void initClient() &#123;        client = new NettyClientHandler();        //创建EventLoopGroup        NioEventLoopGroup group = new NioEventLoopGroup();        Bootstrap bootstrap = new Bootstrap();        bootstrap.group(group)                .channel(NioSocketChannel.class)                .option(ChannelOption.TCP_NODELAY, true)                .handler(                        new ChannelInitializer&lt;SocketChannel&gt;() &#123;                            @Override                            protected void initChannel(SocketChannel ch) throws Exception &#123;                                ChannelPipeline pipeline = ch.pipeline();                                pipeline.addLast(new StringDecoder());                                pipeline.addLast(new StringEncoder());                                pipeline.addLast(client);                            &#125;                        &#125;                );        try &#123;            bootstrap.connect(&quot;127.0.0.1&quot;, 7000).sync();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;package com.demo.netty.dubborpc.customer;import com.demo.netty.dubborpc.netty.NettyClient;import com.demo.netty.dubborpc.publicinterface.HelloService;public class ClientBootstrap &#123;        //这里定义协议头    public static final String providerName = &quot;HelloService#hello#&quot;;    public static void main(String[] args) throws Exception &#123;        //创建一个消费者        NettyClient customer = new NettyClient();        //创建代理对象        HelloService service = (HelloService) customer.getBean(HelloService.class, providerName);        for (; ; ) &#123;            Thread.sleep(2 * 1000);            //通过代理对象调用服务提供者的方法(服务)            String res = service.hello(&quot;你好 dubbo~&quot;);            System.out.println(&quot;调用的结果 res= &quot; + res);        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> IO网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO网络编程 </tag>
            
            <tag> Netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NIO</title>
      <link href="/2021/10/02/nio/"/>
      <url>/2021/10/02/nio/</url>
      
        <content type="html"><![CDATA[<h1 id="NIO-编程"><a href="#NIO-编程" class="headerlink" title="NIO 编程"></a>NIO 编程</h1><h2 id="1-NIO-基本介绍"><a href="#1-NIO-基本介绍" class="headerlink" title="1 NIO 基本介绍"></a>1 NIO 基本介绍</h2><ol><li><code>Java NIO</code> 全称 <strong><code>Java non-blocking IO</code></strong> ，是指 <code>JDK</code> 提供的新 <code>API</code>。从 <code>JDK1.4</code> 开始，<code>Java</code> 提供了一系列改进的输入/输出的新特性，被统称为 <code>NIO</code>（即 <code>NewIO</code>），是同步非阻塞的。</li><li><code>NIO</code> 相关类都被放在 <strong><code>java.nio</code></strong> 包及子包下，并且对原 <code>java.io</code> 包中的很多类进行改写。【基本案例】</li><li><code>NIO</code> 有三大核心部分: <strong><code>Channel</code>（通道）、<code>Buffer</code>（缓冲区）、<code>Selector</code>（选择器）</strong> 。</li><li><code>NIO</code> 是<strong>面向缓冲区，或者面向块编程</strong>的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。</li><li><code>Java NIO</code> 的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。【后面有案例说明】</li><li>通俗理解：<code>NIO</code> 是可以做到用一个线程来处理多个操作的。假设有 <code>10000</code> 个请求过来,根据实际情况，可以分配 <code>50</code> 或者 <code>100</code> 个线程来处理。不像之前的阻塞 <code>IO</code> 那样，非得分配 <code>10000</code> 个。</li><li><code>HTTP 2.0</code> 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 <code>HTTP 1.1</code> 大了好几个数量级。</li><li>案例说明 <code>NIO</code> 的 <code>Buffer</code></li></ol><pre><code class="java">import java.nio.IntBuffer;public class BasicBuffer &#123;    public static void main(String[] args) &#123;        //举例说明 Buffer 的使用(简单说明)        //创建一个 Buffer，大小为 5，即可以存放 5 个 int        IntBuffer intBuffer = IntBuffer.allocate(5);        //向buffer存放数据        //intBuffer.put(10);        //intBuffer.put(11);        //intBuffer.put(12);        //intBuffer.put(13);        //intBuffer.put(14);        for (int i = 0; i &lt; intBuffer.capacity(); i++) &#123;            intBuffer.put(i * 2);        &#125;        //如何从 buffer 读取数据        //将 buffer 转换，读写切换(!!!)        intBuffer.flip();        while (intBuffer.hasRemaining()) &#123;            System.out.println(intBuffer.get());        &#125;    &#125;&#125;</code></pre><h2 id="2-NIO-和-BIO-的比较"><a href="#2-NIO-和-BIO-的比较" class="headerlink" title="2 NIO 和 BIO 的比较"></a>2 NIO 和 BIO 的比较</h2><ol><li><code>BIO</code> 以流的方式处理数据，而 <code>NIO</code> 以块的方式处理数据，块 <code>I/O</code> 的效率比流 <code>I/O</code> 高很多。</li><li><code>BIO</code> 是阻塞的，<code>NIO</code> 则是非阻塞的。</li><li><code>BIO</code> 基于字节流和字符流进行操作，而 <code>NIO</code> 基于 <code>Channel</code>（通道）和 <code>Buffer</code>（缓冲区）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。<code>Selector</code>（选择器）用于监听多个通道的事件（比如：连接请求，数据到达等），因此使用单个线程就可以监听多个客户端通道。</li></ol><h2 id="3-NIO-三大核心原理示意图"><a href="#3-NIO-三大核心原理示意图" class="headerlink" title="3 NIO 三大核心原理示意图"></a>3 NIO 三大核心原理示意图</h2><p>一张图描述 <code>NIO</code> 的 <code>Selector</code>、<code>Channel</code> 和 <code>Buffer</code> 的关系。</p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_01.png" alt="img " style="zoom:50%;" /><ol><li>每个 <code>Channel</code> 都会对应一个 <code>Buffer</code>。</li><li><code>Selector</code> 对应一个线程，一个线程对应多个 <code>Channel</code>（连接）。</li><li>该图反应了有三个 <code>Channel</code> 注册到该 <code>Selector</code> //程序</li><li>程序切换到哪个 <code>Channel</code> 是由事件决定的，<code>Event</code> 就是一个重要的概念。</li><li><code>Selector</code> 会根据不同的事件，在各个通道上切换。</li><li><code>Buffer</code> 就是一个内存块，底层是有一个数组。</li><li>数据的读取写入是通过 <code>Buffer</code>，这个和 <code>BIO</code>，<code>BIO</code> 中要么是输入流，或者是输出流，不能双向，但是 <code>NIO</code> 的 <code>Buffer</code> 是可以读也可以写，需要 <code>flip</code> 方法切换 <code>Channel</code> 是双向的，可以返回底层操作系统的情况，比如 <code>Linux</code>，底层的操作系统通道就是双向的。</li></ol><h2 id="4-缓冲区（Buffer）"><a href="#4-缓冲区（Buffer）" class="headerlink" title="4 缓冲区（Buffer）"></a>4 缓冲区（Buffer）</h2><h3 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h3><p>缓冲区（<code>Buffer</code>）：缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，可以理解成是一个<strong>容器对象（含数组）</strong>，该对象提供了一组方法，可以更轻松地使用内存块，，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。<code>Channel</code> 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 <code>Buffer</code>，如图:【后面举例说明】</p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_02.png" alt="img " style="zoom:50%;" /><h3 id="4-2-Buffer-类及其子类"><a href="#4-2-Buffer-类及其子类" class="headerlink" title="4.2 Buffer 类及其子类"></a>4.2 Buffer 类及其子类</h3><ol><li><p>在 <code>NIO</code> 中，<code>Buffer</code> 是一个顶层父类，它是一个抽象类，类的层级关系：</p><blockquote><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li><li>ShortBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>FloatBuffer</li><li>DoubleBuffer</li><li>CharBuffer</li></ul></blockquote></li><li><p><code>Buffer</code> 类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息：</p></li></ol><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_05.png" alt="img " style="zoom:80%;" /><ol><li><code>Buffer</code> 类相关方法一览</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_06.png" alt="img"></p><h3 id="4-3-ByteBuffer"><a href="#4-3-ByteBuffer" class="headerlink" title="4.3 ByteBuffer"></a>4.3 ByteBuffer</h3><p>从前面可以看出对于 <code>Java</code> 中的基本数据类型（<code>boolean</code> 除外），都有一个 <code>Buffer</code> 类型与之相对应，最常用的自然是 <code>ByteBuffer</code> 类（二进制数据），该类的主要方法如下：</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_07.png" alt="img"></p><h2 id="5-通道（Channel）"><a href="#5-通道（Channel）" class="headerlink" title="5 通道（Channel）"></a>5 通道（Channel）</h2><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p><p>常见的 Channel 有</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><h2 id="6-基本介绍"><a href="#6-基本介绍" class="headerlink" title="6 基本介绍"></a>6 基本介绍</h2><ol><li>NIO 的通道类似于流，但有些区别如下：<ul><li>通道可以同时进行读写，而流只能读或者只能写</li><li>通道可以实现异步读写数据</li><li>通道可以从缓冲读数据，也可以写数据到缓冲:</li></ul></li><li><code>BIO</code> 中的 <code>Stream</code> 是单向的，例如 <code>FileInputStream</code> 对象只能进行读取数据的操作，而 <code>NIO</code> 中的通道（<code>Channel</code>）是双向的，可以读操作，也可以写操作。</li><li><code>Channel</code> 在 <code>NIO</code> 中是一个接口 <code>public interface Channel extends Closeable&#123;&#125;</code></li><li>常用的 <code>Channel</code> 类有: <strong><code>FileChannel</code>、<code>DatagramChannel</code>、<code>ServerSocketChannel</code> 和 <code>SocketChannel</code></strong> 。【<code>ServerSocketChanne</code> 类似 <code>ServerSocket</code>、<code>SocketChannel</code> 类似 <code>Socket</code>】</li><li><code>FileChannel</code> 用于文件的数据读写，<code>DatagramChannel</code> 用于 <code>UDP</code> 的数据读写，<code>ServerSocketChannel</code> 和 <code>SocketChannel</code> 用于 <code>TCP</code> 的数据读写。</li><li>图示</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_08.png" alt="img"></p><h3 id="6-1-FileChannel-类"><a href="#6-1-FileChannel-类" class="headerlink" title="6.1 FileChannel 类"></a>6.1 FileChannel 类</h3><p><code>FileChannel</code> 主要用来对本地文件进行 <code>IO</code> 操作，常见的方法有</p><ul><li><code>public int read(ByteBuffer dst)</code>，从通道读取数据并放到缓冲区中</li><li><code>public int write(ByteBuffer src)</code>，把缓冲区的数据写到通道中</li><li><code>public long transferFrom(ReadableByteChannel src, long position, long count)</code>，从目标通道中复制数据到当前通道</li><li><code>public long transferTo(long position, long count, WritableByteChannel target)</code>，把数据从当前通道复制给目标通道</li></ul><h3 id="6-2-应用实例1-本地文件写数据"><a href="#6-2-应用实例1-本地文件写数据" class="headerlink" title="6.2 应用实例1 - 本地文件写数据"></a>6.2 应用实例1 - 本地文件写数据</h3><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 “hello,尚硅谷” 写入到 <code>file01.txt</code> 中</li><li>文件不存在就创建</li><li>代码演示</li></ol><pre><code class="java">import java.io.FileOutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel01 &#123;    public static void main(String[] args) throws Exception &#123;        String str = &quot;hello&quot;;        //创建一个输出流 -&gt; channel        FileOutputStream fileOutputStream = new FileOutputStream(&quot;d:\\file01.txt&quot;);        //通过 fileOutputStream 获取对应的 FileChannel        //这个 fileChannel 真实类型是 FileChannelImpl        FileChannel fileChannel = fileOutputStream.getChannel();        //创建一个缓冲区 ByteBuffer        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);        //将 str 放入 byteBuffer        byteBuffer.put(str.getBytes());        //对 byteBuffer 进行 flip        byteBuffer.flip();        //将 byteBuffer 数据写入到 fileChannel        fileChannel.write(byteBuffer);        fileOutputStream.close();    &#125;&#125;</code></pre><h3 id="6-3-应用实例2-本地文件读数据"><a href="#6-3-应用实例2-本地文件读数据" class="headerlink" title="6.3 应用实例2 - 本地文件读数据"></a>6.3 应用实例2 - 本地文件读数据</h3><p>实例要求：</p><ol><li>使用前面学习后的 <code>ByteBuffer</code>（缓冲）和 <code>FileChannel</code>（通道），将 <code>file01.txt</code> 中的数据读入到程序，并显示在控制台屏幕</li><li>假定文件已经存在</li><li>代码演示</li></ol><pre><code class="java">import java.io.File;import java.io.FileInputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel02 &#123;    public static void main(String[] args) throws Exception &#123;        //创建文件的输入流        File file = new File(&quot;d:\\file01.txt&quot;);        FileInputStream fileInputStream = new FileInputStream(file);                //通过 fileInputStream 获取对应的 FileChannel -&gt; 实际类型 FileChannelImpl        FileChannel fileChannel = fileInputStream.getChannel();                //创建缓冲区        ByteBuffer byteBuffer = ByteBuffer.allocate((int)file.length());                //将通道的数据读入到 Buffer        fileChannel.read(byteBuffer);                //将 byteBuffer 的字节数据转成 String        System.out.println(new String(byteBuffer.array()));        fileInputStream.close();    &#125;&#125;</code></pre><h3 id="6-4-应用实例3-使用一个-Buffer-完成文件读取、写入"><a href="#6-4-应用实例3-使用一个-Buffer-完成文件读取、写入" class="headerlink" title="6.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入"></a>6.4 应用实例3 - 使用一个 Buffer 完成文件读取、写入</h3><p>实例要求：</p><ol><li>使用 <code>FileChannel</code>（通道）和方法 <code>read、write</code>，完成文件的拷贝</li><li>拷贝一个文本文件 <code>1.txt</code>，放在项目下即可</li><li>代码演示</li></ol><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_09.png" alt="img " style="zoom:50%;" /><pre><code class="java">import java.io.FileInputStream;import java.io.FileOutputStream;import java.nio.ByteBuffer;import java.nio.channels.FileChannel;public class NIOFileChannel03 &#123;    public static void main(String[] args) throws Exception &#123;        FileInputStream fileInputStream = new FileInputStream(&quot;1.txt&quot;);        FileChannel fileChannel01 = fileInputStream.getChannel();        FileOutputStream fileOutputStream = new FileOutputStream(&quot;2.txt&quot;);        FileChannel fileChannel02 = fileOutputStream.getChannel();        ByteBuffer byteBuffer = ByteBuffer.allocate(512);                while (true) &#123; //循环读取            //这里有一个重要的操作，一定不要忘了            /*            public final Buffer clear() &#123;                position = 0;                limit = capacity;                mark = -1;                return this;            &#125;            */            byteBuffer.clear(); //清空 buffer            int read = fileChannel01.read(byteBuffer);            System.out.println(&quot;read = &quot; + read);            if (read == -1) &#123; //表示读完                break;            &#125;            //将 buffer 中的数据写入到 fileChannel02--2.txt            byteBuffer.flip();            fileChannel02.write(byteBuffer);        &#125;        //关闭相关的流        fileInputStream.close();        fileOutputStream.close();    &#125;&#125;</code></pre><h3 id="6-5-应用实例4-拷贝文件-transferFrom-方法"><a href="#6-5-应用实例4-拷贝文件-transferFrom-方法" class="headerlink" title="6.5 应用实例4 - 拷贝文件 transferFrom 方法"></a>6.5 应用实例4 - 拷贝文件 transferFrom 方法</h3><ol><li>实例要求：</li><li>使用 <code>FileChannel</code>（通道）和方法 <code>transferFrom</code>，完成文件的拷贝</li><li>拷贝一张图片</li><li>代码演示</li></ol><pre><code class="java">import java.io.FileInputStream;import java.io.FileOutputStream;import java.nio.channels.FileChannel;public class NIOFileChannel04 &#123;    public static void main(String[] args) throws Exception &#123;        //创建相关流        FileInputStream fileInputStream = new FileInputStream(&quot;d:\\a.jpg&quot;);        FileOutputStream fileOutputStream = new FileOutputStream(&quot;d:\\a2.jpg&quot;);                //获取各个流对应的 FileChannel        FileChannel sourceCh = fileInputStream.getChannel();        FileChannel destCh = fileOutputStream.getChannel();        //使用 transferForm 完成拷贝        destCh.transferFrom(sourceCh, 0, sourceCh.size());        //关闭相关通道和流        sourceCh.close();        destCh.close();        fileInputStream.close();        fileOutputStream.close();    &#125;&#125;</code></pre><h3 id="6-6-关于-Buffer-和-Channel-的注意事项和细节"><a href="#6-6-关于-Buffer-和-Channel-的注意事项和细节" class="headerlink" title="6.6 关于 Buffer 和 Channel 的注意事项和细节"></a>6.6 关于 Buffer 和 Channel 的注意事项和细节</h3><ol><li><code>ByteBuffer</code> 支持类型化的 <code>put</code> 和 <code>get</code>，<code>put</code> 放入的是什么数据类型，<code>get</code> 就应该使用相应的数据类型来取出，否则可能有 <code>BufferUnderflowException</code> 异常。【举例说明】</li></ol><pre><code class="java">import java.nio.ByteBuffer;public class NIOByteBufferPutGet &#123;    public static void main(String[] args) &#123;                //创建一个 Buffer        ByteBuffer buffer = ByteBuffer.allocate(64);        //类型化方式放入数据        buffer.putInt(100);        buffer.putLong(9);        buffer.putChar(&#39;尚&#39;);        buffer.putShort((short) 4);        //取出        buffer.flip();                System.out.println();                System.out.println(buffer.getInt());        System.out.println(buffer.getLong());        System.out.println(buffer.getChar());        System.out.println(buffer.getShort());    &#125;&#125;</code></pre><ol><li>可以将一个普通 <code>Buffer</code> 转成只读 <code>Buffer</code>【举例说明】</li></ol><pre><code class="java">import java.nio.ByteBuffer;public class ReadOnlyBuffer &#123;    public static void main(String[] args) &#123;        //创建一个 buffer        ByteBuffer buffer = ByteBuffer.allocate(64);        for (int i = 0; i &lt; 64; i++) &#123;            buffer.put((byte) i);        &#125;        //读取        buffer.flip();        //得到一个只读的 Buffer        ByteBuffer readOnlyBuffer = buffer.asReadOnlyBuffer();        System.out.println(readOnlyBuffer.getClass());        //读取        while (readOnlyBuffer.hasRemaining()) &#123;            System.out.println(readOnlyBuffer.get());        &#125;        readOnlyBuffer.put((byte) 100); //ReadOnlyBufferException    &#125;&#125;</code></pre><ol><li><code>NIO</code> 还提供了 <code>MappedByteBuffer</code>，可以让文件直接在内存（堆外的内存）中进行修改，而如何同步到文件由 <code>NIO</code> 来完成。【举例说明】</li></ol><pre><code class="java">import java.io.RandomAccessFile;import java.nio.MappedByteBuffer;import java.nio.channels.FileChannel;/** * 说明 1.MappedByteBuffer 可让文件直接在内存（堆外内存）修改,操作系统不需要拷贝一次 */public class MappedByteBufferTest &#123;    public static void main(String[] args) throws Exception &#123;        RandomAccessFile randomAccessFile = new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);        //获取对应的通道        FileChannel channel = randomAccessFile.getChannel();        /**         * 参数 1:FileChannel.MapMode.READ_WRITE 使用的读写模式         * 参数 2：0：可以直接修改的起始位置         * 参数 3:5: 是映射到内存的大小（不是索引位置），即将 1.txt 的多少个字节映射到内存         * 可以直接修改的范围就是 0-5         * 实际类型 DirectByteBuffer         */        MappedByteBuffer mappedByteBuffer = channel.map(FileChannel.MapMode.READ_WRITE, 0, 5);        mappedByteBuffer.put(0, (byte) &#39;H&#39;);        mappedByteBuffer.put(3, (byte) &#39;9&#39;);        mappedByteBuffer.put(5, (byte) &#39;Y&#39;);//IndexOutOfBoundsException        randomAccessFile.close();        System.out.println(&quot;修改成功~~&quot;);    &#125;&#125;</code></pre><ol><li>前面我们讲的读写操作，都是通过一个 <code>Buffer</code> 完成的，<code>NIO</code> 还支持通过多个 <code>Buffer</code>（即 <code>Buffer</code>数组）完成读写操作，即 <code>Scattering</code> 和 <code>Gathering</code>【举例说明】</li></ol><pre><code class="java">import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Arrays;/** * Scattering：将数据写入到 buffer 时，可以采用 buffer 数组，依次写入 [分散] * Gathering：从 buffer 读取数据时，可以采用 buffer 数组，依次读 */public class ScatteringAndGatheringTest &#123;    public static void main(String[] args) throws Exception &#123;                //使用 ServerSocketChannel 和 SocketChannel 网络        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        InetSocketAddress inetSocketAddress = new InetSocketAddress(7000);        //绑定端口到 socket，并启动        serverSocketChannel.socket().bind(inetSocketAddress);        //创建 buffer 数组        ByteBuffer[] byteBuffers = new ByteBuffer[2];        byteBuffers[0] = ByteBuffer.allocate(5);        byteBuffers[1] = ByteBuffer.allocate(3);        //等客户端连接 (telnet)        SocketChannel socketChannel = serverSocketChannel.accept();        int messageLength = 8; //假定从客户端接收 8 个字节        //循环的读取        while (true) &#123;            int byteRead = 0;            while (byteRead &lt; messageLength) &#123;                long l = socketChannel.read(byteBuffers);                byteRead += l; //累计读取的字节数                System.out.println(&quot;byteRead = &quot; + byteRead);                //使用流打印,看看当前的这个 buffer 的 position 和 limit                Arrays.asList(byteBuffers).stream().map(buffer -&gt; &quot;position = &quot; + buffer.position() + &quot;, limit = &quot; + buffer.limit()).forEach(System.out::println);            &#125;            //将所有的 buffer 进行 flip            Arrays.asList(byteBuffers).forEach(buffer -&gt; buffer.flip());            //将数据读出显示到客户端            long byteWirte = 0;            while (byteWirte &lt; messageLength) &#123;                long l = socketChannel.write(byteBuffers);//                byteWirte += l;            &#125;                        //将所有的buffer进行clear            Arrays.asList(byteBuffers).forEach(buffer -&gt; &#123;                buffer.clear();            &#125;);                        System.out.println(&quot;byteRead = &quot; + byteRead + &quot;, byteWrite = &quot; + byteWirte + &quot;, messagelength = &quot; + messageLength);        &#125;    &#125;&#125;</code></pre><h2 id="7-Selector（选择器）"><a href="#7-Selector（选择器）" class="headerlink" title="7 Selector（选择器）"></a>7 Selector（选择器）</h2><h3 id="7-1-基本介绍"><a href="#7-1-基本介绍" class="headerlink" title="7.1 基本介绍"></a>7.1 基本介绍</h3><ol><li><code>Java</code> 的 <code>NIO</code>，用非阻塞的 <code>IO</code> 方式。可以用一个线程，处理多个的客户端连接，就会使用到 <code>Selector</code>（选择器）。</li><li><code>Selector</code> 能够检测多个注册的通道上是否有事件发生（注意：多个 <code>Channel</code> 以事件的方式可以注册到同一个 <code>Selector</code>），如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。【示意图】</li><li>只有在连接/通道真正有读写事件发生时，才会进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程。</li><li>避免了多线程之间的上下文切换导致的开销。</li></ol><h3 id="7-2-Selector-示意图和特点说明"><a href="#7-2-Selector-示意图和特点说明" class="headerlink" title="7.2 Selector 示意图和特点说明"></a>7.2 Selector 示意图和特点说明</h3><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_10.png" alt="img " style="zoom:50%;" /><p>说明如下：</p><ol><li><code>Netty</code> 的 <code>IO</code> 线程 <code>NioEventLoop</code> 聚合了 <code>Selector</code>（选择器，也叫多路复用器），可以同时并发处理成百上千个客户端连接。</li><li>当线程从某客户端 <code>Socket</code> 通道进行读写数据时，若没有数据可用时，该线程可以进行其他任务。</li><li>线程通常将非阻塞 <code>IO</code> 的空闲时间用于在其他通道上执行 <code>IO</code> 操作，所以单独的线程可以管理多个输入和输出通道。</li><li>由于读写操作都是非阻塞的，这就可以充分提升 <code>IO</code> 线程的运行效率，避免由于频繁 <code>I/O</code> 阻塞导致的线程挂起。</li><li>一个 <code>I/O</code> 线程可以并发处理 <code>N</code> 个客户端连接和读写操作，这从根本上解决了传统同步阻塞 <code>I/O</code> 一连接一线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。</li></ol><h3 id="7-3-Selector-类相关方法"><a href="#7-3-Selector-类相关方法" class="headerlink" title="7.3 Selector 类相关方法"></a>7.3 Selector 类相关方法</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_11.png" alt="img"></p><h3 id="7-4-注意事项"><a href="#7-4-注意事项" class="headerlink" title="7.4 注意事项"></a>7.4 注意事项</h3><ol><li><code>NIO</code> 中的 <code>ServerSocketChannel</code> 功能类似 <code>ServerSocket</code>、<code>SocketChannel</code> 功能类似 <code>Socket</code>。</li><li>Selector相关方法说明<ul><li><code>selector.select();</code> //阻塞</li><li><code>selector.select(1000);</code> //阻塞 1000 毫秒，在 1000 毫秒后返回</li><li><code>selector.wakeup();</code> //唤醒 selector</li><li><code>selector.selectNow();</code> //不阻塞，立马返还</li></ul></li></ol><h2 id="8-NIO-非阻塞网络编程原理分析图"><a href="#8-NIO-非阻塞网络编程原理分析图" class="headerlink" title="8 NIO 非阻塞网络编程原理分析图"></a>8 NIO 非阻塞网络编程原理分析图</h2><p><code>NIO</code> 非阻塞网络编程相关的（<code>Selector</code>、<code>SelectionKey</code>、<code>ServerScoketChannel</code> 和 <code>SocketChannel</code>）关系梳理图</p><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_22.png" alt="img"></p><p>对上图的说明：</p><ol><li>当客户端连接时，会通过 <code>ServerSocketChannel</code> 得到 <code>SocketChannel</code>。</li><li><code>Selector</code> 进行监听 <code>select</code> 方法，返回有事件发生的通道的个数。</li><li>将 <code>socketChannel</code> 注册到 <code>Selector</code> 上，<code>register(Selector sel, int ops)</code>，一个 <code>Selector</code> 上可以注册多个 <code>SocketChannel</code>。</li><li>注册后返回一个 <code>SelectionKey</code>，会和该 <code>Selector</code> 关联（集合）。</li><li>进一步得到各个 <code>SelectionKey</code>（有事件发生）。</li><li>在通过 <code>SelectionKey</code> 反向获取 <code>SocketChannel</code>，方法 <code>channel()</code>。</li><li>可以通过得到的 <code>channel</code>，完成业务处理。</li><li>代码撑腰。。。</li></ol><h2 id="9-NIO-非阻塞网络编程快速入门"><a href="#9-NIO-非阻塞网络编程快速入门" class="headerlink" title="9 NIO 非阻塞网络编程快速入门"></a>9 NIO 非阻塞网络编程快速入门</h2><p>案例要求：</p><ol><li>编写一个 <code>NIO</code> 入门案例，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>目的：理解 <code>NIO</code> 非阻塞网络编程机制</li><li>看老师代码演示</li></ol><h2 id="10-SelectionKey"><a href="#10-SelectionKey" class="headerlink" title="10 SelectionKey"></a>10 SelectionKey</h2><ol><li>SelectionKey，表示Selector 和网络通道的注册关系，共四种：<ul><li><code>int OP_ACCEPT</code>：有新的网络连接可以 <code>accept</code>，值为 <code>16</code></li><li><code>int OP_CONNECT</code>：代表连接已经建立，值为 <code>8</code></li><li><code>int OP_READ</code>：代表读操作，值为 <code>1</code></li><li><code>int OP_WRITE</code>：代表写操作，值为 <code>4</code></li></ul></li></ol><p>源码中：</p><pre><code class="java">public static final int OP_READ = 1 &lt;&lt; 0;public static final int OP_WRITE = 1 &lt;&lt; 2;public static final int OP_CONNECT = 1 &lt;&lt; 3;public static final int OP_ACCEPT = 1 &lt;&lt; 4;</code></pre><ol><li><code>SelectionKey</code> 相关方法</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_12.png" alt="img"></p><h2 id="11-ServerSocketChannel"><a href="#11-ServerSocketChannel" class="headerlink" title="11 ServerSocketChannel"></a>11 ServerSocketChannel</h2><ol><li><code>ServerSocketChannel</code> 在服务器端监听新的客户端 <code>Socket</code> 连接</li><li>相关方法如下</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_1png" alt="img"></p><h2 id="12-SocketChannel"><a href="#12-SocketChannel" class="headerlink" title="12 SocketChannel"></a>12 SocketChannel</h2><ol><li><code>SocketChannel</code>，网络 <code>IO</code> 通道，具体负责进行读写操作。<code>NIO</code> 把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区。</li><li>相关方法如下</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_14.png" alt="img"></p><h2 id="13-NIO-网络编程应用实例-群聊系统"><a href="#13-NIO-网络编程应用实例-群聊系统" class="headerlink" title="13 NIO 网络编程应用实例 - 群聊系统"></a>13 NIO 网络编程应用实例 - 群聊系统</h2><p>实例要求：</p><ol><li>编写一个 <code>NIO</code> 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞）</li><li>实现多人群聊</li><li>服务器端：可以监测用户上线，离线，并实现消息转发功能</li><li>客户端：通过 <code>Channel</code> 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息（有服务器转发得到）</li><li>目的：进一步理解 <code>NIO</code> 非阻塞网络编程机制</li><li>示意图分析和代码</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_15.png" alt="img"></p><p>代码：</p><pre><code class="java">// 服务端：import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.Channel;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.util.Iterator;public class GroupChatServer &#123;    //定义属性    private Selector selector;    private ServerSocketChannel listenChannel;    private static final int PORT = 6667;    //构造器    //初始化工作    public GroupChatServer() &#123;        try &#123;            //得到选择器            selector = Selector.open();            //ServerSocketChannel            listenChannel = ServerSocketChannel.open();            //绑定端口            listenChannel.socket().bind(new InetSocketAddress(PORT));            //设置非阻塞模式            listenChannel.configureBlocking(false);            //将该 listenChannel 注册到 selector            listenChannel.register(selector, SelectionKey.OP_ACCEPT);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    public void listen() &#123;        try &#123;            //循环处理            while (true) &#123;                int count = selector.select();                if (count &gt; 0) &#123; //有事件处理                    // 遍历得到 selectionKey 集合                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                    while (iterator.hasNext()) &#123;                        //取出 selectionkey                        SelectionKey key = iterator.next();                        //监听到 accept                        if (key.isAcceptable()) &#123;                            SocketChannel sc = listenChannel.accept();                            sc.configureBlocking(false);                            //将该 sc 注册到 seletor                            sc.register(selector, SelectionKey.OP_READ);                            //提示                            System.out.println(sc.getRemoteAddress() + &quot; 上线 &quot;);                        &#125;                        if (key.isReadable()) &#123;//通道发送read事件，即通道是可读的状态                            // 处理读(专门写方法..)                            readData(key);                        &#125;                        //当前的 key 删除，防止重复处理                        iterator.remove();                    &#125;                &#125; else &#123;                    System.out.println(&quot;等待....&quot;);                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            //发生异常处理....        &#125;    &#125;    //读取客户端消息    public void readData(SelectionKey key) &#123;        SocketChannel channel = null;        try &#123;            //得到 channel            channel = (SocketChannel) key.channel();            //创建 buffer            ByteBuffer buffer = ByteBuffer.allocate(1024);            int count = channel.read(buffer);            //根据 count 的值做处理            if (count &gt; 0) &#123;                //把缓存区的数据转成字符串                String msg = new String(buffer.array());                //输出该消息                System.out.println(&quot;form客户端:&quot; + msg);                //向其它的客户端转发消息(去掉自己),专门写一个方法来处理                sendInfoToOtherClients(msg, channel);            &#125;        &#125; catch (IOException e) &#123;            try &#123;                System.out.println(channel.getRemoteAddress() + &quot;离线了..&quot;);                //取消注册                key.cancel();                //关闭通道                channel.close();            &#125; catch (IOException e2) &#123;                e2.printStackTrace();            &#125;        &#125;    &#125;    //转发消息给其它客户(通道)    private void sendInfoToOtherClients(String msg, SocketChannel self) throws IOException &#123;        System.out.println(&quot;服务器转发消息中...&quot;);        //遍历所有注册到 selector 上的 SocketChannel,并排除 self        for (SelectionKey key : selector.keys()) &#123;            //通过 key 取出对应的 SocketChannel            Channel targetChannel = key.channel();            //排除自己            if (targetChannel instanceof SocketChannel &amp;&amp; targetChannel != self) &#123;                //转型                SocketChannel dest = (SocketChannel) targetChannel;                //将 msg 存储到 buffer                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes());                //将 buffer 的数据写入通道                dest.write(buffer);            &#125;        &#125;    &#125;    public static void main(String[] args) &#123;        //创建服务器对象        GroupChatServer groupChatServer = new GroupChatServer();        groupChatServer.listen();    &#125;&#125;// 客户端：import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.util.Iterator;import java.util.Scanner;public class GroupChatClient &#123;    //定义相关的属性    private final String HOST = &quot;127.0.0.1&quot;;//服务器的ip    private final int PORT = 6667;//服务器端口    private Selector selector;    private SocketChannel socketChannel;    private String username;    //构造器,完成初始化工作    public GroupChatClient() throws IOException &#123;                selector = Selector.open();        //连接服务器        socketChannel = SocketChannel.open(new InetSocketAddress(HOST, PORT));        //设置非阻塞        socketChannel.configureBlocking(false);        //将 channel 注册到selector        socketChannel.register(selector, SelectionKey.OP_READ);        //得到 username        username = socketChannel.getLocalAddress().toString().substring(1);        System.out.println(username + &quot; is ok...&quot;);    &#125;    //向服务器发送消息    public void sendInfo(String info) &#123;        info = username + &quot; 说：&quot; + info;        try &#123;            socketChannel.write(ByteBuffer.wrap(info.getBytes()));        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    //读取从服务器端回复的消息    public void readInfo() &#123;        try &#123;            int readChannels = selector.select();            if (readChannels &gt; 0) &#123;//有可以用的通道                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key = iterator.next();                    if (key.isReadable()) &#123;                        //得到相关的通道                        SocketChannel sc = (SocketChannel) key.channel();                        //得到一个 Buffer                        ByteBuffer buffer = ByteBuffer.allocate(1024);                        //读取                        sc.read(buffer);                        //把读到的缓冲区的数据转成字符串                        String msg = new String(buffer.array());                        System.out.println(msg.trim());                    &#125;                &#125;                iterator.remove(); //删除当前的 selectionKey,防止重复操作            &#125; else &#123;                //System.out.println(&quot;没有可以用的通道...&quot;);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    public static void main(String[] args) throws Exception &#123;        //启动我们客户端        GroupChatClient chatClient = new GroupChatClient();        //启动一个线程,每个 3 秒，读取从服务器发送数据        new Thread() &#123;            public void run() &#123;                while (true) &#123;                    chatClient.readInfo();                    try &#123;                        Thread.currentThread().sleep(3000);                    &#125; catch (InterruptedException e) &#123;                        e.printStackTrace();                    &#125;                &#125;            &#125;        &#125;.start();        //发送数据给服务器端        Scanner scanner = new Scanner(System.in);        while (scanner.hasNextLine()) &#123;            String s = scanner.nextLine();            chatClient.sendInfo(s);        &#125;    &#125;&#125;</code></pre><h2 id="14-NIO-与零拷贝"><a href="#14-NIO-与零拷贝" class="headerlink" title="14 NIO 与零拷贝"></a>14 NIO 与零拷贝</h2><h3 id="14-1-零拷贝基本介绍"><a href="#14-1-零拷贝基本介绍" class="headerlink" title="14.1 零拷贝基本介绍"></a>14.1 零拷贝基本介绍</h3><ol><li>零拷贝是网络编程的关键，很多性能优化都离不开。</li><li>在 <code>Java</code> 程序中，常用的零拷贝有 <code>mmap</code>（内存映射）和 <code>sendFile</code>。那么，他们在 <code>OS</code> 里，到底是怎么样的一个的设计？我们分析 <code>mmap</code> 和 <code>sendFile</code> 这两个零拷贝</li><li>另外我们看下 <code>NIO</code> 中如何使用零拷贝</li></ol><h3 id="14-2-传统-IO-数据读写"><a href="#14-2-传统-IO-数据读写" class="headerlink" title="14.2 传统 IO 数据读写"></a>14.2 传统 IO 数据读写</h3><p><code>Java</code> 传统 <code>IO</code> 和网络编程的一段代码</p><pre><code class="java">File file = new File(&quot;test.txt&quot;);RandomAccessFile raf = new RandomAccessFile(file, &quot;rw&quot;);byte[] arr = new byte[(int) file.length()];raf.read(arr);Socket socket = new ServerSocket(8080).accept();socket.getOutputStream().write(arr);</code></pre><h3 id="14-3-传统-IO-模型"><a href="#14-3-传统-IO-模型" class="headerlink" title="14.3 传统 IO 模型"></a>14.3 传统 IO 模型</h3><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_17.png" alt="img"></p><p><strong>DMA</strong>：<code>direct memory access</code> 直接内存拷贝（不使用 <code>CPU</code>）</p><h3 id="14-4-mmap-优化"><a href="#14-4-mmap-优化" class="headerlink" title="14.4 mmap 优化"></a>14.4 mmap 优化</h3><ol><li><code>mmap</code> 通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户空间的拷贝次数。如下图</li><li><code>mmap</code> 示意图</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_18.png" alt="img"></p><h3 id="14-5-sendFile-优化"><a href="#14-5-sendFile-优化" class="headerlink" title="14.5 sendFile 优化"></a>14.5 sendFile 优化</h3><ol><li><code>Linux2.1</code> 版本提供了 <code>sendFile</code> 函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到 <code>SocketBuffer</code>，同时，由于和用户态完全无关，就减少了一次上下文切换</li><li>示意图和小结</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_19.png" alt="img"></p><ol><li>提示：零拷贝从操作系统角度，是没有 <code>cpu</code> 拷贝</li><li><code>Linux在2.4</code> 版本中，做了一些修改，避免了从内核缓冲区拷贝到 <code>Socketbuffer</code> 的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝。具体如下图和小结：</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter03/chapter03_20.png" alt="img"></p><ol><li>这里其实有一次 <code>cpu</code> 拷贝 <code>kernel buffer</code> -&gt; <code>socket buffer</code> 但是，拷贝的信息很少，比如 <code>lenght</code>、<code>offset</code> 消耗低，可以忽略</li></ol><h3 id="14-6-零拷贝的再次理解"><a href="#14-6-零拷贝的再次理解" class="headerlink" title="14.6 零拷贝的再次理解"></a>14.6 零拷贝的再次理解</h3><ol><li>我们说零拷贝，是从操作系统的角度来说的。因为内核缓冲区之间，没有数据是重复的（只有 <code>kernel buffer</code> 有一份数据）。</li><li>零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，例如更少的上下文切换，更少的 <code>CPU</code> 缓存伪共享以及无 <code>CPU</code> 校验和计算。</li></ol><h3 id="14-7-mmap-和-sendFile-的区别"><a href="#14-7-mmap-和-sendFile-的区别" class="headerlink" title="14.7 mmap 和 sendFile 的区别"></a>14.7 mmap 和 sendFile 的区别</h3><ol><li><code>mmap</code> 适合小数据量读写，<code>sendFile</code> 适合大文件传输。</li><li><code>mmap</code> 需要 <code>4</code> 次上下文切换，<code>3</code> 次数据拷贝；<code>sendFile</code> 需要 <code>3</code> 次上下文切换，最少 <code>2</code> 次数据拷贝。</li><li><code>sendFile</code> 可以利用 <code>DMA</code> 方式，减少 <code>CPU</code> 拷贝，<code>mmap</code> 则不能（必须从内核拷贝到 <code>Socket</code>缓冲区）。</li></ol><h3 id="14-8-NIO-零拷贝案例"><a href="#14-8-NIO-零拷贝案例" class="headerlink" title="14.8 NIO 零拷贝案例"></a>14.8 NIO 零拷贝案例</h3><p>案例要求：</p><ol><li>使用传统的 <code>IO</code> 方法传递一个大文件</li><li>使用 <code>NIO</code> 零拷贝方式传递（<code>transferTo</code>）一个大文件</li><li>看看两种传递方式耗时时间分别是多少</li></ol><pre><code class="java">NewIOServer.javaimport java.net.InetSocketAddress;import java.net.ServerSocket;import java.nio.ByteBuffer;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;//服务器public class NewIOServer &#123;    public static void main(String[] args) throws Exception &#123;        InetSocketAddress address = new InetSocketAddress(7001);        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();        ServerSocket serverSocket = serverSocketChannel.socket();        serverSocket.bind(address);        //创建buffer        ByteBuffer byteBuffer = ByteBuffer.allocate(4096);        while (true) &#123;            SocketChannel socketChannel = serverSocketChannel.accept();            int readcount = 0;            while (-1 != readcount) &#123;                try &#123;                    readcount = socketChannel.read(byteBuffer);                &#125; catch (Exception ex) &#123;                    // ex.printStackTrace();                    break;                &#125;                //                byteBuffer.rewind(); //倒带 position = 0 mark 作废            &#125;        &#125;    &#125;&#125;NewIOClient.javaimport java.io.FileInputStream;import java.net.InetSocketAddress;import java.nio.channels.FileChannel;import java.nio.channels.SocketChannel;public class NewIOClient &#123;    public static void main(String[] args) throws Exception &#123;        SocketChannel socketChannel = SocketChannel.open();        socketChannel.connect(new InetSocketAddress(&quot;localhost&quot;, 7001));        String filename = &quot;protoc-6.1-win32.zip&quot;;        //得到一个文件channel        FileChannel fileChannel = new FileInputStream(filename).getChannel();        //准备发送        long startTime = System.currentTimeMillis();        //在 linux 下一个 transferTo 方法就可以完成传输        //在 windows 下一次调用 transferTo 只能发送 8m, 就需要分段传输文件,而且要主要        //传输时的位置=》课后思考...        //transferTo 底层使用到零拷贝        long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel);        System.out.println(&quot;发送的总的字节数 = &quot; + transferCount + &quot; 耗时: &quot; + (System.currentTimeMillis() - startTime));        //关闭        fileChannel.close();    &#125;&#125;</code></pre><h2 id="15-Java-AIO-基本介绍"><a href="#15-Java-AIO-基本介绍" class="headerlink" title="15 Java AIO 基本介绍"></a>15 Java AIO 基本介绍</h2><ol><li><code>JDK7</code> 引入了 <code>AsynchronousI/O</code>，即 <code>AIO</code>。在进行 <code>I/O</code> 编程中，常用到两种模式：<code>Reactor</code> 和 <code>Proactor</code>。<code>Java</code> 的 <code>NIO</code> 就是 <code>Reactor</code>，当有事件触发时，服务器端得到通知，进行相应的处理</li><li><code>AIO</code> 即 <code>NIO2.0</code>，叫做异步不阻塞的 <code>IO</code>。<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用</li><li>目前 <code>AIO</code> 还没有广泛应用，<code>Netty</code> 也是基于 <code>NIO</code>，而不是 <code>AIO</code>，因此我们就不详解 <code>AIO</code> 了，有兴趣的同学可以参考<a href="http://www.52im.net/thread-306-1-1.html">《Java新一代网络编程模型AIO原理及Linux系统AIO介绍》</a></li></ol><h2 id="16-BIO、NIO、AIO-对比表"><a href="#16-BIO、NIO、AIO-对比表" class="headerlink" title="16 BIO、NIO、AIO 对比表"></a>16 BIO、NIO、AIO 对比表</h2><table><thead><tr><th></th><th>BIO</th><th>NIO</th><th>AIO</th></tr></thead><tbody><tr><td>IO模型</td><td>同步阻塞</td><td>同步非阻塞（多路复用）</td><td>异步非阻塞</td></tr><tr><td>编程难度</td><td>简单</td><td>复杂</td><td>复杂</td></tr><tr><td>可靠性</td><td>差</td><td>好</td><td>好</td></tr><tr><td>吞吐量</td><td>低</td><td>高</td><td>高</td></tr></tbody></table><p><strong>举例说明</strong></p><ol><li>同步阻塞：到理发店理发，就一直等理发师，直到轮到自己理发。</li><li>同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其他事情，一会过来看是否轮到自己.</li><li>异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发</li></ol>]]></content>
      
      
      <categories>
          
          <category> IO网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO网络编程 </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BIO</title>
      <link href="/2021/10/01/bio/"/>
      <url>/2021/10/01/bio/</url>
      
        <content type="html"><![CDATA[<h2 id="1、-I-O-模型"><a href="#1、-I-O-模型" class="headerlink" title="1、 I/O 模型"></a>1、 I/O 模型</h2><ol><li><code>I/O</code> 模型简单的理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能。</li><li><code>Java</code> 共支持 <code>3</code> 种网络编程模型 <code>I/O</code> 模式：<code>BIO</code>、<code>NIO</code>、<code>AIO</code>。</li><li><code>Java BIO</code>：同步并阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。【简单示意图】</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter02/chapter02_01.png" alt="img"></p><ol><li><code>Java NIO</code>：同步非阻塞，服务器实现模式为一个线程处理多个请求（连接），即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有 <code>I/O</code> 请求就进行处理。【简单示意图】</li></ol><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter02/chapter02_02.png" alt="img"></p><ol><li><code>Java AIO(NIO.2)</code>：异步非阻塞，<code>AIO</code> 引入异步通道的概念，采用了 <code>Proactor</code> 模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用。</li><li>我们依次展开讲解。</li></ol><h2 id="2-、BIO、NIO、AIO-使用场景分析"><a href="#2-、BIO、NIO、AIO-使用场景分析" class="headerlink" title="2 、BIO、NIO、AIO 使用场景分析"></a>2 、BIO、NIO、AIO 使用场景分析</h2><ol><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，但程序简单易理解。</li><li><code>NIO</code> 方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，<code>JDK1.4</code> 开始支持。</li><li><code>AIO</code> 方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用 <code>OS</code> 参与并发操作，编程比较复杂，<code>JDK7</code> 开始支持。</li></ol><h2 id="3、-BIO-基本介绍"><a href="#3、-BIO-基本介绍" class="headerlink" title="3、 BIO 基本介绍"></a>3、 BIO 基本介绍</h2><ol><li><code>Java BIO</code> 就是传统的 <code>Java I/O</code> 编程，其相关的类和接口在 <code>java.io</code>。</li><li><code>BIO(BlockingI/O)</code>：同步阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）。【后有应用实例】</li><li><code>BIO</code> 方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，<code>JDK1.4</code> 以前的唯一选择，程序简单易理解。</li></ol><h2 id="4、-BIO-工作机制"><a href="#4、-BIO-工作机制" class="headerlink" title="4、 BIO 工作机制"></a>4、 BIO 工作机制</h2><p><img src="https://dongzl.github.io/netty-handbook/_media/chapter02/chapter02_03.png" alt="img"></p><p>对 <code>BIO</code> 编程流程的梳理</p><ol><li>服务器端启动一个 <code>ServerSocket</code>。</li><li>客户端启动 <code>Socket</code> 对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯。</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝。</li><li>如果有响应，客户端线程会等待请求结束后，在继续执行。</li></ol><h2 id="5、-BIO-应用实例"><a href="#5、-BIO-应用实例" class="headerlink" title="5、 BIO 应用实例"></a>5、 BIO 应用实例</h2><p>实例说明：</p><ol><li>使用 <code>BIO</code> 模型编写一个服务器端，监听 <code>6666</code> 端口，当有客户端连接时，就启动一个线程与之通讯。</li><li>要求使用线程池机制改善，可以连接多个客户端。</li><li>服务器端可以接收客户端发送的数据（<code>telnet</code> 方式即可）。</li><li>代码演示：</li></ol><pre><code class="java">import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class BIOServer &#123;    public static void main(String[] args) throws Exception &#123;        //线程池机制        //思路        //1. 创建一个线程池        //2. 如果有客户端连接，就创建一个线程，与之通讯(单独写一个方法)        ExecutorService newCachedThreadPool = Executors.newCachedThreadPool();        //创建ServerSocket        ServerSocket serverSocket = new ServerSocket(6666);        System.out.println(&quot;服务器启动了&quot;);        while (true) &#123;            System.out.println(&quot;线程信息id = &quot; + Thread.currentThread().getId() + &quot;名字 = &quot; + Thread.currentThread().getName());            //监听，等待客户端连接            System.out.println(&quot;等待连接....&quot;);            final Socket socket = serverSocket.accept();            System.out.println(&quot;连接到一个客户端&quot;);            //就创建一个线程，与之通讯(单独写一个方法)            newCachedThreadPool.execute(new Runnable() &#123;                public void run() &#123;//我们重写                    //可以和客户端通讯                    handler(socket);                &#125;            &#125;);        &#125;    &#125;    //编写一个handler方法，和客户端通讯    public static void handler(Socket socket) &#123;        try &#123;            System.out.println(&quot;线程信息id = &quot; + Thread.currentThread().getId() + &quot;名字 = &quot; + Thread.currentThread().getName());            byte[] bytes = new byte[1024];            //通过socket获取输入流            InputStream inputStream = socket.getInputStream();            //循环的读取客户端发送的数据            while (true) &#123;                System.out.println(&quot;线程信息id = &quot; + Thread.currentThread().getId() + &quot;名字 = &quot; + Thread.currentThread().getName());                System.out.println(&quot;read....&quot;);                int read = inputStream.read(bytes);                if (read != -1) &#123;                    System.out.println(new String(bytes, 0, read));//输出客户端发送的数据                &#125; else &#123;                    break;                &#125;            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125; finally &#123;            System.out.println(&quot;关闭和client的连接&quot;);            try &#123;                socket.close();            &#125; catch (Exception e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;Copy to clipboardErrorCopied</code></pre><h2 id="6、-BIO-问题分析"><a href="#6、-BIO-问题分析" class="headerlink" title="6、 BIO 问题分析"></a>6、 BIO 问题分析</h2><ol><li>每个请求都需要创建独立的线程，与对应的客户端进行数据 <code>Read</code>，业务处理，数据 <code>Write</code>。</li><li>当并发数较大时，需要创建大量线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读，则线程就阻塞在 <code>Read</code> 操作上，造成线程资源浪费。</li></ol>]]></content>
      
      
      <categories>
          
          <category> IO网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO网络编程 </tag>
            
            <tag> BIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于java的生成大疆弓形航线算法实现</title>
      <link href="/2021/05/25/da-jiang-sheng-cheng-gong-xing-hang-dian-suan-fa-java-shi-xian/"/>
      <url>/2021/05/25/da-jiang-sheng-cheng-gong-xing-hang-dian-suan-fa-java-shi-xian/</url>
      
        <content type="html"><![CDATA[<p><strong>问题背景：本人在开发过程中，遇到给定两个点的坐标，需要生成大量的有规律的坐标（实际上就是大疆无人机的航线）。查询相关资料发现国内的博客基本都是计算两点距离，计算点到线距离的距离等，有几篇也都是C语言形式。在这些资料的基础上本人继续研究深入，最终调试出了符合本人的业务场景的算法，在这里分享给予大家参考，算法精度到米级别</strong></p><h4 id="下面是算法实现的生成两张效果图："><a href="#下面是算法实现的生成两张效果图：" class="headerlink" title="下面是算法实现的生成两张效果图："></a>下面是算法实现的生成两张效果图：</h4><p>A点为起始坐标   B点为终点坐标   S为开始点   G为终点  下图为横向的方式生成 本文称为 短边方向  </p><p><img src="https://img-blog.csdnimg.cn/42b43ac8ec5f4d5c983820bd31b4e8fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMzMTgz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>按照 长边 的方向生成的效果图为</p><p><img src="https://img-blog.csdnimg.cn/25be718d32134dd68a8b606882869af0.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMzMTgz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h4 id="下面为算法的主要实现代码："><a href="#下面为算法的主要实现代码：" class="headerlink" title="下面为算法的主要实现代码："></a>下面为算法的主要实现代码：</h4><pre><code class="java">import com.jzi.cloud.api.entity.vo.CoordinateVo;import org.springframework.stereotype.Component;import java.util.ArrayList;import java.util.List;/** * 地理坐标处理工具类 * */@Componentpublic class GeographicalCoordinatesUtils &#123;    /**     * 地球半径（这里取的是平均半径）     */    private static final double EARTH_RADIUS = 6.371229 * 1e6;    /**     * 角度弧度计算公式 rad:()     * 360度=2π π=Math.PI     * x度 = x*π/360 弧度     */    private static double getRadian(double degree) &#123;        return degree * Math.PI / 180.0;    &#125;    /**     * 弧度换成度     * @param radian 弧度     * @return degree 度     */    public static double getDegree(double radian) &#123; return radian * 180 / Math.PI; &#125;    /**     * 依据经纬度计算两点之间的距离 GetDistance:()     * @param lng1 地点A的经度     * @param lat1 地点A的纬度     * @param lng2 地点B的经度     * @param lat2 地点B的纬度     * @return 返参 double 单米（m）     */    public static double getDistance(double lng1, double lat1, double lng2, double lat2) &#123;        double radLat1 = getRadian(lat1);        double radLat2 = getRadian(lat2);        double a = radLat1 - radLat2;// 两点纬度差        double b = getRadian(lng1) - getRadian(lng2);// 两点的经度差        double s = 2 * Math.asin(Math.sqrt(Math.pow(Math.sin(a / 2), 2) + Math.cos(radLat1)                * Math.cos(radLat2) * Math.pow(Math.sin(b / 2), 2)));        s = s * EARTH_RADIUS;        return s;    &#125;    /*     * 大地坐标系资料WGS-84 长半径a=6378137 短半径b=6356752.3142 扁率f=1/298.2572236     */    /** 长半径a=6378137 */    private static final double a = 6378137;    /** 短半径b=6356752.3142 */    private static final double b = 6356752.3142;    /** 扁率f=1/298.2572236 */    private static final double f = 1 / 298.2572236;    /**     * 通过一个点坐标计算另一点经纬度     * @param lon  经度     * @param lat  维度     * @param brng 方位角(传入角度)     * @param dist 距离（米）     * @return  double[] 经纬度     */    public static double[] computerThatLonLat(double lon, double lat, double brng, double dist) &#123;        double alpha1 = getRadian(brng);        double sinAlpha1 = Math.sin(alpha1);        double cosAlpha1 = Math.cos(alpha1);        double tanU1 = (1 - f) * Math.tan(getRadian(lat));        double cosU1 = 1 / Math.sqrt((1 + tanU1 * tanU1));        double sinU1 = tanU1 * cosU1;        double sigma1 = Math.atan2(tanU1, cosAlpha1);        double sinAlpha = cosU1 * sinAlpha1;        double cosSqAlpha = 1 - sinAlpha * sinAlpha;        double uSq = cosSqAlpha * (a * a - b * b) / (b * b);        double A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));        double B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));        double cos2SigmaM=0;        double sinSigma=0;        double cosSigma=0;        double sigma = dist / (b * A), sigmaP = 2 * Math.PI;        while (Math.abs(sigma - sigmaP) &gt; 1e-12) &#123;            cos2SigmaM = Math.cos(2 * sigma1 + sigma);            sinSigma = Math.sin(sigma);            cosSigma = Math.cos(sigma);            double deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)                    - B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * (-3 + 4 * cos2SigmaM * cos2SigmaM)));            sigmaP = sigma;            sigma = dist / (b * A) + deltaSigma;        &#125;        double tmp = sinU1 * sinSigma - cosU1 * cosSigma * cosAlpha1;        double lat2 = Math.atan2(sinU1 * cosSigma + cosU1 * sinSigma * cosAlpha1,                (1 - f) * Math.sqrt(sinAlpha * sinAlpha + tmp * tmp));        double lambda = Math.atan2(sinSigma * sinAlpha1, cosU1 * cosSigma - sinU1 * sinSigma * cosAlpha1);        double C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));        double L = lambda - (1 - C) * f * sinAlpha                * (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM)));        // final bearing        double revAz = Math.atan2(sinAlpha, -tmp);        double[] coordinates = new double[2];        coordinates[0] = lon+getDegree(L);        coordinates[1] = getDegree(lat2);        return coordinates;    &#125;    //传入两点，使用默认的宽度(10m)、间隔（10m）、高度200、长边生成航点    public static List&lt;CoordinateVo&gt; defaultGenerateCoordinates(double lng1, double lat1, double lng2, double lat2)&#123;        return coordinateProcessing(lng1, lat1, lng2, lat2, 10, 10,200,true);    &#125;    //传入两点，自定义的宽度、间隔、高度、长（短）边生成航点    public static List&lt;CoordinateVo&gt; customGenerateCoordinates(double lng1, double lat1, double lng2, double lat2,                                                                float width,float interval,float high,boolean direction)&#123;        return coordinateProcessing(lng1, lat1, lng2, lat2, width, interval,high,direction);    &#125;    /**     * 返回处理后的航点坐标的集合     * width  宽度     * interval 间隔距离     * high 航点高度     * direction true为长边，false为短边     */    private static List&lt;CoordinateVo&gt; coordinateProcessing(double lng1, double lat1, double lng2, double lat2,                                                           float width,float interval,float high,boolean direction )&#123;        //两点间距离        double distance = getDistance(lng1, lat1, lng2, lat2);        //计算偏移角        double offsetAngle= Math.toDegrees(Math.atan((lng1-lng2)/(lat1-lat2)));        //计算单边的航点数量        int divisionNum;        List&lt;CoordinateVo&gt; oneCoordinateVoList;        List&lt;CoordinateVo&gt; twoCoordinateVoList;        List&lt;CoordinateVo&gt; coordinateVos;        CoordinateVo coordinateVo1 ;        CoordinateVo coordinateVo2 ;                if (direction)&#123;            //长边            divisionNum = (int) Math.ceil( (width*2) / interval) + 1;            oneCoordinateVoList = new ArrayList&lt;&gt;(divisionNum); //上            twoCoordinateVoList = new ArrayList&lt;&gt;(divisionNum); //下            coordinateVos = new ArrayList&lt;&gt;(divisionNum * 2);            int temp = divisionNum / 2 ;            //处理点左边            for (int i = temp; i &gt;= 0; i--) &#123;                coordinateVo1 = new CoordinateVo();                coordinateVo2 = new CoordinateVo();                //上面左边                double[] leftCoordinateVo = computerThatLonLat(lng2, lat2, -90+offsetAngle, i*interval);                coordinateVo1.setLongitude(leftCoordinateVo[0]);                coordinateVo1.setLatitude(leftCoordinateVo[1]);                coordinateVo1.setAltitude((double) high);                oneCoordinateVoList.add(coordinateVo1);                //下面左边                double[] rightCoordinateVo = computerThatLonLat(lng1, lat1, -90+offsetAngle, i*interval);                coordinateVo2.setLongitude(rightCoordinateVo[0]);                coordinateVo2.setLatitude(rightCoordinateVo[1]);                coordinateVo2.setAltitude((double) high);                twoCoordinateVoList.add(coordinateVo2);            &#125;            //处理点右边            for (int i = 1; i &lt;= temp ; i++) &#123;                coordinateVo1 = new CoordinateVo();                coordinateVo2 = new CoordinateVo();                //上                double[] leftCoordinateVo = computerThatLonLat(lng2, lat2, 90+offsetAngle, i*interval);                coordinateVo1.setLongitude(leftCoordinateVo[0]);                coordinateVo1.setLatitude(leftCoordinateVo[1]);                coordinateVo1.setAltitude((double) high);                oneCoordinateVoList.add(coordinateVo1);                //下                double[] rightCoordinateVo = computerThatLonLat(lng1, lat1, 90+offsetAngle, i*interval);                coordinateVo2.setLongitude(rightCoordinateVo[0]);                coordinateVo2.setLatitude(rightCoordinateVo[1]);                coordinateVo2.setAltitude((double) high);                twoCoordinateVoList.add(coordinateVo2);            &#125;            //如果A点在上面则交换两个集合的数据            if (lat1&gt;lat2)&#123;                List&lt;CoordinateVo&gt; tempList=new ArrayList&lt;&gt;(oneCoordinateVoList);                oneCoordinateVoList = new ArrayList&lt;&gt;(twoCoordinateVoList);                twoCoordinateVoList = new ArrayList&lt;&gt;(tempList);            &#125;            //点排序            boolean flag=false;            for (int i = 0; i &lt; oneCoordinateVoList.size(); i++) &#123;                if (flag)&#123;                    //从下往上                    coordinateVos.add(twoCoordinateVoList.get(i));                    coordinateVos.add(oneCoordinateVoList.get(i));                    flag =false;                &#125;else &#123;                    //从上往下                    coordinateVos.add(oneCoordinateVoList.get(i));                    coordinateVos.add(twoCoordinateVoList.get(i));                    flag = true;                &#125;            &#125;        &#125;else &#123;            //短边            divisionNum = (int) Math.ceil(distance / interval) + 1;            oneCoordinateVoList = new ArrayList&lt;&gt;(divisionNum); //保存左侧的所有点            twoCoordinateVoList = new ArrayList&lt;&gt;(divisionNum); //保存右侧的所有点            coordinateVos = new ArrayList&lt;&gt;(divisionNum * 2);            //计算第一个点左边的坐标            double[] leftCoordinate = computerThatLonLat(lng1, lat1, -90+offsetAngle, width);            //计算第一个点右边的坐标            double[] rightCoordinate = computerThatLonLat(lng1, lat1, 90+offsetAngle, width);            //判断哪个点在上方            if (lat1&lt;lat2)&#123; //A下B上                //计算出所有点并且进行左右分类                for (int i = 0; i &lt; divisionNum; i++) &#123;                    coordinateVo1 = new CoordinateVo();                    coordinateVo2 = new CoordinateVo();                    //左边                    double[] leftCoordinateVo = computerThatLonLat(leftCoordinate[0], leftCoordinate[1], 0+offsetAngle, i*interval);                    coordinateVo1.setLongitude(leftCoordinateVo[0]);                    coordinateVo1.setLatitude(leftCoordinateVo[1]);                    coordinateVo1.setAltitude((double) high);                    oneCoordinateVoList.add(coordinateVo1);                    //右边                    double[] rightCoordinateVo = computerThatLonLat(rightCoordinate[0], rightCoordinate[1], 0+offsetAngle, i*interval);                    coordinateVo2.setLongitude(rightCoordinateVo[0]);                    coordinateVo2.setLatitude(rightCoordinateVo[1]);                    coordinateVo2.setAltitude((double) high);                    twoCoordinateVoList.add(coordinateVo2);                &#125;            &#125;else &#123;//A上B下                for (int i = 0; i &lt; divisionNum; i++) &#123;                    coordinateVo1 = new CoordinateVo();                    coordinateVo2 = new CoordinateVo();                    //左边                    double[] leftCoordinateVo = computerThatLonLat(leftCoordinate[0], leftCoordinate[1], 180+offsetAngle, i*interval);                    coordinateVo1.setLongitude(leftCoordinateVo[0]);                    coordinateVo1.setLatitude(leftCoordinateVo[1]);                    coordinateVo1.setAltitude((double) high);                    oneCoordinateVoList.add(coordinateVo1);                    //右边                    double[] rightCoordinateVo = computerThatLonLat(rightCoordinate[0], rightCoordinate[1], 180+offsetAngle, i*interval);                    coordinateVo2.setLongitude(rightCoordinateVo[0]);                    coordinateVo2.setLatitude(rightCoordinateVo[1]);                    coordinateVo2.setAltitude((double) high);                    twoCoordinateVoList.add(coordinateVo2);                &#125;            &#125;            //点排序            boolean flag=false;            for (int i = 0; i &lt; oneCoordinateVoList.size(); i++) &#123;                if (flag)&#123;                    //从右往左                    coordinateVos.add(twoCoordinateVoList.get(i));                    coordinateVos.add(oneCoordinateVoList.get(i));                    flag =false;                &#125;else &#123;                    //从左往右                    coordinateVos.add(oneCoordinateVoList.get(i));                    coordinateVos.add(twoCoordinateVoList.get(i));                    flag = true;                &#125;            &#125;        &#125;                return coordinateVos;    &#125;&#125;</code></pre><p>CoordinateVo对象为：</p><pre><code class="java">@Datapublic class CoordinateVo &#123;    private Double altitude;    private Double latitude;    private Double longitude;&#125;</code></pre><h4 id="使用方式："><a href="#使用方式：" class="headerlink" title="使用方式："></a>使用方式：</h4><p><strong>此工具类主要有两个方法：</strong></p><pre><code>    defaultGenerateCoordinates：传入两个坐标点的经纬度，其余参数使用，默认值    customGenerateCoordinates：传入两点，自定义的宽度、间隔、高度、长（短）边生成点</code></pre><p><strong>参数说明：</strong></p><pre><code> lng1   经度,     lat1    纬度,  lng2    经度,     lat2    纬度, width  宽度,     interval 间距 high  航点高度,direction  长短边 （true为长边方向，false为短边方向）</code></pre><p>测试：</p><pre><code class="java">double long1=120.09675077317218;        double lat1=30.24381935736484;        double long2=120.09748061125909;        double lat2=30.24408250042433;        System.err.println(&quot;传入坐标A(&quot;+long1+&quot;,&quot;+lat1+&quot;)  坐标B(&quot;+long2+&quot;,&quot;+lat2+&quot;)&quot;);        double distance = GeographicalCoordinatesUtils.getDistance(long1, lat1, long2, lat2);        System.err.println(&quot;两点间距离--&gt;&quot;+distance);        List&lt;CoordinateVo&gt; coordinateVos = GeographicalCoordinatesUtils.customGenerateCoordinates(                long1, lat1, long2, lat2,10,10,100,false);</code></pre><p>下面这些图为我前端测试的效果图，仅供大家参考</p><p><img src="https://img-blog.csdnimg.cn/4d3280a253ea493b9624bbd9c60f5bcc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMzMTgz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/a3411993864c41d2bc397639e815d2c9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMzMTgz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/ad8dbe3279564667a8761a9b5b78605b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMzMTgz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/d909d1238ffb4ffe9609b1322cb7dff9.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNTMzMTgz,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> dji </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dji </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云视频点播(sdk)的使用姿势</title>
      <link href="/2021/05/20/a-li-yun-shi-pin-dian-bo/"/>
      <url>/2021/05/20/a-li-yun-shi-pin-dian-bo/</url>
      
        <content type="html"><![CDATA[<h1 id="视频点播（SDK）"><a href="#视频点播（SDK）" class="headerlink" title="视频点播（SDK）"></a>视频点播（SDK）</h1><p><strong>阿里云文档地址：</strong></p><pre><code>https://help.aliyun.com/document_detail/57756.html?spm=a2c4g.11186623.6.1037.2bd84e28xsVzg2</code></pre><h2 id="1、引入依赖"><a href="#1、引入依赖" class="headerlink" title="1、引入依赖:"></a>1、引入依赖:</h2><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt;    &lt;version&gt;4.5.1&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-java-sdk-vod&lt;/artifactId&gt;    &lt;version&gt;2.15.11&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.aliyun&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-sdk-vod-upload&lt;/artifactId&gt;    &lt;version&gt;1.4.13&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;    &lt;artifactId&gt;fastjson&lt;/artifactId&gt;    &lt;version&gt;1.2.62&lt;/version&gt;  &lt;/dependency&gt;</code></pre><h2 id="2、初始化对象："><a href="#2、初始化对象：" class="headerlink" title="2、初始化对象："></a>2、初始化对象：</h2><pre><code class="java">public class InitObject &#123;    public static DefaultAcsClient initVodClient(String accessKeyId, String accessKeySecret) throws ClientException &#123;        String regionId = &quot;cn-shanghai&quot;;  // 点播服务接入区域        DefaultProfile profile = DefaultProfile.getProfile(regionId, accessKeyId, accessKeySecret);        DefaultAcsClient client = new DefaultAcsClient(profile);        return client;    &#125;&#125;</code></pre><h2 id="3、获取视频相关信息："><a href="#3、获取视频相关信息：" class="headerlink" title="3、获取视频相关信息："></a>3、获取视频相关信息：</h2><h3 id="3-1、根据视频id获取视频的播放地址："><a href="#3-1、根据视频id获取视频的播放地址：" class="headerlink" title="3.1、根据视频id获取视频的播放地址："></a>3.1、根据视频id获取视频的播放地址：</h3><p>注：加密后的视频不能直接通过地址访问</p><pre><code class="java">public class TestVod &#123;    public static void main(String[] args) throws ClientException &#123;//  1、根据是视频id获取视频的播放地址        //（1）创建初始化对象 参数：阿里云oss的上传密钥（此处替换成你自己的）        DefaultAcsClient client = InitObject.initVodClient(&quot;###&quot;, &quot;***&quot;);        // (2) 创建获取视频地址request 和response        GetPlayInfoRequest request = new GetPlayInfoRequest();        GetPlayInfoResponse response = new GetPlayInfoResponse();        // (3) 向request对象里面设置视频id        request.setVideoId(&quot;6e19e54e5f2341f487364a2aeae0f36e&quot;);        // (4) 调用初始化对象里面的方法传递request，获取数据        response = client.getAcsResponse(request);        List&lt;GetPlayInfoResponse.PlayInfo&gt; playInfoList = response.getPlayInfoList();        //播放地址        for (GetPlayInfoResponse.PlayInfo playInfo : playInfoList) &#123;            System.out.print(&quot;PlayInfo.PlayURL = &quot; + playInfo.getPlayURL() + &quot;\n&quot;);        &#125;        //Base信息        System.out.print(&quot;VideoBase.Title = &quot; + response.getVideoBase().getTitle() + &quot;\n&quot;);    &#125;&#125;</code></pre><h3 id="3-2、根据视频id获取视频的播放凭证："><a href="#3-2、根据视频id获取视频的播放凭证：" class="headerlink" title="3.2、根据视频id获取视频的播放凭证："></a>3.2、根据视频id获取视频的播放凭证：</h3><pre><code class="java">//  2、根据视频id获取视频播放凭证        //（1）创建初始化对象 参数：阿里云oss的上传密钥        DefaultAcsClient client = InitObject.initVodClient(&quot;###&quot;, &quot;***&quot;);        // (2) 创建获取视频凭证request 和response        GetVideoPlayAuthRequest request = new GetVideoPlayAuthRequest();        GetVideoPlayAuthResponse response = new GetVideoPlayAuthResponse();        // (3) 向request对象里面设置视频id        request.setVideoId(&quot;6e19e54e5f2341f487364a2aeae0f36e&quot;);        // (4) 调用初始化对象里面的方法传递request，获取数据        response = client.getAcsResponse(request);        System.out.println(&quot;视频播放凭证为：&quot;+response.getPlayAuth());</code></pre><h2 id="4、视频上传"><a href="#4、视频上传" class="headerlink" title="4、视频上传"></a>4、视频上传</h2><h3 id="4-1、本地视频上传"><a href="#4-1、本地视频上传" class="headerlink" title="4.1、本地视频上传"></a>4.1、本地视频上传</h3><pre><code class="java"> String accessKeyId = &quot;***&quot;;        String accessKeySecret = &quot;###&quot;;        String title = &quot;6 - What If I Want to Move Faster - upload by sdk&quot;;   //上传之后文件名称        String fileName = &quot;D:/Project/项目资料/1-阿里云上传测试视频/test.mp4&quot;;  //本地文件路径和名称        //上传视频的方法        UploadVideoRequest request = new UploadVideoRequest(accessKeyId, accessKeySecret, title, fileName);        /* 可指定分片上传时每个分片的大小，默认为2M字节 */        request.setPartSize(2 * 1024 * 1024L);        /* 可指定分片上传时的并发线程数，默认为1，(注：该配置会占用服务器CPU资源，需根据服务器情况指定）*/        request.setTaskNum(1);        UploadVideoImpl uploader = new UploadVideoImpl();        UploadVideoResponse response = uploader.uploadVideo(request);        if (response.isSuccess()) &#123;            System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\n&quot;);        &#125; else &#123;            /* 如果设置回调URL无效，不影响视频上传，可以返回VideoId同时会返回错误码。其他情况上传失败时，VideoId为空，此时需要根据返回错误码分析具体错误原因 */            System.out.print(&quot;VideoId=&quot; + response.getVideoId() + &quot;\n&quot;);            System.out.print(&quot;ErrorCode=&quot; + response.getCode() + &quot;\n&quot;);            System.out.print(&quot;ErrorMessage=&quot; + response.getMessage() + &quot;\n&quot;);        &#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 阿里云服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云对象存储(oss)的使用姿势</title>
      <link href="/2021/05/20/a-li-yun-oss/"/>
      <url>/2021/05/20/a-li-yun-oss/</url>
      
        <content type="html"><![CDATA[<h1 id="阿里云OSS使用"><a href="#阿里云OSS使用" class="headerlink" title="阿里云OSS使用"></a>阿里云OSS使用</h1><ul><li>首先在使用之前请先确保你已经申请了阿里云的oss对象存储服务（如果没有请先申请）</li><li>请先获取到oss的 endpoint、keyid、keysecret、bucketname的值（每个人都不一样）</li></ul><h4 id="1、创建一个新的模块"><a href="#1、创建一个新的模块" class="headerlink" title="1、创建一个新的模块"></a>1、创建一个新的模块</h4><p>配置文件为：</p><pre><code class="properties">#服务名spring.application.name=service-ossserver.port=8086spring.profiles.active=dev#阿里云oss配置 （以下信息替换成你自己的）aliyun.oss.file.endpoint=***aliyun.oss.file.keyid=***aliyun.oss.file.keysecret=***#bucket可以在控制台创建，也可以使用java代码创建aliyun.oss.file.bucketname=***</code></pre><h4 id="2、创建utils、controller、service包-和-启动类"><a href="#2、创建utils、controller、service包-和-启动类" class="headerlink" title="2、创建utils、controller、service包 和 启动类"></a>2、创建utils、controller、service包 和 启动类</h4><p>启动类为：</p><pre><code class="java">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)  //配置启动类不加载数据库@ComponentScan(basePackages = &#123;&quot;com.hscs&quot;&#125;)        //扫描包public class OssApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(OssApplication.class, args);    &#125;&#125;</code></pre><h4 id="3、在utils包下创建ConstantPropertiesUtlis类"><a href="#3、在utils包下创建ConstantPropertiesUtlis类" class="headerlink" title="3、在utils包下创建ConstantPropertiesUtlis类"></a>3、在utils包下创建ConstantPropertiesUtlis类</h4><pre><code class="java">@Componentpublic class ConstantPropertiesUtlis implements InitializingBean &#123;    @Value(&quot;$&#123;aliyun.oss.file.endpoint&#125;&quot;)    private String endpoint;    @Value(&quot;$&#123;aliyun.oss.file.keyid&#125;&quot;)    private String keyId;    @Value(&quot;$&#123;aliyun.oss.file.keysecret&#125;&quot;)    private String keySecret;    @Value(&quot;$&#123;aliyun.oss.file.bucketname&#125;&quot;)    private String bucketName;    public static String END_POINT;    public static String KEY_ID;    public static String KEY_SECRET;    public static String BUCKET_NAME;    @Override    public void afterPropertiesSet() throws Exception &#123;        END_POINT=endpoint;        KEY_ID=keyId;        KEY_SECRET=keySecret;        BUCKET_NAME=bucketName;    &#125;&#125;</code></pre><h4 id="4、创建controller类"><a href="#4、创建controller类" class="headerlink" title="4、创建controller类"></a>4、创建controller类</h4><pre><code class="java">@Controller@RequestMapping(&quot;oss/fileoss&quot;)@CrossOriginpublic class OssController &#123;    @Autowired    private OssService ossService;    /**     * 上传头像     * */    @PostMapping()    public R uploadFileOss(MultipartFile file)&#123;        String url=ossService.uploadFileAvatar(file);        return R.ok().data(&quot;url&quot;,url);    &#125;&#125;</code></pre><h4 id="5、创建业务接口和实现接口类"><a href="#5、创建业务接口和实现接口类" class="headerlink" title="5、创建业务接口和实现接口类"></a>5、创建业务接口和实现接口类</h4><pre><code class="java">//接口public interface OssService &#123;    String uploadFileAvatar(MultipartFile file);&#125;//类/** * @author wmg *  文件上传业务实现 */@Servicepublic class OssServiceImpl implements OssService &#123;    @Override    public String uploadFileAvatar(MultipartFile file) &#123;        String endpoint = ConstantPropertiesUtlis.END_POINT;        String accessKeyId = ConstantPropertiesUtlis.KEY_ID;        String accessKeySecret = ConstantPropertiesUtlis.KEY_SECRET;        String bucketName=ConstantPropertiesUtlis.BUCKET_NAME;        try&#123;            // 创建OSSClient实例。            OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);            //获取文件名称            String fileName = file.getOriginalFilename();            //在文件里面添加随机唯一的id值，避免名字重复造成文件覆盖            String uuid = UUID.randomUUID().toString().replaceAll(&quot;-&quot;, &quot;&quot;);            fileName=uuid+fileName;            //将文件按日期分类            String datePath = new DateTime().toString(&quot;yyyy/MM/dd&quot;);            fileName=datePath+&quot;/&quot;+fileName;            // 上传文件流。            InputStream inputStream = file.getInputStream();            //第一个参数为bucket名  第二个参数为上传文件路径            ossClient.putObject(bucketName, fileName, inputStream);            //将上传路径返回  https://home-school-communication.oss-cn-guangzhou.aliyuncs.com/image/1.jpg            String url=&quot;https://&quot;+bucketName+&quot;.&quot;+endpoint+&quot;/&quot;+fileName;            // 关闭OSSClient。            ossClient.shutdown();            return url;        &#125;catch (Exception e)&#123;            System.out.println(&quot;图片上传失败！&quot;);            e.printStackTrace();            return null;        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 阿里云服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> oss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS 7 安装go-fastdfs及可视化界面go-fastdfs-web</title>
      <link href="/2021/04/25/centos7-an-zhuang-go-fastdfs/"/>
      <url>/2021/04/25/centos7-an-zhuang-go-fastdfs/</url>
      
        <content type="html"><![CDATA[<h3 id="1、安装go-fastdfs"><a href="#1、安装go-fastdfs" class="headerlink" title="1、安装go-fastdfs"></a>1、安装go-fastdfs</h3><h4 id="1-1-下载go-fastdfs相关文件并且授予执行权限"><a href="#1-1-下载go-fastdfs相关文件并且授予执行权限" class="headerlink" title="1.1 下载go-fastdfs相关文件并且授予执行权限"></a>1.1 下载go-fastdfs相关文件并且授予执行权限</h4><pre><code class="powershell">#创建文件夹cd /usr/local/mkdir go-fastdfsmkdir go-fastdfs-webcd go-fastdfs#如果无法连接github可以换成gitee wget https://github.com/sjqzhang/go-fastdfs/releases/download/v1.3.0/fileserverwget  https://raw.githubusercontent.com/sjqzhang/go-fastdfs/master/control#下载完毕进行授权，否则无法执行chmod 755 fileserverchmod 755 control#启动（看到running..即为成功，运行成功之后会生成一些文件 ll 可查看）./control start# 放行服务器端口8080后使用如下指令访问http://你的ip:8080#出现如下页面即可</code></pre><p><img src="https://img-blog.csdnimg.cn/04a1ac263f4e4813bba05093a239a54e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3YtbWFzdGVy,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述"><strong>修改配置文件</strong><br>go-fastdfs的配置文件在 conf下的cfg.json文件里面 直接 vim conf/cfg.json 进入修改保存即可，配置文件全部有中文注释，白名单中添加本机ip,或者你想放行的ip即可<br><img src="https://img-blog.csdnimg.cn/62dd2b930d1f4ce98847b294d5f273ca.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAY3YtbWFzdGVy,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="在这里插入图片描述">修改完毕保存重启即可</p><pre><code class="powershell">#启动/停止/重启/查看状态/查看日志./control start|stop|restart|status|tail</code></pre><h3 id="1-2-安装可视化工具go-fastdfs-web"><a href="#1-2-安装可视化工具go-fastdfs-web" class="headerlink" title="1.2 安装可视化工具go-fastdfs-web"></a>1.2 安装可视化工具go-fastdfs-web</h3><p><strong>注：可视化工具需java环境(jdk)未安装可参考以下教程进行安装</strong></p><blockquote><p>安装jdk 教程<br><a href="https://www.cnblogs.com/sxdcgaq8080/p/7492426.html">https://www.cnblogs.com/sxdcgaq8080/p/7492426.html</a></p></blockquote><pre><code class="powershell">#下载可视化资源包（.tar.gz）https://github.com/perfree/go-fastdfs-web/releases#下载完毕上传到go-fastdfs-web目录下解压tar -zxvf go-fastdfs-web-v1.3.6.tar.gz#进入go-fastdfs-web目录下 分配权限chmod +x goFastDfsWeb.sh#运行./goFastDfsWeb.sh start#开放服务器8088端口 运行成功后http://ip:8088    #访问#如果启动报  -bash: ./goFastDfsWeb.sh: /bin/bash^M: bad interpreter: No such file or directory#解决方法：vim goFastDfsWeb.sh:set fileformat=unix#保存退出即可#运行./goFastDfsWeb.sh start</code></pre><p>成功运行后按照界面文字说明注册即可(“注：连接的ip 要在go-fastdfs配置文件的白名单中”)</p>]]></content>
      
      
      <categories>
          
          <category> go-fastdfs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
            <tag> go-fastdfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker中安装常用的服务(docker、mysql、redis、prtainer、go-fastdfs、rocketMQ)</title>
      <link href="/2021/04/01/docker-an-zhuang-fu-wu/"/>
      <url>/2021/04/01/docker-an-zhuang-fu-wu/</url>
      
        <content type="html"><![CDATA[<h1 id="docker安装服务"><a href="#docker安装服务" class="headerlink" title="docker安装服务"></a>docker安装服务</h1><h3 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h3><pre><code class="sh">sudo sed -e &#39;s|^mirrorlist=|#mirrorlist=|g&#39; \         -e &#39;s|^#baseurl=http://mirror.centos.org|baseurl=https://mirrors.tuna.tsinghua.edu.cn|g&#39; \         -i.bak \         /etc/yum.repos.d/CentOS-*.repo          sudo yum makecache          #上传，下载工具 yum -y install lrzsz #上传  rz  下载 sz</code></pre><h3 id="centos7安装docker"><a href="#centos7安装docker" class="headerlink" title="centos7安装docker"></a>centos7安装docker</h3><pre><code class="shell">#卸载系统之前的docker sudo yum remove docker \                  docker-client \                  docker-client-latest \                  docker-common \                  docker-latest \                  docker-latest-logrotate \                  docker-logrotate \                  docker-engine                  #安装工具                  sudo yum install -y yum-utils# 配置镜像sudo yum-config-manager \    --add-repo \    https://download.docker.com/linux/centos/docker-ce.repo# 安装    sudo yum install -y docker-ce docker-ce-cli containerd.io#启动sudo systemctl start docker# 设置开机自启动sudo systemctl enable dockerdocker -vsudo docker images# 配置（阿里云）镜像加速sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-&#39;EOF&#39;&#123;  &quot;registry-mirrors&quot;: [&quot;https://pacmlq67.mirror.aliyuncs.com&quot;]&#125;EOF#修改docker 支持远程访问vim /lib/systemd/system/docker.service#修改这一行ExecStart=/usr/bin/dockerd  -H tcp://0.0.0.0:2375 -H fd:// --containerd=/run/containerd/containerd.sock #重启sudo systemctl daemon-reload &amp;&amp; sudo systemctl restart docker</code></pre><h3 id="docker安装mysql"><a href="#docker安装mysql" class="headerlink" title="docker安装mysql"></a>docker安装mysql</h3><pre><code class="shell">#拉取镜像sudo docker pull mysql:5.7# --name指定容器名字 -v目录挂载 -p指定端口映射  -e设置mysql参数 -d后台运行sudo docker run -p 3306:3306 --name mysql-pro \-v /mydata/mysql/log:/var/log/mysql \-v /mydata/mysql/data:/var/lib/mysql \-v /mydata/mysql/conf:/etc/mysql \-e TZ=Asia/Shanghai \-e MYSQL_ROOT_PASSWORD=123456 \-d mysql:5.7docker exec -it mysql bin/bashexit因为有目录映射，所以我们可以直接在镜像外执行vi /mydata/mysql/conf/my.conf [client]default-character-set=utf8[mysql]default-character-set=utf8[mysqld]init_connect=&#39;SET collation_connection = utf8_unicode_ci&#39;init_connect=&#39;SET NAMES utf8&#39;character-set-server=utf8collation-server=utf8_unicode_cidefault-time-zone = &#39;+08:00&#39;skip-character-set-client-handshakeskip-name-resolvedocker restart mysql</code></pre><h3 id="docker安装redis"><a href="#docker安装redis" class="headerlink" title="docker安装redis"></a>docker安装redis</h3><pre><code class="shell"># 在虚拟机中mkdir -p /mydata/redis/conftouch /mydata/redis/conf/redis.confdocker pull redisdocker run -p 6379:6379 --name redis \-v /mydata/redis/data:/data \-v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf \-d redis redis-server /etc/redis/redis.conf# 直接进去redis客户端。docker exec -it redis redis-cli#配置持久化vim /mydata/redis/conf/redis.conf# 插入下面内容appendonly yes保存docker restart redis#配置开机自启docker update redis --restart=always</code></pre><h3 id="docker安装可视化prtainer"><a href="#docker安装可视化prtainer" class="headerlink" title="docker安装可视化prtainer"></a>docker安装可视化prtainer</h3><pre><code class="shell">docker pull portainer/portainerdocker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer  portainer/portainer#访问http://ip:9000/</code></pre><h3 id="docker安装go-fastdfs"><a href="#docker安装go-fastdfs" class="headerlink" title="docker安装go-fastdfs"></a>docker安装go-fastdfs</h3><pre><code class="shell">#拉取镜像docker pull sjqzhang/go-fastdfs:latest#创建保存目录mkdir usr/local/datamkdir usr/local/fastdfs_data#运行docker run --name go-fastdfs --privileged=true -t -p 9090:8080 -v /usr/local/data/fastdfs_data:/data -e GO_FASTDFS_DIR=/data sjqzhang/go-fastdfs#访问http://ip:9090/</code></pre><pre><code>go-fastdfs的目录结构一般是：├── conf│   └── cfg.json├── data│   ├── 20200102│   ├── fileserver.db│   ├── log.db│   └── stat.json├── files│   ├── _big│   └── default├── fileserver├── log│   ├── access.log│   ├── fileserver.log│   └── tusd.log└── static    └── uppy.html</code></pre><h4 id="go-fastdfs-web可视化界面"><a href="#go-fastdfs-web可视化界面" class="headerlink" title="go-fastdfs-web可视化界面"></a>go-fastdfs-web可视化界面</h4><pre><code class="shell">#下载镜像文件docker pull perfree/fastdfsweb#运行容器docker run --name fastdfsweb -d -p 8088:8088 perfree/fastdfsweb#测试是否正常访问http://本地ip:8088 #配置go-fastdfs-web集群名称：随意填写组：对应本地映射中文件夹conf/cfg.json 文件内容中的group访问地址：http://本地ip:8080</code></pre><h3 id="docker安装RocketMQ"><a href="#docker安装RocketMQ" class="headerlink" title="docker安装RocketMQ"></a>docker安装RocketMQ</h3><pre><code class="shell">#查找镜像docker search rocketmq#下载并且启动NameServerdocker run -d -p 9876:9876 --name rmqserver  foxiswho/rocketmq:server-4.5.1#启动broker    Broker容器中默认的配置文件的路径为：/etc/rocketmq/broker.confdocker run -d -p 10911:10911 -p 10909:10909\ --name rmqbroker --link rmqserver:namesrv\ -e &quot;NAMESRV_ADDR=namesrv:9876&quot; -e &quot;JAVA_OPTS=-Duser.home=/opt&quot;\ -e &quot;JAVA_OPT_EXT=-server -Xms128m -Xmx128m&quot;\ -v /conf/broker.conf:/etc/rocketmq/broker.conf \ foxiswho/rocketmq:broker-4.5.1 #下载并且启动 rocketmq consoledocker run -d --name rmqconsole -p 8180:8080 --link rmqserver:namesrv\ -e &quot;JAVA_OPTS=-Drocketmq.namesrv.addr=namesrv:9876\ -Dcom.rocketmq.sendMessageWithVIPChannel=false&quot;\ -t styletang/rocketmq-console-ng  #命令检查一下启动情况docker ps|grep rocketmq#通过浏览器访问console页面ip：8180/</code></pre><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><pre><code class="shell">#查看运行容器的宿主机进程ps aux|grep sleep|grep -v grep#进入容器内部docker exec -it 容器id /bin/sh#查看容器日志docker logs -f 容器id#容器内安装软件yum/apt-get/apt #查看docker端口情况netstat -luntp</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目的常用组件集成（swagger、统一返回结果、异常、日志、包扫描）</title>
      <link href="/2021/03/01/swagger-result-exception-log/"/>
      <url>/2021/03/01/swagger-result-exception-log/</url>
      
        <content type="html"><![CDATA[<h2 id="swagger2配置"><a href="#swagger2配置" class="headerlink" title="swagger2配置"></a>swagger2配置</h2><pre><code class="xml">        &lt;!-- swagger--&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;            &lt;version&gt;2.9.2&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--UI展示页面--&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.springfox&lt;/groupId&gt;            &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;            &lt;version&gt;2.9.2&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>1、创建swaggerConfig配置类</p><pre><code class="java">@Configuration@EnableSwagger2public class SwaggerConfig &#123;    @Bean    public Docket webApiConfig()&#123;        return new Docket(DocumentationType.SWAGGER_2)                .groupName(&quot;webApi&quot;)                .apiInfo(webApiInfo())                .select()                //若路径中包含/admin/  或  /error 则不显示                .paths(Predicates.not(PathSelectors.regex(&quot;/admin/.*&quot;)))                .paths(Predicates.not(PathSelectors.regex(&quot;/error.*&quot;)))                .build();    &#125;    private ApiInfo webApiInfo()&#123;        return new ApiInfoBuilder()                .title(&quot;网站-课程中心API文档&quot;)                .description(&quot;本文档描述了课程中心微服务接口定义&quot;)                .version(&quot;1.0&quot;)                .contact(new Contact(&quot;java&quot;, &quot;http://aliyun.com&quot;, &quot;1123@qq.com&quot;))                .build();    &#125;&#125;</code></pre><p>2、在启动类上添加扫描包注解</p><pre><code class="java">@ComponentScan(basePackages = &#123;&quot;com.painter&quot;&#125;)//路径到所有配置类的父级包名之前</code></pre><p>3、使用swagger注解</p><pre><code class="java">@Api(&quot;讲师管理&quot;)            //放在@Controller相同的地方@ApiOperation(value = &quot;获取所有讲师列表&quot;)  //放在controller层的方法接口上@ApiModel(value=&quot;EduTeacher对象&quot;, description=&quot;讲师&quot;)  //放在实体类上与@Data相同的地方@ApiModelProperty(value = &quot;讲师ID&quot;)  //放实体类属性名上</code></pre><p>4、访问</p><pre><code>http://localhost:8080/swagger-ui.html</code></pre><h2 id="统一结果返回"><a href="#统一结果返回" class="headerlink" title="统一结果返回"></a>统一结果返回</h2><pre><code class="java">//1、在config包中新建一个接口（定义返回状态码）public interface ResultCode &#123;    //成功    public static Integer SUCCESS=200;    //失败    public static Integer ERROR=400;&#125;//2、创建返回结果类@Datapublic class R &#123;    @ApiModelProperty(value = &quot;是否成功&quot;)    private Boolean success;    @ApiModelProperty(value = &quot;返回码&quot;)    private Integer code;    @ApiModelProperty(value = &quot;返回消息&quot;)    private String message;    @ApiModelProperty(value = &quot;返回数据&quot;)    private Map&lt;String, Object&gt; data = new HashMap&lt;String, Object&gt;();    //把构造方法私有    private R() &#123;&#125;    //成功静态方法    public static R ok() &#123;        R r = new R();        r.setSuccess(true);        r.setCode(ResultCode.SUCCESS);        r.setMessage(&quot;成功&quot;);        return r;    &#125;    //失败静态方法    public static R error() &#123;        R r = new R();        r.setSuccess(false);        r.setCode(ResultCode.ERROR);        r.setMessage(&quot;失败&quot;);        return r;    &#125;    public R success(Boolean success)&#123;        this.setSuccess(success);        return this;    &#125;    public R message(String message)&#123;        this.setMessage(message);        return this;    &#125;    public R code(Integer code)&#123;        this.setCode(code);        return this;    &#125;    public R data(String key, Object value)&#123;        this.data.put(key, value);        return this;    &#125;    public R data(Map&lt;String, Object&gt; map)&#123;        this.setData(map);        return this;    &#125;&#125;</code></pre><h2 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h2><pre><code class="java">//1、创建统一异常处理类@ControllerAdvicepublic class ExceptionHandler &#123;    /**     * 指定出现什么异常执行此方法  此方法为全局异常处理     * */    @org.springframework.web.bind.annotation.ExceptionHandler(Exception.class)    @ResponseBody    public Result error(GuliException e)&#123;        e.printStackTrace();        return Result.error().code(e.getCode()).message(e.getMsg());    &#125;&#125;//2、自定义异常处理类@Data@Accessors(chain = true)@AllArgsConstructor@NoArgsConstructorpublic class GuliException extends RuntimeException&#123;    private Integer code;    private String msg;&#125;//3、测试使用try &#123;        int a = 10/0;    &#125;catch(Exception e) &#123;        throw new GuliException(200,&quot;出现自定义异常&quot;);    &#125;</code></pre><h2 id="统一日志处理"><a href="#统一日志处理" class="headerlink" title="统一日志处理"></a>统一日志处理</h2><p>一、日志</p><p>1、配置日志级别</p><p>日志记录器（Logger）的行为是分等级的。如下表所示：</p><p>分为：OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL</p><p>默认情况下，spring boot从控制台打印出来的日志级别只有INFO及以上级别，可以配置日志级别</p><pre><code class="properties"># 设置日志级别logging.level.root=WARN</code></pre><p><strong>二、Logback日志</strong></p><pre><code class="pox">&lt;dependency&gt;     &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;     &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>1、配置logback日志</p><p>删除application.properties中的日志配置</p><p>安装idea彩色日志插件：grep-console</p><p>resources 中创建  logback-spring.xml </p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!-- 日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出 --&gt;&lt;!-- scan:当此属性设置为true时，配置文档如果发生改变，将会被重新加载，默认值为true --&gt;&lt;!-- scanPeriod:设置监测配置文档是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。                 当scan为true时，此属性生效。默认的时间间隔为1分钟。 --&gt;&lt;!-- debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。 --&gt;&lt;configuration  scan=&quot;true&quot; scanPeriod=&quot;10 seconds&quot;&gt;    &lt;contextName&gt;logback&lt;/contextName&gt;    &lt;!-- name的值是变量的名称，value的值时变量定义的值。通过定义的值会被插入到logger上下文中。定义后，可以使“$&#123;&#125;”来使用变量。 --&gt;    &lt;property name=&quot;log.path&quot; value=&quot;G:/logs/pmp&quot; /&gt;    &lt;!--0. 日志格式和颜色渲染 --&gt;    &lt;!-- 彩色日志依赖的渲染类 --&gt;    &lt;conversionRule conversionWord=&quot;clr&quot; converterClass=&quot;org.springframework.boot.logging.logback.ColorConverter&quot; /&gt;    &lt;conversionRule conversionWord=&quot;wex&quot; converterClass=&quot;org.springframework.boot.logging.logback.WhitespaceThrowableProxyConverter&quot; /&gt;    &lt;conversionRule conversionWord=&quot;wEx&quot; converterClass=&quot;org.springframework.boot.logging.logback.ExtendedWhitespaceThrowableProxyConverter&quot; /&gt;    &lt;!-- 彩色日志格式 --&gt;    &lt;property name=&quot;CONSOLE_LOG_PATTERN&quot; value=&quot;$&#123;CONSOLE_LOG_PATTERN:-%clr(%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&#125;&quot;/&gt;    &lt;!--1. 输出到控制台--&gt;    &lt;appender name=&quot;CONSOLE&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt;        &lt;!--此日志appender是为开发使用，只配置最底级别，控制台输出的日志级别是大于或等于此级别的日志信息--&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&gt;            &lt;level&gt;debug&lt;/level&gt;        &lt;/filter&gt;        &lt;encoder&gt;            &lt;Pattern&gt;$&#123;CONSOLE_LOG_PATTERN&#125;&lt;/Pattern&gt;            &lt;!-- 设置字符集 --&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;    &lt;/appender&gt;    &lt;!--2. 输出到文档--&gt;    &lt;!-- 2.1 level为 DEBUG 日志，时间滚动输出  --&gt;    &lt;appender name=&quot;DEBUG_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 正在记录的日志文档的路径及文档名 --&gt;        &lt;file&gt;$&#123;log.path&#125;/web_debug.log&lt;/file&gt;        &lt;!--日志文档输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 设置字符集 --&gt;        &lt;/encoder&gt;        &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!-- 日志归档 --&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;/web-debug-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--日志文档保留天数--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!-- 此日志文档只记录debug级别的 --&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;debug&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;!-- 2.2 level为 INFO 日志，时间滚动输出  --&gt;    &lt;appender name=&quot;INFO_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 正在记录的日志文档的路径及文档名 --&gt;        &lt;file&gt;$&#123;log.path&#125;/web_info.log&lt;/file&gt;        &lt;!--日志文档输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;        &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;!-- 每天日志归档路径以及格式 --&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;/web-info-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--日志文档保留天数--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!-- 此日志文档只记录info级别的 --&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;info&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;!-- 2.3 level为 WARN 日志，时间滚动输出  --&gt;    &lt;appender name=&quot;WARN_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 正在记录的日志文档的路径及文档名 --&gt;        &lt;file&gt;$&#123;log.path&#125;/web_warn.log&lt;/file&gt;        &lt;!--日志文档输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;        &lt;/encoder&gt;        &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;/web-warn-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--日志文档保留天数--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!-- 此日志文档只记录warn级别的 --&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;warn&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;!-- 2.4 level为 ERROR 日志，时间滚动输出  --&gt;    &lt;appender name=&quot;ERROR_FILE&quot; class=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&gt;        &lt;!-- 正在记录的日志文档的路径及文档名 --&gt;        &lt;file&gt;$&#123;log.path&#125;/web_error.log&lt;/file&gt;        &lt;!--日志文档输出格式--&gt;        &lt;encoder&gt;            &lt;pattern&gt;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n&lt;/pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;!-- 此处设置字符集 --&gt;        &lt;/encoder&gt;        &lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;        &lt;rollingPolicy class=&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;&gt;            &lt;fileNamePattern&gt;$&#123;log.path&#125;/web-error-%d&#123;yyyy-MM-dd&#125;.%i.log&lt;/fileNamePattern&gt;            &lt;timeBasedFileNamingAndTriggeringPolicy class=&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;&gt;                &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;            &lt;/timeBasedFileNamingAndTriggeringPolicy&gt;            &lt;!--日志文档保留天数--&gt;            &lt;maxHistory&gt;15&lt;/maxHistory&gt;        &lt;/rollingPolicy&gt;        &lt;!-- 此日志文档只记录ERROR级别的 --&gt;        &lt;filter class=&quot;ch.qos.logback.classic.filter.LevelFilter&quot;&gt;            &lt;level&gt;ERROR&lt;/level&gt;            &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt;            &lt;onMismatch&gt;DENY&lt;/onMismatch&gt;        &lt;/filter&gt;    &lt;/appender&gt;    &lt;!--        &lt;logger&gt;用来设置某一个包或者具体的某一个类的日志打印级别、        以及指定&lt;appender&gt;。&lt;logger&gt;仅有一个name属性，        一个可选的level和一个可选的addtivity属性。        name:用来指定受此logger约束的某一个包或者具体的某一个类。        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，              还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。              如果未设置此属性，那么当前logger将会继承上级的级别。        addtivity:是否向上级logger传递打印信息。默认是true。        &lt;logger name=&quot;org.springframework.web&quot; level=&quot;info&quot;/&gt;        &lt;logger name=&quot;org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor&quot; level=&quot;INFO&quot;/&gt;    --&gt;    &lt;!--        使用mybatis的时候，sql语句是debug下才会打印，而这里我们只配置了info，所以想要查看sql语句的话，有以下两种操作：        第一种把&lt;root level=&quot;info&quot;&gt;改成&lt;root level=&quot;DEBUG&quot;&gt;这样就会打印sql，不过这样日志那边会出现很多其他消息        第二种就是单独给dao下目录配置debug模式，代码如下，这样配置sql语句会打印，其他还是正常info级别：        【logging.level.org.mybatis=debug logging.level.dao=debug】     --&gt;    &lt;!--        root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性        level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，        不能设置为INHERITED或者同义词NULL。默认是DEBUG        可以包含零个或多个元素，标识这个appender将会添加到这个logger。    --&gt;    &lt;!-- 4. 最终的策略 --&gt;    &lt;!-- 4.1 开发环境:打印控制台--&gt;    &lt;springProfile name=&quot;dev&quot;&gt;        &lt;logger name=&quot;com.sdcm.pmp&quot; level=&quot;debug&quot;/&gt;    &lt;/springProfile&gt;    &lt;root level=&quot;info&quot;&gt;        &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;        &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt;        &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt;        &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt;        &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt;    &lt;/root&gt;    &lt;!-- 4.2 生产环境:输出到文档    &lt;springProfile name=&quot;pro&quot;&gt;        &lt;root level=&quot;info&quot;&gt;            &lt;appender-ref ref=&quot;CONSOLE&quot; /&gt;            &lt;appender-ref ref=&quot;DEBUG_FILE&quot; /&gt;            &lt;appender-ref ref=&quot;INFO_FILE&quot; /&gt;            &lt;appender-ref ref=&quot;ERROR_FILE&quot; /&gt;            &lt;appender-ref ref=&quot;WARN_FILE&quot; /&gt;        &lt;/root&gt;    &lt;/springProfile&gt; --&gt;&lt;/configuration&gt;</code></pre><p>2、将异常信息输出到日志文件</p><pre><code class="java">1、在统一异常处理类上添加注解@Slf4j2、在类里面设置需要加入的内容@ControllerAdvice@Slf4jpublic class ExceptionHandler &#123;    /**     * 指定出现什么异常执行此方法  此方法为全局异常处理     * */    @org.springframework.web.bind.annotation.ExceptionHandler(Exception.class)    @ResponseBody    public Result error(GuliException e)&#123;        //将错误信息写到日志文件里        log.error(e.getMessage());        // log.info(e.getMessage());        e.printStackTrace();        return Result.error().code(e.getCode()).message(e.getMsg());    &#125;&#125;</code></pre><h2 id="扫描java目录下xml文件配置"><a href="#扫描java目录下xml文件配置" class="headerlink" title="扫描java目录下xml文件配置"></a>扫描java目录下xml文件配置</h2><pre><code class="xml">#配置mapper xml文件的路径mybatis-plus.mapper-locations=classpath:com/painter/eduservice/mapper/xml/*.xml &lt;!-- 项目打包时会将java目录中的*.xml文件也进行打包 --&gt;    &lt;build&gt;        &lt;resources&gt;            &lt;resource&gt;                &lt;directory&gt;src/main/java&lt;/directory&gt;                &lt;includes&gt;                    &lt;include&gt;**/*.xml&lt;/include&gt;                &lt;/includes&gt;                &lt;filtering&gt;false&lt;/filtering&gt;            &lt;/resource&gt;        &lt;/resources&gt;    &lt;/build&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> springboot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JWT的使用姿势</title>
      <link href="/2021/02/25/jwt/"/>
      <url>/2021/02/25/jwt/</url>
      
        <content type="html"><![CDATA[<h2 id="JWT简介"><a href="#JWT简介" class="headerlink" title="JWT简介"></a>JWT简介</h2><blockquote><p>JWT(Json Web Token)，基于token的用户认证原理：让用户输入账号和密码，认证通过后获得一个token（令牌），在token有效期里用户可以带着token访问特定资源。<br> 开始token并没有一个统一标准，大家都各自使用自己的方案。后来出现了JWT(Json Web Token)这个标准。<br> JWT本质上是一个对JSON对象加密后的字符串。当服务器认证用户通过后，一个包含用户信息的json对象被加密后返回给用户，</p><p>json 对象：</p></blockquote><pre><code class="json">&#123;    &quot;expire&quot;: &quot;2019-11-29 20:19:00&quot;,    &quot;permissions&quot;: [        &quot;sys:user:list&quot;,        &quot;sys:dept:list&quot;,        &quot;sys:role:list&quot;   ],    &quot;role&quot;: [        &quot;dev&quot;   ],    &quot;userName&quot;: &quot;dev123&quot;&#125;</code></pre><p>之后，用户访问服务器时，都要返回这个json对象。服务器只靠这个对象就可以识别用户身份，不需要再去查数据库。为了防止用户篡改数据，服务器在生成对象时将添加一个签名。<br> 服务器不保存任何会话数据，也就是说，服务器变得<strong>无状态</strong>，从而更容易扩展。</p><h2 id="JWT-怎么用"><a href="#JWT-怎么用" class="headerlink" title="JWT 怎么用"></a>JWT 怎么用</h2><p>以浏览器接收到服务器发过来的jwt后，可以存储在Cookie 或 localStorage 中。之后，浏览器每次与服务器通信时都会带上JWT。可以将JWT放在Cookie中，会自动发送（不跨域），或将JWT放在HTTP请求头的授权字段中。</p><pre><code class="xml">Authorization: Bearer &lt;token&gt;</code></pre><p>也可放在url中，或POST请求的数据体中。</p><h2 id="JWT-结构"><a href="#JWT-结构" class="headerlink" title="JWT 结构"></a>JWT 结构</h2><p>jwt有3个组成部分，每部分通过点号来分割 header.payload.signature</p><ul><li>头部（header) 是一个 JSON 对象</li><li>载荷（payload) 是一个 JSON 对象，用来存放实际需要传递的数据</li><li>签名（signature) 对header和payload使用密钥进行签名，防止数据篡改。</li></ul><h4 id="头部-header"><a href="#头部-header" class="headerlink" title="头部 header"></a>头部 header</h4><p>Jwt的头部是一个JSON,然后使用Base64URL编码，承载两部分信息：</p><ul><li>声明类型typ，表示这个令牌（token）的类型（type），JWT令牌统一写为JWT</li><li>声明加密的算法alg，通常直接使用HMACSHA256，就是HS256了，也可以使用RSA,支持很多算(HS256、HS384、HS512、RS256、RS384、RS512、ES256、ES384、ES512、PS256、PS384)</li></ul><pre><code class="json">&#123;  &quot;alg&quot;: &quot;HS256&quot;,  &quot;typ&quot;: &quot;JWT&quot;&#125;</code></pre><ul><li>Base64URL 编码后(Base64编码后可能出现字符+和/，在URL中不能直接作为参数，Base64URL就是把字符+和/分别变成-和 _。JWT有可能放在url中，所以要用Base64URL编码。）</li></ul><pre><code class="tex">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</code></pre><h4 id="载荷-payload"><a href="#载荷-payload" class="headerlink" title="载荷 payload"></a>载荷 payload</h4><p>payload也是一个JSON字符串，是承载消息具体内容的地方，也需要使用Base64URL编码，就是存储我们要保存到客户端的信息，一般都是包含用户的基本信息，权限信息，时间戳等信息。<br> JWT指定了一些官方字段（claims）备用:</p><ul><li>iss: 签发人</li><li>exp: 过期时间</li><li>iat: 签发时间</li><li>nbf: 生效时间</li><li>jti: 编号</li><li>sub: 主题</li><li>aud: 受众</li></ul><p>除了官方字段，在这个部分还可以添加私有字段，例如：</p><pre><code class="json">&#123;  &quot;sub&quot;: &quot;1dfaafa7-fddf-46f2-b3d8-11bfe9ac7230&quot;,  &quot;jwt-roles-key_&quot;: [    &quot;普通用户角色&quot; ],  &quot;iss&quot;: &quot;yingxue.com&quot;,  &quot;jwt-permissions-key&quot;: [    &quot;sys:user:list&quot;,    &quot;sys:dept:list&quot;,    &quot;sys:role:list&quot;,    &quot;sys:permission:list&quot;,    &quot;sys:log:list&quot; ],  &quot;jwt-user-name-key&quot;: &quot;dev123&quot;,  &quot;exp&quot;: 1575005723,  &quot;iat&quot;: 1574998523&#125;</code></pre><p>Base64URL编码的后：</p><pre><code class="undefined">eyJzdWIiOiIxZGZhYWZhNy1mZGRmLTQ2ZjItYjNkOC0xMWJmZTlhYzcyMzAiLCJqd3Qtcm9sZXMta2V5XyI6WyLmma7pgJrnlKjmiLfop5LoibIiXSwiaXNzIjoieWluZ3h1ZS5jb20iLCJqd3QtcGVybWlzc2lvbnMta2V5IjpbInN5czp1c2VyOmxpc3QiLCJzeXM6ZGVwdDpsaXN0Iiwic3lzOnJvbGU6bGlzdCIsInN5czpwZXJtaXNzaW9uOmxpc3QiLCJzeXM6bG9nOmxpc3QiXSwiand0LXVzZXItbmFtZS1rZXkiOiJkZXYxMjMiLCJleHAiOjE1NzUwMDU3MjMsImlhdCI6MTU3NDk5ODUyM30</code></pre><h4 id="签名-Signature"><a href="#签名-Signature" class="headerlink" title="签名 Signature"></a>签名 Signature</h4><p>Signature部分是对前两部分的防篡改签名。将Header和Payload用Base64URL编码后，再用点(.)连接起来。然后使用签名算法和密钥对这个字符串进行签名：</p><pre><code class="bash">signature = HMACSHA256(header + &quot;.&quot; + payload, secret);</code></pre><p>首先，需要指定一个密码（secret）。该密码保存在服务器中，并且不能向用户公开。然后，使用标头中指定的签名算法根据以下公式生成签名。signature = HMACSHA256(header + “.” + payload, secret);  在计算出签名哈希后，JWT头，有效载荷和签名哈希的三个部分组合成一个字符串，每个部分用”.”分隔，就构成整个JWT对象。  以上三部分都是在服务器定义，当用户登陆成功后，根据用户信息，按照jwt规则生成token返回给客户端。<br> 签名信息：</p><pre><code class="undefined">qYWHdAbYZlP6akHTrDm-MkIWia8mPW-TO75eu8r0-Vk</code></pre><p><strong>组合在一起</strong><br> 3部分组合在一起，构成了完整的jwt：</p><pre><code class="css">eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiIxZGZhYWZhNy1mZGRmLTQ2ZjItYjNkOC0xMWJmZTlhYzcyMzAiLCJqd3Qtcm9sZXMta2V5XyI6WyLmma7pgJrnlKjmiLfop5LoibIiXSwiaXNzIjoieWluZ3h1ZS5jb20iLCJqd3QtcGVybWlzc2lvbnMta2V5IjpbInN5czp1c2VyOmxpc3QiLCJzeXM6ZGVwdDpsaXN0Iiwic3lzOnJvbGU6bGlzdCIsInN5czpwZXJtaXNzaW9uOmxpc3QiLCJzeXM6bG9nOmxpc3QiXSwiand0LXVzZXItbmFtZS1rZXkiOiJkZXYxMjMiLCJleHAiOjE1NzUwMDU3MjMsImlhdCI6MTU3NDk5ODUyM30.qYWHdAbYZlP6akHTrDm�MkIWia8mPW-TO75eu8r0-Vk</code></pre><h2 id="使用要点"><a href="#使用要点" class="headerlink" title="使用要点"></a>使用要点</h2><ul><li>JWT默认是不加密的，但也可以加密，不加密时不宜在jwt中存放敏感信息</li><li>不要泄露签名密钥(secret)</li><li>jwt签发后无法撤回，有效期不宜太长</li><li>JWT 泄露会被人冒用身份，为防止盗用，JWT应尽量使用 https 协议传输</li></ul><h2 id="JWT-使用姿势"><a href="#JWT-使用姿势" class="headerlink" title="JWT 使用姿势"></a>JWT 使用姿势</h2><blockquote><p>大家有没有发现，现在的网站通常第一次登录验证通过后，在后续的操作都不需要用户名密码，那后端怎么确定这次访问的用户是合法用户呢？</p><p>其实当第一次登录后，服务器生成一个Token 便将此 Token 返回给客户端，以后客户端只需带上这个 Token 前来请求数据即可，无需再次带上用户名和密码。<br> 那么我们后端该怎么实现上述的业务呢？</p></blockquote><h3 id="1-有状态-token"><a href="#1-有状态-token" class="headerlink" title="1. 有状态 token"></a>1. 有状态 token</h3><p>所谓的有状态就是 把生成的 token 保存在服务器端。<br> 实现步骤：</p><ul><li>当用户登录进来后端生成一个随机数 token(我通常用uuid) 然后把 token 做key userId 做为 value 存入 reids 并且设置失效时间。</li><li>编写一个拦截器，设置要拦截的 api(即是受保护的api)和开放的api(用户登录、注册等接口)。 去 header 或者 cookie 拿 token，如果 token 为空或者 token 已经失效(拿 token 去 redis 检测是否失效)则告知客户端<br> 引导到登录页面。</li></ul><h3 id="2-无状态-token"><a href="#2-无状态-token" class="headerlink" title="2. 无状态 token"></a>2. 无状态 token</h3><p>所谓的无状态 token 就是服务器不保存 token 信息，当用户登陆成功后，返回 token 给客户端，客户端保存起来每次请求都会带过来。其实我们用 token 的作用就是拿到用户ID 只有拿到了 ID 才能区别是哪个用户访问，那么 JWT 刚刚好满足要求，JWT是签发给客户端而且 用户 ID 直接存在 JWT 里面，客户端每次请求过来的时候我们直接解析 JWT 拿到用户 ID，这样就达到了识别用户的效果。<br> 但是在使用 JWT 的时候都会遇到下列的烦恼？<br> <strong>无法作废已颁布的令牌。</strong>所有的认证信息都在 JWT 中，由于在服务端没有状态，即使你知道了某个 JWT 被盗取了，你也没有办法将其作废。在 JWT 过期之前（你绝对应该设置过期时间），你无能为力。<br> <strong>不易应对数据过期。</strong>与上一条类似，JWT 有点类似缓存，由于无法作废已颁布的令牌，在其过期前，你只能忍受“过期”的数据。</p><h3 id="我的使用姿势："><a href="#我的使用姿势：" class="headerlink" title="我的使用姿势："></a>我的使用姿势：</h3><ul><li>用户登录进来，会生产两个 token (一个过期时间比较短的 access_token ,一个过期时间比较长的 refresh_token )，创建一个拦截器拦截用户请求。</li><li>当要更新jwt携带的数据时候，直接用refresh_token 刷新 access_token,而老的access_token 用redis 标记起来并设置过期时间(过期时间为该令牌剩余的过期时间)</li><li>当要作废令牌的时候，直接把这个令牌在redis 标记起来，并且设置过期时间(过期时间为该令牌剩余的过期时间)。</li></ul><h2 id="JWT-工具类封装"><a href="#JWT-工具类封装" class="headerlink" title="JWT 工具类封装"></a>JWT 工具类封装</h2><p>我们在日常开发中会多次去验证客户端传入的 token，所以我们要把验证的方法抽出来，封装成一个工具类，每次直接用工具类调用就可以了</p><h5 id="首先创建一个-JwtTokenUtil"><a href="#首先创建一个-JwtTokenUtil" class="headerlink" title="首先创建一个 JwtTokenUtil"></a>首先创建一个 JwtTokenUtil</h5><pre><code class="java">@Slf4jpublic class JwtTokenUtil &#123;&#125;</code></pre><h5 id="application-yml-加入-JWT-相关配置参数"><a href="#application-yml-加入-JWT-相关配置参数" class="headerlink" title="application.yml 加入 JWT 相关配置参数"></a>application.yml 加入 JWT 相关配置参数</h5><pre><code class="yml">#JWT 密钥jwt: secretKey: 78944878877848fg) accessTokenExpireTime: PT2H refreshTokenExpireTime: PT8H refreshTokenExpireAppTime: P30D issuer: ggk.com</code></pre><h5 id="创建配置读取类"><a href="#创建配置读取类" class="headerlink" title="创建配置读取类"></a>创建配置读取类</h5><pre><code class="java">@Configuration@ConfigurationProperties(prefix = &quot;jwt&quot;)@Datapublic class TokenSettings &#123;    private String secretKey;    private Duration accessTokenExpireTime;    private Duration refreshTokenExpireTime;    private Duration refreshTokenExpireAppTime;    private String  issuer; &#125;</code></pre><h5 id="创建初始化配置代理类"><a href="#创建初始化配置代理类" class="headerlink" title="创建初始化配置代理类"></a>创建初始化配置代理类</h5><pre><code class="java">@Componentpublic class InitializerUtil &#123;    private TokenSettings tokenSettings;    public InitializerUtil(TokenSettings tokenSettings) &#123;        JwtTokenUtil.setTokenSettings(tokenSettings);   &#125;&#125;</code></pre><h5 id="修改JwtTokenUtil加入签发-token-方法"><a href="#修改JwtTokenUtil加入签发-token-方法" class="headerlink" title="修改JwtTokenUtil加入签发 token 方法"></a>修改JwtTokenUtil加入签发 token 方法</h5><pre><code class="java">@Slf4jpublic class JwtTokenUtil &#123;    private static String secretKey;    private static Duration accessTokenExpireTime;    private static Duration refreshTokenExpireTime;    private static Duration refreshTokenExpireAppTime;    private static String issuer;    public static void setTokenSettings(TokenSettings tokenSettings)&#123;        secretKey=tokenSettings.getSecretKey();        accessTokenExpireTime=tokenSettings.getAccessTokenExpireTime();        refreshTokenExpireTime=tokenSettings.getRefreshTokenExpireTime();        refreshTokenExpireAppTime=tokenSettings.getRefreshTokenExpireAppTime();        issuer=tokenSettings.getIssuer();    &#125;    /**     * 签发/生成token     * issuer 签发人     * subject 代表这个JWT的主体，即他的所有人，一般是用户ID     * claims 储存在jwt里的信息(键值对)，一般是放些用户的权限/角色信息     * ttlMillis 有效时间(毫秒)     * secret 密钥     */    public static String generateToken(String issuer, String subject, Map&lt;String, Object&gt; claims, long ttlMillis, String secret) &#123;        //加密方式        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;        //当前时间戳，并转为日期        long nowMillis = System.currentTimeMillis();        Date now = new Date(nowMillis);        //String printBase64Binary(byte[])就是将字节数组做base64编码，byte[] parseBase64Binary(String) 就是将Base64编码后的String还原成字节数组。        byte[] signingKey = DatatypeConverter.parseBase64Binary(secret);        //这里其实就是new一个JwtBuilder，设置jwt的body        JwtBuilder builder = Jwts.builder();        //如果claims不为空，就加到JWT的载荷里面去        if(null!=claims)&#123;            builder.setClaims(claims);        &#125;        if (!StringUtils.isEmpty(subject)) &#123;            builder.setSubject(subject);        &#125;        if (!StringUtils.isEmpty(issuer)) &#123;            builder.setIssuer(issuer);        &#125;        //签发时间        builder.setIssuedAt(now);        if (ttlMillis &gt;= 0) &#123;            long expMillis = nowMillis + ttlMillis;            //过期时间            Date exp = new Date(expMillis);            builder.setExpiration(exp);        &#125;        builder.signWith(signatureAlgorithm, signingKey);        return builder.compact();    &#125;    // 刷新token和业务token 只是过期时间不一样    /**     * 生成 access_token   正常请求资源时携带的凭证     */    public static String getAccessToken(String subject, Map&lt;String,Object&gt; claims)&#123;        return generateToken(issuer,subject,claims,accessTokenExpireTime.toMillis(),secretKey);    &#125;    /**     * 生产 PC refresh_token     */    public static String getRefreshToken(String subject,Map&lt;String,Object&gt; claims)&#123;        return generateToken(issuer,subject,claims,refreshTokenExpireTime.toMillis(),secretKey);    &#125;    /**     * 生产 App端 refresh_token     */    public static String getRefreshAppToken(String subject,Map&lt;String,Object&gt; claims)&#123;        return generateToken(issuer,subject,claims,refreshTokenExpireAppTime.toMillis(),secretKey);    &#125;    /**     * 解析令牌 获取数据声明     * 拿到用户及用户的角色、权限等信息     */    public static Claims getClaimsFromToken(String token) &#123;        Claims claims;        try &#123;            //用密钥(必字节数组)解析jwt，获取body（有效载荷）            claims = Jwts.parser().setSigningKey(DatatypeConverter.parseBase64Binary(secretKey)).parseClaimsJws(token).getBody();        &#125; catch (Exception e) &#123;            //解析不了，这个token就是无效的            claims = null;        &#125;        return claims;    &#125;    /**     * 获取用户id     */    public static String getUserId(String token)&#123;        String userId=null;        try &#123;            Claims claims = getClaimsFromToken(token);            userId = claims.getSubject();        &#125; catch (Exception e) &#123;            log.error(&quot;error=&#123;&#125;&quot;,e);        &#125;        return userId;    &#125;    /**     * 获取用户名     * 用于首页展示     */    public static String getUserName(String token)&#123;        String username=null;        try &#123;            //解析token获取claims            Claims claims = getClaimsFromToken(token);            //claims中的key当作自定义的常量            username = (String) claims .get(Constant.JWT_USER_NAME);        &#125; catch (Exception e) &#123;            log.error(&quot;error=&#123;&#125;&quot;,e);        &#125;        return username;    &#125;    /**     * 验证token 是否过期     */    public static Boolean isTokenExpired(String token) &#123;        try &#123;            //首先解析，如果能解析成功，证明我服务器签发的            Claims claims = getClaimsFromToken(token);            Date expiration = claims.getExpiration();            //过期时间和当前时间比较，如果过期时间在当前时间之前，返回true，表示已过期；否则返回false，没过期            return expiration.before(new Date());        &#125; catch (Exception e) &#123;            log.error(&quot;error=&#123;&#125;&quot;,e);            //解析失败，抛出异常，返回true，表示已过期            return true;        &#125;    &#125;    /**     * 校验令牌     */    public static Boolean validateToken(String token) &#123;        Claims claimsFromToken = getClaimsFromToken(token);        return (null!=claimsFromToken &amp;&amp; !isTokenExpired(token));    &#125;    /**     * 刷新token     * 如果是过期刷新，claims/载荷 不变；     * 如果主动刷新，claims/载荷 改变【一般是权限/角色改变的时候去主动刷新】     */    public static String refreshToken(String refreshToken,Map&lt;String, Object&gt; claims) &#123;        String refreshedToken;        try &#123;            Claims parserclaims = getClaimsFromToken(refreshToken);            /**             * 如果传入的claims为空，说明是过期刷新，原先的用户信息不变，claims引用上个token里的内容             */            if(null==claims)&#123;                claims=parserclaims;            &#125;            /**             * 不为空，根据传入的claims【用户信息】，生成新的Token             */            refreshedToken = generateToken(parserclaims.getIssuer(),parserclaims.getSubject(),claims,accessTokenExpireTime.toMillis(),secretKey);        &#125; catch (Exception e) &#123;            refreshedToken = null;            log.error(&quot;error=&#123;&#125;&quot;,e);        &#125;        return refreshedToken;    &#125;    /**     * 获取token的剩余过期时间     */    public static long getRemainingTime(String token)&#123;        long result=0;        try &#123;            long nowMillis = System.currentTimeMillis();            result= getClaimsFromToken(token).getExpiration().getTime()-nowMillis;        &#125; catch (Exception e) &#123;            log.error(&quot;error=&#123;&#125;&quot;,e);        &#125;        return result;    &#125;&#125;</code></pre><h2 id="JwtTokenUtil"><a href="#JwtTokenUtil" class="headerlink" title="JwtTokenUtil"></a>JwtTokenUtil</h2><pre><code class="java">import io.jsonwebtoken.Claims;import io.jsonwebtoken.Jwts;import io.jsonwebtoken.SignatureAlgorithm;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.stereotype.Component;import java.util.Date;import java.util.HashMap;import java.util.Map;/** * JwtToken生成的工具类 * JWT token的格式：header.payload.signature * header的格式（算法、token的类型）： * &#123;&quot;alg&quot;: &quot;HS512&quot;,&quot;type&quot;: &quot;JWT&quot;&#125; * payload的格式（用户名、创建时间、生成时间）： * &#123;&quot;sub&quot;:&quot;wang&quot;,&quot;created&quot;:1489079981393,&quot;exp&quot;:1489684781&#125; * signature的生成算法： * HMACSHA512(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload),secret) */@Componentpublic class JwtTokenUtil &#123;    private static final Logger LOGGER = LoggerFactory.getLogger(JwtTokenUtil.class);    private static final String CLAIM_KEY_USERNAME = &quot;sub&quot;;    private static final String CLAIM_KEY_CREATED = &quot;created&quot;;        @Value(&quot;$&#123;jwt.secret&#125;&quot;)    private String secret;    @Value(&quot;$&#123;jwt.expiration&#125;&quot;)    private Long expiration;    /**     * 根据负责生成JWT的token     */    private String generateToken(Map&lt;String, Object&gt; claims) &#123;        return Jwts.builder()                .setClaims(claims)                .setExpiration(generateExpirationDate())                .signWith(SignatureAlgorithm.HS512, secret)                .compact();    &#125;    /**     * 从token中获取JWT中的负载     */    private Claims getClaimsFromToken(String token) &#123;        Claims claims = null;        try &#123;            claims = Jwts.parser()                    .setSigningKey(secret)                    .parseClaimsJws(token)                    .getBody();        &#125; catch (Exception e) &#123;            LOGGER.info(&quot;JWT格式验证失败:&#123;&#125;&quot;,token);        &#125;        return claims;    &#125;    /**     * 生成token的过期时间     */    private Date generateExpirationDate() &#123;        return new Date(System.currentTimeMillis() + expiration * 1000);    &#125;    /**     * 从token中获取登录用户名     */    public String getUserNameFromToken(String token) &#123;        String username;        try &#123;            Claims claims = getClaimsFromToken(token);            username =  claims.getSubject()        &#125; catch (Exception e) &#123;            username = null;        &#125;        return username;    &#125;    /**     * 验证token是否还有效     * @param token       客户端传入的token     * @param userDetails 从数据库中查询出来的用户信息     */    public boolean validateToken(String token, UserDetails userDetails) &#123;        String username = getUserNameFromToken(token);        return username.equals(userDetails.getUsername()) &amp;&amp; !isTokenExpired(token);    &#125;    /**     * 判断token是否已经失效     */    private boolean isTokenExpired(String token) &#123;        Date expiredDate = getExpiredDateFromToken(token);        return expiredDate.before(new Date());    &#125;    /**     * 从token中获取过期时间     */    private Date getExpiredDateFromToken(String token) &#123;        Claims claims = getClaimsFromToken(token);        return claims.getExpiration();    &#125;    /**     * 根据用户信息生成token     */    public String generateToken(UserDetails userDetails) &#123;        Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();        claims.put(CLAIM_KEY_USERNAME, userDetails.getUsername());        claims.put(CLAIM_KEY_CREATED, new Date());        return generateToken(claims);    &#125;    /**     * 判断token是否可以被刷新     */    public boolean canRefresh(String token) &#123;        return !isTokenExpired(token);    &#125;    /**     * 刷新token     */    public String refreshToken(String token) &#123;        Claims claims = getClaimsFromToken(token);        claims.put(CLAIM_KEY_CREATED, new Date());        return generateToken(claims);    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> Security </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jwt </tag>
            
            <tag> token </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis Plus</title>
      <link href="/2020/06/27/mybatisplus/"/>
      <url>/2020/06/27/mybatisplus/</url>
      
        <content type="html"><![CDATA[<h1 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h1><p><strong>简介</strong></p><p>官网：<a href="http://mp.baomidou.com/">http://mp.baomidou.com/</a></p><p>参考教程：<a href="http://mp.baomidou.com/guide/">http://mp.baomidou.com/guide/</a></p><p><a href="https://github.com/baomidou/mybatis-plus">MyBatis-Plus</a>（简称  MP）是一个 <a href="http://www.mybatis.org/mybatis-3/">MyBatis</a> 的增强工具，在 MyBatis  的基础上只做增强不做改变，为简化开发、提高效率而生。</p><p><strong>特性</strong></p><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的  CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD  操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持  Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持多种数据库</strong>：支持  MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer2005、SQLServer  等多种数据库</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID  生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 XML  热加载</strong>：Mapper 对应的 XML 支持热加载，对于简单的 CRUD 操作，甚至可以无 XML  启动</li><li><strong>支持  ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD  操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once,  use anywhere ）</li><li><strong>支持关键词自动转义</strong>：支持数据库关键词（order、key……）自动转义，还可自定义关键词</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成  Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis  物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>内置性能分析插件</strong>：可输出 Sql  语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update  操作智能分析阻断，也可自定义拦截规则，预防误操作</li><li><strong>内置 Sql  注入剥离器</strong>：支持 Sql 注入剥离，有效预防 Sql 注入攻击</li></ul><p>快速开始参考：<a href="http://mp.baomidou.com/guide/quick-start.html">http://mp.baomidou.com/guide/quick-start.html</a></p><p>测试项目： mybatis_plus</p><p>数据库：mybatis_plus</p><hr><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="一、创建并初始化数据库"><a href="#一、创建并初始化数据库" class="headerlink" title="一、创建并初始化数据库"></a>一、创建并初始化数据库</h3><h4 id="1、创建数据库："><a href="#1、创建数据库：" class="headerlink" title="1、创建数据库："></a>1、创建数据库：</h4><p>mybatis_plus</p><h4 id="2、创建-User-表"><a href="#2、创建-User-表" class="headerlink" title="2、创建 User 表"></a>2、创建 <code>User</code> 表</h4><p>其表结构如下：</p><table><thead><tr><th>id</th><th>name</th><th>age</th><th>email</th></tr></thead><tbody><tr><td>1</td><td>Jone</td><td>18</td><td><a href="mailto:&#116;&#101;&#x73;&#x74;&#x31;&#64;&#98;&#97;&#111;&#x6d;&#x69;&#100;&#111;&#x75;&#x2e;&#99;&#x6f;&#109;">&#116;&#101;&#x73;&#x74;&#x31;&#64;&#98;&#97;&#111;&#x6d;&#x69;&#100;&#111;&#x75;&#x2e;&#99;&#x6f;&#109;</a></td></tr><tr><td>2</td><td>Jack</td><td>20</td><td><a href="mailto:&#116;&#101;&#x73;&#x74;&#50;&#64;&#x62;&#x61;&#x6f;&#109;&#x69;&#x64;&#111;&#117;&#46;&#x63;&#111;&#x6d;">&#116;&#101;&#x73;&#x74;&#50;&#64;&#x62;&#x61;&#x6f;&#109;&#x69;&#x64;&#111;&#117;&#46;&#x63;&#111;&#x6d;</a></td></tr><tr><td>3</td><td>Tom</td><td>28</td><td><a href="mailto:&#x74;&#x65;&#115;&#x74;&#x33;&#64;&#98;&#x61;&#111;&#109;&#105;&#100;&#x6f;&#x75;&#x2e;&#99;&#111;&#x6d;">&#x74;&#x65;&#115;&#x74;&#x33;&#64;&#98;&#x61;&#111;&#109;&#105;&#100;&#x6f;&#x75;&#x2e;&#99;&#111;&#x6d;</a></td></tr><tr><td>4</td><td>Sandy</td><td>21</td><td><a href="mailto:&#x74;&#101;&#115;&#x74;&#52;&#64;&#98;&#97;&#x6f;&#x6d;&#x69;&#100;&#111;&#x75;&#46;&#x63;&#x6f;&#109;">&#x74;&#101;&#115;&#x74;&#52;&#64;&#98;&#97;&#x6f;&#x6d;&#x69;&#100;&#111;&#x75;&#46;&#x63;&#x6f;&#109;</a></td></tr><tr><td>5</td><td>Billie</td><td>24</td><td><a href="mailto:&#x74;&#101;&#x73;&#x74;&#53;&#x40;&#98;&#x61;&#111;&#x6d;&#x69;&#100;&#x6f;&#x75;&#x2e;&#x63;&#111;&#x6d;">&#x74;&#101;&#x73;&#x74;&#53;&#x40;&#98;&#x61;&#111;&#x6d;&#x69;&#100;&#x6f;&#x75;&#x2e;&#x63;&#111;&#x6d;</a></td></tr></tbody></table><p>其对应的数据库 Schema 脚本如下：</p><pre><code class="sql">DROP TABLE IF EXISTS user;CREATE TABLE user(      id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;,    name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;姓名&#39;,    age INT(11) NULL DEFAULT NULL COMMENT &#39;年龄&#39;,    email VARCHAR(50) NULL DEFAULT NULL COMMENT &#39;邮箱&#39;,    PRIMARY KEY (id)     );       </code></pre><p>其对应的数据库 Data 脚本如下：</p><pre><code class="sql">DELETE FROM user;INSERT INTO user (id, name, age, email) VALUES(1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;),(2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;),(3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;),(4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;),(5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;);</code></pre><h3 id="二、初始化工程"><a href="#二、初始化工程" class="headerlink" title="二、初始化工程"></a>二、初始化工程</h3><p>使用 Spring Initializr 快速初始化一个 Spring  Boot 工程</p><p>Group：com.atguigu</p><p>Artifact：mybatis-plus</p><p>版本：2.2.1.RELEASE</p><h3 id="三、添加依赖"><a href="#三、添加依赖" class="headerlink" title="三、添加依赖"></a>三、添加依赖</h3><pre><code class="xml">   &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!--mybatisplus--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;            &lt;version&gt;3.3.0&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;            &lt;artifactId&gt;druid&lt;/artifactId&gt;            &lt;version&gt;1.1.18&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;</code></pre><p><strong>注意：</strong>引入 <code>MyBatis-Plus</code> 之后请不要再次引入 <code>MyBatis</code> 以及 <code>MyBatis-Spring</code>，以避免因版本差异导致的问题。</p><h3 id="四、配置文件"><a href="#四、配置文件" class="headerlink" title="四、配置文件"></a>四、配置文件</h3><p>在 `application.yml 配置文件中添加 MySQL  数据库的相关配置：</p><pre><code class="yml">spring:  datasource:    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://localhost:3306/testdate?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT&amp;zeroDateTimeBehavior=CONVERT_TO_NULL    username: root    password: password  profiles:    active: dev  #环境设置为开发环境mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl  #mybatisplus的sql执行语句  global-config:   #设置mybatisplus做逻辑删除时 1为逻辑删除后的值  0为默认值    db-config:      logic-delete-value: 1      logic-not-delete-value: 0</code></pre><h3 id="五、编写代码"><a href="#五、编写代码" class="headerlink" title="五、编写代码"></a>五、编写代码</h3><p><strong>1、主类</strong></p><p>在 Spring Boot 启动类中添加 <code>@MapperScan</code> 注解，扫描 Mapper 文件夹</p><p><strong>注意：</strong>扫描的包名根据实际情况修改</p><pre><code class="java">@SpringBootApplication@MapperScan(&quot;com.atguigu.mybatisplus.mapper&quot;)//mapper接口包路径public class MybatisPlusApplication &#123;   ...... &#125;</code></pre><p><strong>2、实体</strong></p><p>创建包  entity 编写实体类 <code>User.java</code>（此处使用了 <a href="https://www.projectlombok.org/">Lombok</a> 简化代码）</p><pre><code class="java">@Datapublic class User &#123;       private Long id;    private String name;    private Integer age;    private String email;&#125;</code></pre><p><strong>3、mapper</strong></p><p>创建包 mapper 编写Mapper 接口： <code>UserMapper.java</code></p><pre><code class="java">public interface UserMapper extends BaseMapper&lt;User&gt; &#123; &#125;</code></pre><h3 id="六、开始使用"><a href="#六、开始使用" class="headerlink" title="六、开始使用"></a>六、开始使用</h3><p>添加测试类，进行功能测试：</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTestpublic class MybatisPlusApplicationTests &#123;    @Autowired    private UserMapper userMapper;    @Test    public void testSelectList() &#123;    System.out.println((&quot;----- selectAll method test ------&quot;));    //UserMapper 中的 selectList() 方法的参数为 MP 内置的条件封装器 Wrapper    //所以不填写就是无任何条件    List&lt;User&gt; users = userMapper.selectList(null);    users.forEach(System.out::println);     &#125;    &#125;</code></pre><p><strong>注意：</strong></p><p>IDEA在 userMapper  处报错，因为找不到注入的对象，因为类是动态创建的，但是程序可以正确的执行。</p><p>为了避免报错，可以在 dao 层 的接口上添加 @Repository 注</p><p>控制台输出：</p><pre><code class="java">User(id=1, name=Jone, age=18, email=test1@baomidou.com)User(id=2, name=Jack, age=20, email=test2@baomidou.com)User(id=3, name=Tom, age=28, email=test3@baomidou.com)User(id=4, name=Sandy, age=21, email=test4@baomidou.com)User(id=5, name=Billie, age=24, email=test5@baomidou.com)</code></pre><p>通过以上几个简单的步骤，我们就实现了 User 表的 CRUD 功能，甚至连 XML 文件都不用编写！</p><h3 id="七、配置日志"><a href="#七、配置日志" class="headerlink" title="七、配置日志"></a>七、配置日志</h3><p>查看sql输出日志在yml中配置，上面已配置</p><pre><code class="properties">#mybatis日志mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl</code></pre><h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a><strong>insert</strong></h3><h4 id="1、插入操作"><a href="#1、插入操作" class="headerlink" title="1、插入操作"></a><strong>1、插入操作</strong></h4><pre><code class="java"> @Test    void addUsers()&#123;        Usertest usertest = new Usertest();        usertest.setName(&quot;Devi&quot;);        usertest.setAge(30);        usertest.setEmail(&quot;658486@qq.com&quot;);        int insert = userMapper.insert(usertest);        System.out.println(&quot;------&quot;+insert);    &#125;</code></pre><p><strong>注意：</strong>数据库插入id值默认为：全局唯一id</p><h4 id="2、主键策略"><a href="#2、主键策略" class="headerlink" title="2、主键策略"></a>2、主键策略</h4><p><strong>（1）ID_WORKER</strong></p><p>MyBatis-Plus默认的主键策略是：ID_WORKER  <em>全局唯一ID</em></p><p><strong>参考资料：分布式系统唯一ID生成方案汇总：</strong><a href="https://www.cnblogs.com/haoxinyue/p/5208136.html">https://www.cnblogs.com/haoxinyue/p/5208136.html</a></p><p><strong>（2）自增策略</strong></p><ul><li><p>要想主键自增需要配置如下</p><p>主键</p><p>策略</p><ul><li>需要在创建数据表的时候设置主键自增</li><li>实体字段中配置 @TableId(type =  IdType.AUTO)</li></ul></li></ul><pre><code>@TableId(type = IdType.AUTO)private Long id;</code></pre><p>要想影响所有实体的配置，可以设置全局主键配置</p><pre><code>#全局设置主键生成策略mybatis-plus.global-config.db-config.id-type=auto</code></pre><p>其它主键策略：分析 IdType 源码可知</p><pre><code class="java">@Getterpublic enum IdType &#123;  /** * 数据库ID自增*/ AUTO(0),/** * 该类型为未设置主键类*/ NONE(1),/*** 用户输入ID* 该类型可以通过自己注册自动填充插件进行填充*/ INPUT(2),    /* 以下3种类型、只有当插入对象ID 为空，才自动填充。 *//*** 全局唯一ID (idWorker)*/ID_WORKER(3), /*** 全局唯一ID (UUID)*/UUID(4),/** * 字符串全局唯一ID (idWorker 的字符串表示) */    ID_WORKER_STR(5); private int key; IdType(int key) &#123;      this.key = key; &#125;&#125;</code></pre><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><h4 id="1、根据Id更新操作"><a href="#1、根据Id更新操作" class="headerlink" title="1、根据Id更新操作"></a><strong>1、根据Id更新操作</strong></h4><p><strong>注意：</strong>update时生成的sql自动是动态sql：UPDATE user SET age=? WHERE  id=? </p><pre><code class="java">    @Test    void updateUsertest()&#123;        Usertest usertest = new Usertest();        usertest.setId(7);        usertest.setName(&quot;王多鱼&quot;);        int i = userMapper.updateById(usertest);        System.out.println(&quot;修改&quot;+i);    &#125;</code></pre><h4 id="2、自动填充"><a href="#2、自动填充" class="headerlink" title="2、自动填充"></a>2、自动填充</h4><p>项目中经常会遇到一些数据，每次都使用相同的方式填充，例如记录的创建时间，更新时间等。</p><p>我们可以使用MyBatis Plus的自动填充功能，完成这些字段的赋值工作：</p><p><strong>（1）数据库表中添加自动填充字段</strong></p><p>在User表中添加datetime类型的新的字段 create_time、update_time</p><p><strong>（2）实体上添加注解</strong></p><pre><code class="java">@Datapublic class User &#123;      ......    @TableField(fill = FieldFill.INSERT)    private Date createTime;    //@TableField(fill = FieldFill.UPDATE)    @TableField(fill = FieldFill.INSERT_UPDATE)    private Date updateTime;&#125;</code></pre><p><strong>（3）实现元对象处理器接口</strong></p><p><strong>注意：不要忘记添加 @Component 注解</strong></p><pre><code class="java">package com.atguigu.mybatisplus.handler;import com.baomidou.mybatisplus.core.handlers.MetaObjectHandler ;import org.apache.ibatis.reflection.MetaObject;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class MyMetaObjectHandler implements MetaObjectHandler &#123;    private static final Logger LOGGER = LoggerFactory.getLogger(MyMetaObjectHandler.class);    @Override    public void insertFill(MetaObject metaObject) &#123;        LOGGER.info(&quot;start insert fill ....&quot;);        this.setFieldValByName(&quot;createTime&quot;, new Date(), metaObject);        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);    &#125;    @Override    public void updateFill(MetaObject metaObject) &#123;        LOGGER.info(&quot;start update fill ....&quot;);        this.setFieldValByName(&quot;updateTime&quot;, new Date(), metaObject);     &#125;&#125;</code></pre><p><strong>（4）测试</strong></p><h4 id="3、乐观锁"><a href="#3、乐观锁" class="headerlink" title="3、乐观锁"></a>3、乐观锁</h4><p><strong>主要适用场景：</strong>当要更新一条记录的时候，希望这条记录没有被别人更新，也就是说实现线程安全的数据更新</p><p><strong>乐观锁实现方式：</strong></p><ul><li>取出记录时，获取当前version</li><li>更新时，带上这个version</li><li>执行更新时， set  version = newVersion where version = oldVersion</li><li>如果version不对，就更新失败</li></ul><p><strong>（1）数据库中添加version字段</strong></p><pre><code class="sql">ALTER TABLE `user` ADD COLUMN `version` INT</code></pre><p><em><strong>*（2）实体类添加version字段*</strong></em></p><p>并添加 @Version 注解</p><pre><code class="java">@Version@TableField(fill = FieldFill.INSERT)private Integer version;</code></pre><p><strong>（3）元对象处理器接口添加version的insert默认值</strong></p><pre><code class="java">@Overridepublic void insertFill(MetaObject metaObject) &#123;    ......     this.setFieldValByName(&quot;version&quot;, 1, metaObject);&#125;</code></pre><p><strong>特别说明:</strong></p><p>支持的数据类型只有  int,Integer,long,Long,Date,Timestamp,LocalDateTime 整数类型下 <code>newVersion = oldVersion + 1</code> <code>newVersion</code> 会回写到 <code>entity</code> 中 仅支持 <code>updateById(id)</code> 与 <code>update(entity, wrapper)</code> 方法 在 <code>update(entity, wrapper)</code> 方法下, <code>wrapper</code> 不能复用!!!</p><p><strong>（4）*<em>在 MybatisPlusConfig 中注册  Bean*</em></strong></p><p>创建配置类</p><pre><code class="java">package com.mybatisplus.config;import com.baomidou.mybatisplus.extension.plugins.OptimisticLockerInterceptor;import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;import org.mybatis.spring.annotation.MapperScan;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * 此类为统一配置类(配置mapper加载路径 ，mybatisplus插件配置) */@Configuration@MapperScan(&quot;com.mybatisplus.mapper&quot;)//mapper接口包路径public class GeneralConfig &#123;    /**     * mybatisplus乐观锁配置     */    @Bean    public OptimisticLockerInterceptor optimisticLockerInterceptor()&#123;        return new OptimisticLockerInterceptor();    &#125;    /**     * 分页插件配置     * */    @Bean    public PaginationInterceptor paginationInterceptor() &#123;        return new PaginationInterceptor();    &#125;    /**     * SQL性能分析插件     * 仅在开发环境 测试环境使用     * */    @Bean    @Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)//设置dev test环境开启   public PerformanceInterceptor performanceInterceptor() &#123;       PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();       performanceInterceptor.setMaxTime(100); //ms ,超过设置的ms的sql不执行        performanceInterceptor.setFormat(true);       return performanceInterceptor;    &#125;&#125;</code></pre><p><strong>（5）测试乐观锁可以修改成功</strong></p><p>测试后分析打印的sql语句，将version的数值进行了加1操作</p><pre><code class="java">/*** 测试 乐观锁插件*/@Testpublic void testOptimisticLocker() &#123;    //查询     User user = userMapper.selectById(1L);     //修改数据    user.setName(&quot;Helen Yao&quot;);    user.setEmail(&quot;helen@qq.com&quot;);    //执行更新    userMapper.updateById(user);&#125;</code></pre><p><strong>（5）测试乐观锁修改失败</strong></p><pre><code class="java">/*** 测试乐观锁插件 失败*/@Testpublic void testOptimisticLockerFail() &#123;    //查询    User user = userMapper.selectById(1L);    //修改数据    user.setName(&quot;Helen Yao1&quot;);    user.setEmail(&quot;helen@qq.com1&quot;)        //模拟取出数据后，数据库中version实际数据比取出的值大，即已被其它线程修改并更新了version    user.setVersion(user.getVersion() - 1);    //执行更新    userMapper.updateById(user);&#125;</code></pre><h3 id="select"><a href="#select" class="headerlink" title="select"></a><strong>select</strong></h3><h4 id="1、根据id查询记录"><a href="#1、根据id查询记录" class="headerlink" title="1、根据id查询记录"></a><strong>1、根据id查询记录</strong></h4><pre><code class="java">@Testpublic void testSelectById()&#123;      User user = userMapper.selectById(1L);    System.out.println(user);    &#125;</code></pre><h4 id="2、通过多个id批量查询"><a href="#2、通过多个id批量查询" class="headerlink" title="2、通过多个id批量查询"></a><strong>2、通过多个id批量查询</strong></h4><p>完成了动态sql的foreach的功能</p><pre><code class="java">@Testpublic void testSelectBatchIds()&#123; List&lt;User&gt; users = userMapper.selectBatchIds(Arrays.asList(1, 2, 3));                users.forEach(System.out::println);    &#125;</code></pre><h4 id="3、简单的条件查询"><a href="#3、简单的条件查询" class="headerlink" title="3、简单的条件查询"></a><strong>3、简单的条件查询</strong></h4><p>通过map封装查询条件</p><pre><code class="java">@Testpublic void testSelectByMap()&#123;     //查询名字为  Helen 并且年龄为18 的记录    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;name&quot;, &quot;Helen&quot;);    map.put(&quot;age&quot;, 18);     List&lt;User&gt; users = userMapper.selectByMap(map);    users.forEach(System.out::println);&#125;</code></pre><p><strong>注意：</strong>map中的key对应的是数据库中的列名。例如数据库user_id，实体类是userId，这时map的key需要填写user_id</p><h4 id="4、分页"><a href="#4、分页" class="headerlink" title="4、分页"></a>4、分页</h4><p>MyBatis  Plus自带分页插件，只要简单的配置即可实现分页功能</p><p><strong>（1）创建配置类</strong></p><p>此时可以删除主类中的 <em>@MapperScan</em> 扫描注解</p><pre><code class="java">/* 分页插件 */@Beanpublic PaginationInterceptor paginationInterceptor() &#123;   return new PaginationInterceptor();&#125;</code></pre><p><strong>（2）测试selectPage分页</strong></p><p><strong>测试：</strong>最终通过page对象获取相关数据</p><pre><code class="java">@Testvoid pageTest()&#123;        //1、创建page对象  传入两个参数：当前页 、 每页显示记录数        Page&lt;Usertest&gt; page = new Page&lt;&gt;(1,10);        //调用mp分页查询时，会把分页所有数据都封装到page对象里        userMapper.selectPage(page,null);//第二个参数为条件        System.out.println(page.getCurrent());//获取当前页        System.out.println(page.getRecords());//每页数据list集合        System.out.println(page.getSize());//每页显示记录数        System.out.println(page.getTotal());//总记录数        System.out.println(page.getPages());//总页数        System.out.println(page.hasNext());//是否有下一页，返回布尔值        System.out.println(page.hasPrevious());//是否有上一页    &#125;</code></pre><p>控制台sql语句打印：SELECT  id,name,age,email,create_time,update_time FROM user LIMIT 0,5 </p><p><strong>（3）测试selectMapsPage分页：结果集是Map</strong></p><h3 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h3><h4 id="1、根据id删除记录"><a href="#1、根据id删除记录" class="headerlink" title="1、根据id删除记录"></a><strong>1、根据id删除记录</strong></h4><pre><code class="java">@Testpublic void testDeleteById()&#123;     int result = userMapper.deleteById(8L);    System.out.println(result);&#125;</code></pre><h4 id="2、批量删除"><a href="#2、批量删除" class="headerlink" title="2、批量删除"></a><strong>2、批量删除</strong></h4><pre><code class="java">    @Test    public void testDeleteBatchIds() &#123;         int result = userMapper.deleteBatchIds(Arrays.asList(8, 9, 10));        System.out.println(result);    &#125;</code></pre><h4 id="3、简单的条件查询删除"><a href="#3、简单的条件查询删除" class="headerlink" title="3、简单的条件查询删除"></a><strong>3、简单的条件查询删除</strong></h4><pre><code class="java">@Testpublic void testDeleteByMap() &#123;    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;name&quot;, &quot;Helen&quot;);   map.put(&quot;age&quot;, 18);    int result = userMapper.deleteByMap(map);     System.out.println(result);&#125;</code></pre><h4 id="4、逻辑删除"><a href="#4、逻辑删除" class="headerlink" title="4、逻辑删除"></a>4、逻辑删除</h4><ul><li>物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除数据</li><li>逻辑删除：假删除，将对应数据中代表是否被删除字段状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录</li></ul><p><strong>（1）数据库中添加  deleted字段</strong></p><pre><code class="sql">ALTER TABLE `user` ADD COLUMN `deleted` boolean</code></pre><p><strong>（2）实体类添加deleted 字段</strong></p><p>并加上  @TableLogic 注解 和 @TableField(fill = FieldFill.INSERT) 注解</p><pre><code class="java">@TableLogic@TableField(fill = FieldFill.INSERT)private Integer deleted;</code></pre><p><strong>（3）元对象处理器接口添加deleted的insert默认值</strong></p><pre><code class="java">@Overridepublic void insertFill(MetaObject metaObject) &#123;     ......    this.setFieldValByName(&quot;deleted&quot;, 0, metaObject);&#125;</code></pre><p><strong>（4）application.properties 加入配置</strong></p><p>此为默认值，如果你的默认值和mp默认的一样,该配置可无</p><pre><code class="properties">mybatis-plus.global-config.db-config.logic-delete-value=1mybatis-plus.global-config.db-config.logic-not-delete-value=0</code></pre><p><strong>（5）在  MybatisPlusConfig 中注册 Bean</strong></p><pre><code class="java">@Beanpublic ISqlInjector sqlInjector() &#123;   return new LogicSqlInjector();&#125;</code></pre><p><strong>（6）测试逻辑删除</strong></p><ul><li>测试后发现，数据并没有被删除，deleted字段的值由0变成了1</li><li>测试后分析打印的sql语句，是一条update</li><li><strong>注意：</strong>被删除数据的deleted 字段的值必须是  0，才能被选取出来执行逻辑删除的操作</li></ul><pre><code class="java">/* 测试 逻辑删除 */@Testpublic void testLogicDelete() &#123;     int result = userMapper.deleteById(1L);    System.out.println(result);&#125;</code></pre><p><strong>（7）测试逻辑删除后的查询</strong></p><p>MyBatis Plus中查询操作也会自动添加逻辑删除字段的判断</p><pre><code class="java">/* 测试 逻辑删除后的查询： 不包括被逻辑删除的记录 */@Testpublic void testLogicDeleteSelect() &#123;    User user = new User();    List&lt;User&gt; users = userMapper.selectList(null);    users.forEach(System.out::println);&#125;</code></pre><p>测试后分析打印的sql语句，包含 WHERE deleted=0 </p><p>SELECT  id,name,age,email,create_time,update_time,deleted FROM user WHERE  deleted=0</p><h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><p>性能分析拦截器，用于输出每条 SQL 语句及其执行时间</p><p>SQL  性能执行分析,开发环境使用，超过指定时间，停止运行。有助于发现问题</p><h4 id="1、配置插件"><a href="#1、配置插件" class="headerlink" title="1、配置插件"></a>1、配置插件</h4><p><strong>（1）参数说明</strong></p><p>参数：maxTime：  SQL 执行最大时长，超过自动停止运行，有助于发现问题。</p><p>参数：format：  SQL是否格式化，默认false。</p><p><strong>（2）在  MybatisPlusConfig 中配置</strong></p><pre><code class="java">/*** SQL 执行性能分析插* 件开发环境使用，线上不推荐。 maxTime 指的是 sql 最大执行时长*/@Bean@Profile(&#123;&quot;dev&quot;,&quot;test&quot;&#125;)// 设置 dev test 环境开启public PerformanceInterceptor performanceInterceptor() &#123;    PerformanceInterceptor performanceInterceptor = new PerformanceInterceptor();     performanceInterceptor.setMaxTime(100);//ms，超过此处设置的ms则sql不执行     performanceInterceptor.setFormat(true);    return performanceInterceptor;&#125;</code></pre><p><strong>（3）Spring  Boot 中设置dev环境</strong></p><pre><code class="properties">#环境设置：dev、test、prodspring.profiles.active=dev</code></pre><p>可以针对各环境新建不同的配置文件<code>application-dev.properties</code>、<code>application-test.properties</code>、<code>application-prod.properties</code></p><p>也可以自定义环境名称：如test1、test2</p><h4 id="2、测试"><a href="#2、测试" class="headerlink" title="2、测试"></a>2、测试</h4><p><strong>（1）常规测试</strong></p><pre><code class="java">/*** 测试 性能分析插件*/@Testpublic void testPerformance() &#123;    User user = new User();    user.setName(&quot;我是Helen&quot;);    user.setEmail(&quot;helen@sina.com&quot;);    user.setAge(18);    userMapper.insert(user);&#125;</code></pre><p><strong>（2）将maxTime  改小之后再次进行测试</strong></p><pre><code class="java">performanceInterceptor.setMaxTime(5);//ms，超过此处设置的ms不执行</code></pre><p>如果执行时间过长，则抛出异常：The SQL execution time is too  large, </p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>如果想进行复杂条件查询，那么需要使用条件构造器 Wapper，涉及到如下方法</p><p><strong>1、delete</strong></p><p><strong>2、selectOne</strong></p><p><strong>3、selectCount</strong></p><p><strong>4、selectList</strong></p><p><strong>5、selectMaps</strong></p><p><strong>6、selectObjs</strong></p><p><strong>7、update</strong></p><h2 id="wapper介绍"><a href="#wapper介绍" class="headerlink" title="wapper介绍"></a><strong>wapper介绍</strong></h2><p><img src="C:\Users\Carina\Desktop\Java学习笔记\assets\27b56b5e-39a6-42ba-b7ed-4f109b6ad7bf.png" alt="img"></p><p>Wrapper ：  条件构造抽象类，最顶端父类</p><p>   AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件</p><p>​     QueryWrapper ： Entity 对象封装操作类，不是用lambda语法</p><p>​     UpdateWrapper ： Update 条件封装，用于Entity对象更新操作</p><p>   AbstractLambdaWrapper ： Lambda 语法使用 Wrapper统一处理解析 lambda 获取 column。</p><p>​     LambdaQueryWrapper ：看名称也能明白就是用于Lambda语法使用的查询Wrapper</p><p>​     LambdaUpdateWrapper ： Lambda 更新封装Wrapper</p><pre><code class="java">@RunWith(SpringRunner.class)@SpringBootTestpublic class QueryWrapperTests &#123;    @Autowired    private UserMapper userMapper;&#125;</code></pre><h3 id="AbstractWrapper"><a href="#AbstractWrapper" class="headerlink" title="AbstractWrapper"></a>AbstractWrapper</h3><p><strong>注意：以下条件构造器的方法入参中的 <code>column </code>均表示数据库字段</strong></p><h4 id="ge、gt、le、lt、isNull、isNotNull、eq、ne"><a href="#ge、gt、le、lt、isNull、isNotNull、eq、ne" class="headerlink" title="ge、gt、le、lt、isNull、isNotNull、eq、ne"></a><strong>ge、gt、le、lt、isNull、isNotNull、</strong>eq、ne</h4><pre><code class="java">    //mp实现复杂查询//ge、gt、le、lt   对应 &gt;=  &gt; &lt;=   &lt;//eq、ne  对应  =  != 或 &lt;&gt;    @Test    void testSelectQuery() &#123;        //创建QueryWrapper对象        QueryWrapper&lt;Usertest&gt; wrapper = new QueryWrapper&lt;&gt;();        //通过QueryWrapper设置条件        //查询age&gt;=30的记录  第一个参数为数据库字段名 第二个为参数值        //wrapper.ge(&quot;age&quot;,30);        //eq为等于 ne为不等于   查询名字为tom的记录       // wrapper.eq(&quot;name&quot;,&quot;tom&quot;);        List&lt;Usertest&gt; usertests = userMapper.selectList(wrapper);        System.out.println(usertests);    &#125;</code></pre><p>SQL：UPDATE  user SET deleted=1 WHERE deleted=0 AND name IS NULL AND age &gt;= ? AND email IS  NOT NULL</p><p><strong>注意：</strong>seletOne返回的是一条实体记录，当出现多条时会报错</p><p>SELECT  id,name,age,email,create_time,update_time,deleted,version FROM user WHERE  deleted=0 AND name = ? </p><h4 id="between、notBetween"><a href="#between、notBetween" class="headerlink" title="between、notBetween"></a><strong>between、notBetween</strong></h4><p>包含大小边界</p><pre><code class="java">@Testpublic void testSelectCount() &#123;     QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    //查询年龄在20到30之间的记录     queryWrapper.between(&quot;age&quot;, 20, 30);     Integer count = userMapper.selectCount(queryWrapper);     System.out.println(count);   &#125;</code></pre><p>SELECT  COUNT(1) FROM user WHERE deleted=0 AND age BETWEEN ? AND ? </p><h4 id="allEq"><a href="#allEq" class="headerlink" title="allEq"></a><strong>allEq</strong></h4><pre><code class="java">@Testpublic void testSelectList() &#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;id&quot;, 2);     map.put(&quot;name&quot;, &quot;Jack&quot;);    map.put(&quot;age&quot;, 20);    queryWrapper.allEq(map);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);&#125;</code></pre><p>SELECT  id,name,age,email,create_time,update_time,deleted,version </p><p>FROM user WHERE deleted=0 AND name = ? AND id = ?  AND age = ? </p><h4 id="like、notLike、likeLeft、likeRight"><a href="#like、notLike、likeLeft、likeRight" class="headerlink" title="like、notLike、likeLeft、likeRight"></a>like、notLike、likeLeft、likeRight</h4><p>selectMaps返回Map集合列表</p><pre><code class="java">@Testpublic void testSelectMaps() &#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.notLike(&quot;name&quot;, &quot;e&quot;).likeRight(&quot;email&quot;, &quot;t&quot;);    List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper);    //返回值是Map列表    maps.forEach(System.out::println);&#125;</code></pre><p>SELECT  id,name,age,email,create_time,update_time,deleted,version </p><p>FROM user  WHERE deleted=0 AND name NOT LIKE ? AND email LIKE ? </p><h4 id="in、notIn、inSql、notinSql、exists、notExists"><a href="#in、notIn、inSql、notinSql、exists、notExists" class="headerlink" title="in、notIn、inSql、notinSql、exists、notExists"></a><strong>in、notIn、inSql、notinSql、exists、notExists</strong></h4><p>in、notIn：</p><pre><code class="java"> notIn(&quot;age&quot;,&#123;1,2,3&#125;)---&gt;age not in (1,2,3) notIn(&quot;age&quot;, 1, 2, 3)---&gt;age not in  (1,2,3)</code></pre><p>inSql、notinSql：可以实现子查询</p><ul><li>例: <code>inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)</code>—&gt;<code>age in (1,2,3,4,5,6)</code></li><li>例: <code>inSql(&quot;id&quot;, &quot;select id from table where id &lt;  3&quot;)</code>—&gt;<code>id in (select id from table where id &lt;  3)</code></li></ul><pre><code class="java">@Testpublic void testSelectObjs() &#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    //queryWrapper.in(&quot;id&quot;, 1, 2, 3);    queryWrapper.inSql(&quot;id&quot;, &quot;select id from user where id &lt; 3&quot;);    List&lt;Object&gt; objects = userMapper.selectObjs(queryWrapper);//返回值是Object列表     objects.forEach(System.out::println);&#125;</code></pre><p>SELECT  id,name,age,email,create_time,update_time,deleted,version </p><p>FROM user  WHERE deleted=0 AND id IN (select id from user where id &lt; 3) </p><h4 id="or、and"><a href="#or、and" class="headerlink" title="or、and"></a>or、and</h4><p><strong>注意：</strong>这里使用的是  UpdateWrapper </p><p>不调用<code>or</code>则默认为使用 <code>and </code>连</p><pre><code class="java">@Testpublic void testUpdate1() &#123;     //修改值    User user = new User();    user.setAge(99);    user.setName(&quot;Andy&quot;);    //修改条件    UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;();       userUpdateWrapper           .like(&quot;name&quot;, &quot;h&quot;)           .or()           .between(&quot;age&quot;, 20, 30);    int result = userMapper.update(user, userUpdateWrapper);    System.out.println(result);&#125;</code></pre><p>UPDATE user  SET name=?, age=?, update_time=? WHERE deleted=0 AND name LIKE ? OR age BETWEEN  ? AND ?</p><h4 id="嵌套or、嵌套and"><a href="#嵌套or、嵌套and" class="headerlink" title="嵌套or、嵌套and"></a>嵌套or、嵌套and</h4><p>这里使用了lambda表达式，or中的表达式最后翻译成sql时会被加上圆括号</p><pre><code class="java">public void testUpdate2() &#123;    //修改值    User user = new User();    user.setAge(99);    user.setName(&quot;Andy&quot;);    //修改条件    UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;();    userUpdateWrapper        .like(&quot;name&quot;, &quot;h&quot;)        .or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;age&quot;, 20));    int result = userMapper.update(user, userUpdateWrapper);    System.out.println(result);&#125;</code></pre><p>UPDATE user  SET name=?, age=?, update_time=? </p><p>WHERE  deleted=0 AND name LIKE ? </p><p>OR ( name =  ? AND age &lt;&gt; ? ) </p><h4 id="orderBy、orderByDesc、orderByAsc"><a href="#orderBy、orderByDesc、orderByAsc" class="headerlink" title="orderBy、orderByDesc、orderByAsc"></a><strong>orderBy、orderByDesc、orderByAsc</strong></h4><pre><code class="java">@Testpublic void testSelectListOrderBy() &#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.orderByDesc(&quot;id&quot;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println)；&#125;</code></pre><p>SELECT  id,name,age,email,create_time,update_time,deleted,version </p><p>FROM user WHERE deleted=0 ORDER BY id  DESC </p><h4 id="last"><a href="#last" class="headerlink" title="last"></a><strong>last</strong></h4><p>直接拼接到 sql  的最后</p><p><strong>注意：</strong>只能调用一次,多次调用以最后一次为准  有sql注入的风险,请谨慎使用</p><pre><code class="java">@Testpublic void testSelectListLast() &#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.last(&quot;limit 1&quot;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);&#125;</code></pre><p>SELECT  id,name,age,email,create_time,update_time,deleted,version </p><p>FROM user WHERE deleted=0 limit  1 </p><h4 id="指定要查询的列"><a href="#指定要查询的列" class="headerlink" title="指定要查询的列"></a>指定要查询的列</h4><pre><code class="java">@Testpublic void testSelectListColumn() &#123;    QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;();    queryWrapper.select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;);    List&lt;User&gt; users = userMapper.selectList(queryWrapper);    users.forEach(System.out::println);&#125;</code></pre><p>SELECT  id,name,age FROM user WHERE deleted=0 </p><h4 id="set、setSql"><a href="#set、setSql" class="headerlink" title="set、setSql"></a><strong>set、setSql</strong></h4><p>最终的sql会合并 user.setAge()，以及 userUpdateWrapper.set()  和 setSql() 中 的字段</p><pre><code class="java">@Testpublic void testUpdateSet() &#123;    //修改值    User user = new User();    user.setAge(99);    //修改条件    UpdateWrapper&lt;User&gt; userUpdateWrapper = new UpdateWrapper&lt;&gt;();    userUpdateWrapper        .like(&quot;name&quot;, &quot;h&quot;)        .set(&quot;name&quot;, &quot;老李头&quot;)        //除了可以查询还可以使用set设置修改的字段        .setSql(&quot; email = &#39;123@qq.com&#39;&quot;);    //可以有子查询    int result = userMapper.update(user, userUpdateWrapper);&#125;</code></pre><p>UPDATE user  SET age=?, update_time=?, name=?, email = ‘<a href="mailto:&#x31;&#x32;&#x33;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;">&#x31;&#x32;&#x33;&#x40;&#x71;&#113;&#46;&#99;&#111;&#109;</a>‘ WHERE deleted=0 AND name  LIKE ? </p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis Plus </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis</title>
      <link href="/2020/06/25/mybatis/"/>
      <url>/2020/06/25/mybatis/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="1、Mybatis介绍"><a href="#1、Mybatis介绍" class="headerlink" title="1、Mybatis介绍"></a>1、Mybatis介绍</h2><p>MyBatis 是一款优秀的<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=55187093&ss_c=ssc.citiao.link">持久层</a>框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=175271925&ss_c=ssc.citiao.link">几乎所有的</a> JDBC 代码和手动设置参数以及获取<a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=66020459&ss_c=ssc.citiao.link">结果集</a>。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Old Java Objects,普通的 Java对象)映射成数据库中的记录。</p><h2 id="2、Mybatis项目搭建"><a href="#2、Mybatis项目搭建" class="headerlink" title="2、Mybatis项目搭建"></a>2、Mybatis项目搭建</h2><h3 id="2-1-导入maven依赖"><a href="#2-1-导入maven依赖" class="headerlink" title="2.1  导入maven依赖"></a>2.1  导入maven依赖</h3><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;org.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mybatis&lt;/artifactId&gt;    &lt;version&gt;3.4.5&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;5.1.26&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="2-2-创建数据库表"><a href="#2-2-创建数据库表" class="headerlink" title="2.2  创建数据库表"></a>2.2  创建数据库表</h3><pre><code class="sql">CREATE TABLE users(id INT PRIMARY KEY  AUTO_INCREMENT, NAME VARCHAR(20), age INT);  INSERT INTO users(NAME, age)  VALUES(&#39;Tom&#39;, 12);  INSERT INTO users(NAME, age)  VALUES(&#39;Jack&#39;, 11);  </code></pre><h3 id="2-3-添加Mybatis配置文件"><a href="#2-3-添加Mybatis配置文件" class="headerlink" title="2.3 添加Mybatis配置文件"></a>2.3 添加Mybatis配置文件</h3><ul><li><p>在resources目录下新建一个mybatis-config.xml文件</p></li><li><p>并修改数据库配置</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot;/&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;                &lt;property name=&quot;password&quot; value=&quot;123&quot;/&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;!--    注解接口绑定--&gt;    &lt;mappers&gt;        &lt;mapper class=&quot;com.itdemo.Dao.UserMapper&quot;&gt;&lt;/mapper&gt;        &lt;mapper resource=&quot;com/itdemo/Dao*.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;&lt;/configuration&gt;</code></pre></li></ul><h3 id="2-4-创建目录结构并且编写数据库对应的实体类"><a href="#2-4-创建目录结构并且编写数据库对应的实体类" class="headerlink" title="2.4  创建目录结构并且编写数据库对应的实体类"></a>2.4  创建目录结构并且编写数据库对应的实体类</h3><p>创建实体类user</p><pre><code class="java">public class User  &#123;    private int id;    private String name;    private String pwd;    public User(int id, String name, String pwd) &#123;        this.id = id;        this.name = name;        this.pwd = pwd;    &#125;    //编写get 和set方法</code></pre><h3 id="2-5-定义Mapper接口"><a href="#2-5-定义Mapper接口" class="headerlink" title="2.5 定义Mapper接口"></a>2.5 定义Mapper接口</h3><pre><code class="java">public interface UserMapper &#123;    //使用注解    @Select(&quot;select * from user&quot;)    List&lt;User&gt;  findAll();        //不使用注解时     List&lt;User&gt;  findAll();&#125;</code></pre><h3 id="2-6-在同一个包下创建Mapper的映射文件"><a href="#2-6-在同一个包下创建Mapper的映射文件" class="headerlink" title="2.6  在同一个包下创建Mapper的映射文件"></a>2.6  在同一个包下创建Mapper的映射文件</h3><p>文件名为UserMapper.xml</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itdemo.Dao.UserMapper&quot;&gt;    //id为接口的方法名    parameterType为参数类型 resultType 返回结果类型    &lt;select id=&quot;findAll&quot; parameterType=&quot;int&quot; resultType=&quot;com.itdemo.dao.UserMapper&quot;&gt;        select * from user where id =#&#123;id&#125;;    &lt;/select&gt;&lt;/mapper&gt;</code></pre><h3 id="2-7在mybatis-config-xml文件中加载Mapper映射文件"><a href="#2-7在mybatis-config-xml文件中加载Mapper映射文件" class="headerlink" title="2.7在mybatis-config.xml文件中加载Mapper映射文件"></a>2.7在mybatis-config.xml文件中加载Mapper映射文件</h3><pre><code class="xml">&lt;!--    注解接口绑定--&gt;    &lt;mappers&gt;        &lt;mapper class=&quot;com.itdemo.Dao.UserMapper&quot;&gt;&lt;/mapper&gt;        &lt;mapper resource=&quot;com/itdemo/Dao*.xml&quot;&gt;&lt;/mapper&gt;    &lt;/mappers&gt;</code></pre><h3 id="2-8在utils包下创建一个工具类"><a href="#2-8在utils包下创建一个工具类" class="headerlink" title="2.8在utils包下创建一个工具类"></a>2.8在utils包下创建一个工具类</h3><pre><code class="java">package com.itdemo.Utils;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import java.io.IOException;import java.io.InputStream;public class MybatisUtils &#123;    private static SqlSessionFactory sqlSessionFactory;    static &#123;            String resource =&quot;mybatis-config.xml&quot;;        try &#123;            InputStream inputStream = Resources.getResourceAsStream(resource);            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;  public static SqlSession getsqlSession() &#123;     return sqlSessionFactory.openSession(true);  &#125;&#125;</code></pre><h3 id="2-9测试"><a href="#2-9测试" class="headerlink" title="2.9测试"></a>2.9测试</h3><pre><code class="java">public static void main(String[] args) throws IOException &#123;    SqlSession sqlSession = MybatisUtils.getsqlSession();    UserMapper mapper = sqlSession.getMapper(UserMapper.class);//使用了代理模式    List&lt;User&gt; users=mapper.findAll();    for (User user:users)&#123;        System.out.println(user);    &#125;    sqlSession.close();&#125;</code></pre><h3 id="2-10Mapper映射文件无法加载问题"><a href="#2-10Mapper映射文件无法加载问题" class="headerlink" title="2.10Mapper映射文件无法加载问题"></a>2.10Mapper映射文件无法加载问题</h3><p>在pom.xml中添加下面的代码</p><pre><code class="xml">&lt;build&gt;    &lt;resources&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/resources&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;        &lt;resource&gt;            &lt;directory&gt;src/main/java&lt;/directory&gt;            &lt;includes&gt;                &lt;include&gt;**/*.properties&lt;/include&gt;                &lt;include&gt;**/*.xml&lt;/include&gt;            &lt;/includes&gt;            &lt;filtering&gt;true&lt;/filtering&gt;        &lt;/resource&gt;    &lt;/resources&gt;&lt;/build&gt;</code></pre><h2 id="3、万能Map"><a href="#3、万能Map" class="headerlink" title="3、万能Map"></a>3、万能Map</h2><p>如果我们的实体类，或者数据库中的表，字段或参数过多，我们应该使用map</p><p>配置文件中可传递map</p><p>接口中的方法</p><pre><code class="java">int addUser(Map&lt;String,Object&gt; map);</code></pre><pre><code class="xml">&lt;insert id=&quot;addUser&quot; parameterType=&quot;map&quot;&gt;        insert into user(id ,name,password) values(#&#123;userid&#125;,#&#123;name&#125;,#&#123;password&#125;)；&lt;/insert&gt;</code></pre><p>测试类中</p><pre><code class="xml">Map&lt;String,Object&gt; map=new HashMap&lt;String, Object&gt;();map.put(&quot;userid&quot;,5);//数据库中不需要的可以省略map.put(&quot;name&quot;,&quot;张三&quot;);map.put(&quot;password&quot;,&quot;1234561&quot;);mapper.addUser(map);</code></pre><h3 id="ResultMap解决属性名和字段名不一致问题"><a href="#ResultMap解决属性名和字段名不一致问题" class="headerlink" title="ResultMap解决属性名和字段名不一致问题"></a>ResultMap解决属性名和字段名不一致问题</h3><p>如果数据库表字段名和实体类的属性名不一致时，无法直接获取结果</p><pre><code class="xml"> &lt;select id=&quot;getUserById&quot; resultMap=&quot;UserMap&quot;&gt;        select * from user where id=#&#123;id&#125;;    &lt;/select&gt;    &lt;resultMap id=&quot;UserMap&quot; type=&quot;com.itdemo.User&quot;&gt;&lt;!--        column为数据库中的字段    property实体类中的属性--&gt;        &lt;result column=&quot;id&quot;       property=&quot;userid&quot;/&gt;        &lt;result column=&quot;name&quot;     property=&quot;name&quot;/&gt;        &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;    &lt;/resultMap&gt;</code></pre><h2 id="4、日志"><a href="#4、日志" class="headerlink" title="4、日志"></a>4、日志</h2><h3 id="4-1日志工厂"><a href="#4-1日志工厂" class="headerlink" title="4.1日志工厂"></a>4.1日志工厂</h3><p>在resources配置文件中添加</p><pre><code class="xml">&lt;settings&gt;    &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt;</code></pre><h2 id="5、注解开发"><a href="#5、注解开发" class="headerlink" title="5、注解开发"></a>5、注解开发</h2><h3 id="5-1-建立注解Mapper"><a href="#5-1-建立注解Mapper" class="headerlink" title="5.1 建立注解Mapper"></a>5.1 建立注解Mapper</h3><pre><code class="java">public interface UserMapper &#123;    @Select(&quot;select * from user&quot;)    List&lt;User&gt;  findAll();    @Select(&quot;select * from user where id=#&#123;id&#125;&quot;)    User getByid(@Param(&quot;id&quot;) int id);    @Insert(&quot;insert into user(id,name,pwd) values(#&#123;id&#125;,#&#123;name&#125;,#&#123;password&#125;)&quot;)    int addUser(User user);    @Update(&quot;update user set pwd=#&#123;&#125; where id=#&#123;id&#125;&quot;)    int updateUser(User user);&#125;</code></pre><h3 id="5-2-加入mybatis-xml"><a href="#5-2-加入mybatis-xml" class="headerlink" title="5.2 加入mybatis.xml"></a>5.2 加入mybatis.xml</h3><pre><code> &lt;mapper  class=&quot;com.itdemo.dao.UserMapper&quot; /&gt;  </code></pre><h3 id="5-3-运行测试"><a href="#5-3-运行测试" class="headerlink" title="5.3 运行测试"></a>5.3 运行测试</h3><h1 id="Mybatis总结"><a href="#Mybatis总结" class="headerlink" title="Mybatis总结"></a>Mybatis总结</h1><h2 id="Mybatis与jdbc"><a href="#Mybatis与jdbc" class="headerlink" title="Mybatis与jdbc"></a>Mybatis与jdbc</h2><h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h3><p>ORM（Object Relational Mapping），对象关系映射，是一种为了解决关系型数据库数据与简单Java对象（POJO）的映射关系的技术。简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系型数据库中。</p><h3 id="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"><a href="#为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？" class="headerlink" title="为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？"></a>为什么说Mybatis是半自动ORM映射工具？它与全自动的区别在哪里？</h3><p>Hibernate属于全自动ORM映射工具，使用Hibernate查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。</p><p>而Mybatis在查询关联对象或关联集合对象时，需要手动编写sql来完成，所以，称之为半自动ORM映射工具。</p><h3 id="传统JDBC开发存在的问题"><a href="#传统JDBC开发存在的问题" class="headerlink" title="传统JDBC开发存在的问题"></a>传统JDBC开发存在的问题</h3><ul><li><p>频繁创建数据库连接对象、释放，容易造成系统资源浪费，影响系统性能。可以使用连接池解决这个问题。但是使用jdbc需要自己实现连接池。</p></li><li><p>sql语句定义、参数设置、结果集处理存在硬编码。实际项目中sql语句变化的可能性较大，一旦发生变化，需要修改java代码，系统需要重新编译，重新发布。不好维护。</p></li><li><p>使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。</p></li><li><p>结果集处理存在重复代码，处理麻烦。如果可以映射成Java对象会比较方便。</p><h3 id="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC编程有哪些不足之处，MyBatis是如何解决这些问题的？</h3><p>1、数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库连接池可解决此问题。</p></li></ul><p>解决：在mybatis-config.xml中配置数据链接池，使用连接池管理数据库连接。</p><p>2、Sql语句写在代码中造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。</p><p>解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。</p><p>3、向sql语句传参数麻烦，因为sql语句的where条件不一定，可能多也可能少，占位符需要和参数一一对应。</p><p>解决： Mybatis自动将java对象映射至sql语句。</p><p>4、对结果集解析麻烦，sql变化导致解析代码变化，且解析前需要遍历，如果能将数据库记录封装成pojo对象解析比较方便。</p><p>解决：Mybatis自动将sql执行结果映射至java对象。</p><h2 id="Mybatis优缺点"><a href="#Mybatis优缺点" class="headerlink" title="Mybatis优缺点"></a>Mybatis优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h5 id="与传统的数据库访问技术相比，ORM有以下优点："><a href="#与传统的数据库访问技术相比，ORM有以下优点：" class="headerlink" title="与传统的数据库访问技术相比，ORM有以下优点："></a>与传统的数据库访问技术相比，ORM有以下优点：</h5><ul><li>基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用</li><li>与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接</li><li>很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护</li><li>能够与Spring很好的集成</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>SQL语句的编写工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求</li><li>SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库</li></ul><h3 id="MyBatis框架适用场景"><a href="#MyBatis框架适用场景" class="headerlink" title="MyBatis框架适用场景"></a>MyBatis框架适用场景</h3><ul><li>MyBatis专注于SQL本身，是一个足够灵活的DAO层解决方案。</li><li>对性能的要求很高，或者需求变化较多的项目，如互联网项目，MyBatis将是不错的选择。</li></ul><h3 id="Hibernate-和-MyBatis-的区别"><a href="#Hibernate-和-MyBatis-的区别" class="headerlink" title="Hibernate 和 MyBatis 的区别"></a>Hibernate 和 MyBatis 的区别</h3><h5 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h5><p>都是对jdbc的封装，都是持久层的框架，都用于dao层的开发。</p><h5 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h5><h5 id="映射关系"><a href="#映射关系" class="headerlink" title="映射关系"></a>映射关系</h5><ul><li><p>MyBatis 是一个半自动映射的框架，配置Java对象与sql语句执行结果的对应关系，多表关联关系配置简单</p></li><li><p>Hibernate 是一个全表映射的框架，配置Java对象与数据库表的对应关系，多表关联关系配置复杂</p><h5 id="SQL优化和移植性"><a href="#SQL优化和移植性" class="headerlink" title="SQL优化和移植性"></a>SQL优化和移植性</h5></li><li><p>Hibernate 对SQL语句封装，提供了日志、缓存、级联（级联比 MyBatis 强大）等特性，此外还提供 HQL（Hibernate Query Language）操作数据库，数据库无关性支持好，但会多消耗性能。如果项目需要支持多种数据库，代码开发量少，但SQL语句优化困难。</p></li><li><p>MyBatis 需要手动编写 SQL，支持动态 SQL、处理列表、动态生成表名、支持存储过程。开发工作量相对大些。直接使用SQL语句操作数据库，不支持数据库无关性，但sql语句优化容易。</p><h5 id="开发难易程度和学习成本"><a href="#开发难易程度和学习成本" class="headerlink" title="开发难易程度和学习成本"></a>开发难易程度和学习成本</h5></li><li><p>Hibernate 是重量级框架，学习使用门槛高，适合于需求相对稳定，中小型的项目，比如：办公自动化系统</p></li><li><p>MyBatis 是轻量级框架，学习使用门槛低，适合于需求变化频繁，大型的项目，比如：互联网电子商务系统</p></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>MyBatis 是一个小巧、方便、高效、简单、直接、半自动化的持久层框架，</p><p>Hibernate 是一个强大、方便、高效、复杂、间接、全自动化的持久层框架。</p><h2 id="MyBatis的解析和运行原理"><a href="#MyBatis的解析和运行原理" class="headerlink" title="MyBatis的解析和运行原理"></a>MyBatis的解析和运行原理</h2><h3 id="MyBatis编程步骤是什么样的？"><a href="#MyBatis编程步骤是什么样的？" class="headerlink" title="MyBatis编程步骤是什么样的？"></a>MyBatis编程步骤是什么样的？</h3><p>1、 创建SqlSessionFactory</p><p>2、 通过SqlSessionFactory创建SqlSession</p><p>3、 通过sqlsession执行数据库操作</p><p>4、 调用session.commit()提交事务</p><p>5、 调用session.close()关闭会话</p><h3 id="MyBatis的工作原理"><a href="#MyBatis的工作原理" class="headerlink" title="MyBatis的工作原理"></a>MyBatis的工作原理</h3><p>MyBatis 的工作原理如下图</p><p><img src="C:\Users\Carina\AppData\Roaming\Typora\typora-user-images\image-20200716203333762.png" alt="image-20200716203333762"></p><p>1）读取 MyBatis 配置文件：mybatis-config.xml 为 MyBatis 的全局配置文件，配置了 MyBatis 的运行环境等信息，例如数据库连接信息。</p><p>2）加载映射文件。映射文件即 SQL 映射文件，该文件中配置了操作数据库的 SQL 语句，需要在 MyBatis 配置文件 mybatis-config.xml 中加载。mybatis-config.xml 文件可以加载多个映射文件，每个文件对应数据库中的一张表。</p><p>3）构造会话工厂：通过 MyBatis 的环境等配置信息构建会话工厂 SqlSessionFactory。</p><p>4）创建会话对象：由会话工厂创建 SqlSession 对象，该对象中包含了执行 SQL 语句的所有方法。</p><p>5）Executor 执行器：MyBatis 底层定义了一个 Executor 接口来操作数据库，它将根据 SqlSession 传递的参数动态地生成需要执行的 SQL 语句，同时负责查询缓存的维护。</p><p>6）MappedStatement 对象：在 Executor 接口的执行方法中有一个 MappedStatement 类型的参数，该参数是对映射信息的封装，用于存储要映射的 SQL 语句的 id、参数等信息。</p><p>7）输入参数映射：输入参数类型可以是 Map、List 等集合类型，也可以是基本数据类型和 POJO 类型。输入参数映射过程类似于 JDBC 对 preparedStatement 对象设置参数的过程。</p><p>8）输出结果映射：输出结果类型可以是 Map、 List 等集合类型，也可以是基本数据类型和 POJO 类型。输出结果映射过程类似于 JDBC 对结果集的解析过程。</p><h3 id="MyBatis的功能架构是怎样的"><a href="#MyBatis的功能架构是怎样的" class="headerlink" title="MyBatis的功能架构是怎样的"></a>MyBatis的功能架构是怎样的</h3><p><img src="C:\Users\Carina\AppData\Roaming\Typora\typora-user-images\image-20200716203600506.png" alt="image-20200716203600506"></p><h5 id="我们把Mybatis的功能架构分为三层："><a href="#我们把Mybatis的功能架构分为三层：" class="headerlink" title="我们把Mybatis的功能架构分为三层："></a>我们把Mybatis的功能架构分为三层：</h5><ul><li>API接口层：提供给外部使用的接口API，开发人员通过这些本地API来操纵数据库。接口层一接收到调用请求就会调用数据处理层来完成具体的数据处理。</li><li>数据处理层：负责具体的SQL查找、SQL解析、SQL执行和执行结果映射处理等。它主要的目的是根据调用的请求完成一次数据库操作。</li><li>基础支撑层：负责最基础的功能支撑，包括连接管理、事务管理、配置加载和缓存处理，这些都是共用的东西，将他们抽取出来作为最基础的组件。为上层的数据处理层提供最基础的支撑。</li></ul><h5 id="为什么需要预编译"><a href="#为什么需要预编译" class="headerlink" title="为什么需要预编译"></a>为什么需要预编译</h5><ol><li><p>定义：<br>SQL 预编译指的是数据库驱动在发送 SQL 语句和参数给 DBMS 之前对 SQL 语句进行编译，这样 DBMS 执行 SQL 时，就不需要重新编译。</p></li><li><p>为什么需要预编译<br>JDBC 中使用对象 PreparedStatement 来抽象预编译语句，使用预编译。预编译阶段可以优化 SQL 的执行。预编译之后的 SQL 多数情况下可以直接执行，DBMS 不需要再次编译，越复杂的SQL，编译的复杂度将越大，预编译阶段可以合并多次操作为一个操作。同时预编译语句对象可以重复利用。把一个 SQL 预编译后产生的 PreparedStatement 对象缓存下来，下次对于同一个SQL，可以直接使用这个缓存的 PreparedState 对象。Mybatis默认情况下，将对所有的 SQL 进行预编译。</p></li></ol><h5 id="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"><a href="#Mybatis都有哪些Executor执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis都有哪些Executor执行器？它们之间的区别是什么？"></a>Mybatis都有哪些Executor执行器？它们之间的区别是什么？</h5><p>Mybatis有三种基本的Executor执行器，SimpleExecutor、ReuseExecutor、BatchExecutor。</p><p>SimpleExecutor：每执行一次update或select，就开启一个Statement对象，用完立刻关闭Statement对象。</p><p>ReuseExecutor：执行update或select，以sql作为key查找Statement对象，存在就使用，不存在就创建，用完后，不关闭Statement对象，而是放置于Map&lt;String, Statement&gt;内，供下一次使用。简言之，就是重复使用Statement对象。</p><p>BatchExecutor：执行update（没有select，JDBC批处理不支持select），将所有sql都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个Statement对象，每个Statement对象都是addBatch()完毕后，等待逐一执行executeBatch()批处理。与JDBC批处理相同。</p><p>作用范围：Executor的这些特点，都严格限制在SqlSession生命周期范围内。</p><h5 id="Mybatis中如何指定使用哪一种Executor执行器？"><a href="#Mybatis中如何指定使用哪一种Executor执行器？" class="headerlink" title="Mybatis中如何指定使用哪一种Executor执行器？"></a>Mybatis中如何指定使用哪一种Executor执行器？</h5><p>在Mybatis配置文件中，在设置（settings）可以指定默认的ExecutorType执行器类型，也可以手动给DefaultSqlSessionFactory的创建SqlSession的方法传递ExecutorType类型参数，如SqlSession openSession(ExecutorType execType)。</p><p>配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（prepared statements）； BATCH 执行器将重用语句并执行批量更新。</p><p>Mybatis是否支持延迟加载？如果支持，它的实现原理是什么？<br>Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，association指的就是一对一，collection指的就是一对多查询。在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled=true|false。</p><p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。</p><p>当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p><h3 id="映射器"><a href="#映射器" class="headerlink" title="映射器"></a>映射器</h3><h4 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h4><ul><li><p>#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。</p></li><li><p>Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。</p></li><li><p>Mybatis在处理时，是原值传入，就是把{}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译</p></li><li><p>变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’</p></li><li><p>#{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入</p></li><li><p>#{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外</p><h4 id="模糊查询like语句该怎么写"><a href="#模糊查询like语句该怎么写" class="headerlink" title="模糊查询like语句该怎么写"></a>模糊查询like语句该怎么写</h4><p>（1）’%${question}%’ 可能引起SQL注入，不推荐</p><p>（2）”%”#{question}”%” 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ ‘，所以这里 % 需     要使用双引号” “，不能使用单引号 ’ ‘，不然会查不到任何结果。</p><p>（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐</p><p>（4）使用bind标签</p><pre><code class="xml">&lt;select id=&quot;listUserLikeUsername&quot; resultType=&quot;com.jourwon.pojo.User&quot;&gt;　　&lt;bind name=&quot;pattern&quot; value=&quot;&#39;%&#39; + username + &#39;%&#39;&quot; /&gt;　　select id,sex,age,username,password from person where username LIKE #&#123;pattern&#125;&lt;/select&gt;</code></pre><h2 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h2><h4 id="在mapper中如何传递多个参数"><a href="#在mapper中如何传递多个参数" class="headerlink" title="在mapper中如何传递多个参数"></a>在mapper中如何传递多个参数</h4><h5 id="方法1：顺序传参法"><a href="#方法1：顺序传参法" class="headerlink" title="方法1：顺序传参法"></a>方法1：顺序传参法</h5><pre><code class="xml">public User selectUser(String name, int deptId);&lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;    select * from user    where user_name = #&#123;0&#125; and dept_id = #&#123;1&#125;&lt;/select&gt;</code></pre><p>#{}里面的数字代表传入参数的顺序。</p><p>这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错。</p><h5 id="方法2：-Param注解传参法"><a href="#方法2：-Param注解传参法" class="headerlink" title="方法2：@Param注解传参法"></a>方法2：@Param注解传参法</h5><pre><code class="xml">public User selectUser(@Param(&quot;userName&quot;) String name, int @Param(&quot;deptId&quot;) deptId);&lt;select id=&quot;selectUser&quot; resultMap=&quot;UserResultMap&quot;&gt;    select * from user    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;&lt;/select&gt;</code></pre><p>#{}里面的名称对应的是注解@Param括号里面修饰的名称。</p><p>这种方法在参数不多的情况还是比较直观的，推荐使用。</p><h5 id="方法3：Map传参法"><a href="#方法3：Map传参法" class="headerlink" title="方法3：Map传参法"></a>方法3：Map传参法</h5><pre><code class="java">public User selectUser(Map&lt;String, Object&gt; params);&lt;select id=&quot;selectUser&quot; parameterType=&quot;java.util.Map&quot; resultMap=&quot;UserResultMap&quot;&gt;    select * from user    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;&lt;/select&gt;</code></pre><p>#{}里面的名称对应的是Map里面的key名称。</p><p>这种方法适合传递多个参数，且参数易变能灵活传递的情况。</p><h5 id="方法4：Java-Bean传参法"><a href="#方法4：Java-Bean传参法" class="headerlink" title="方法4：Java Bean传参法"></a>方法4：Java Bean传参法</h5><pre><code class="java">public User selectUser(User user);&lt;select id=&quot;selectUser&quot; parameterType=&quot;com.jourwon.pojo.User&quot; resultMap=&quot;UserResultMap&quot;&gt;    select * from user    where user_name = #&#123;userName&#125; and dept_id = #&#123;deptId&#125;&lt;/select&gt;</code></pre><p>#{}里面的名称对应的是User类里面的成员属性。这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h3 id="Mapper-编写有哪几种方式？"><a href="#Mapper-编写有哪几种方式？" class="headerlink" title="Mapper 编写有哪几种方式？"></a>Mapper 编写有哪几种方式？</h3><p>第一种：接口实现类继承 SqlSessionDaoSupport：使用此种方法需要编写mapper 接口，mapper 接口实现类、mapper.xml 文件。</p><p>（1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置</p><pre><code class="xml">&lt;mappers&gt;    &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;    &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;&lt;/mappers&gt;</code></pre></li></ul><p>  （2）定义 mapper 接口</p><p>  （3）实现类集成 SqlSessionDaoSupport</p><p>  mapper 方法中可以 this.getSqlSession()进行数据增删改查。</p><p>  （4）spring 配置</p><pre><code class="xml">&lt;bean id=&quot; &quot; class=&quot;mapper 接口的实现&quot;&gt;    &lt;property name=&quot;sqlSessionFactory&quot;    ref=&quot;sqlSessionFactory&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><p>  第二种：使用 org.mybatis.spring.mapper.MapperFactoryBean：</p><p>  （1）在 sqlMapConfig.xml 中配置 mapper.xml 的位置，如果 mapper.xml 和mappre 接口的名称相同且在同一个目录，这里可以不用配置</p><pre><code class="xml">&lt;mappers&gt;    &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;    &lt;mapper resource=&quot;mapper.xml 文件的地址&quot; /&gt;&lt;/mappers&gt;</code></pre><p>  （2）定义 mapper 接口：</p><p>  （3）mapper.xml 中的 namespace 为 mapper 接口的地址</p><p>  （4）mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致</p><p>  （5）Spring 中定义</p><pre><code class="xml">&lt;bean id=&quot;&quot; class=&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;&gt;    &lt;property name=&quot;mapperInterface&quot; value=&quot;mapper 接口地址&quot; /&gt;    &lt;property name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot; /&gt;&lt;/bean&gt;</code></pre><p>  第三种：使用 mapper 扫描器：</p><p>  第三种：使用 mapper 扫描器：</p><p>  （1）mapper.xml 文件编写：</p><p>  mapper.xml 中的 namespace 为 mapper 接口的地址；</p><p>  mapper 接口中的方法名和 mapper.xml 中的定义的 statement 的 id 保持一致；</p><p>  如果将 mapper.xml 和 mapper 接口的名称保持一致则不用在 sqlMapConfig.xml中进行配置。</p><p>  （2）定义 mapper 接口：</p><p>  注意 mapper.xml 的文件名和 mapper 的接口名称保持一致，且放在同一个目录</p><p>  （3）配置 mapper 扫描器：</p><pre><code class="xml">&lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;    &lt;property name=&quot;basePackage&quot; value=&quot;mapper 接口包地址    &quot;&gt;&lt;/property&gt;    &lt;property name=&quot;sqlSessionFactoryBeanName&quot;    value=&quot;sqlSessionFactory&quot;/&gt;&lt;/bean&gt;    </code></pre><p>  （4）使用扫描器后从 spring 容器中获取 mapper 的实现对象。</p><h3 id="什么是MyBatis的接口绑定？有哪些实现方式？"><a href="#什么是MyBatis的接口绑定？有哪些实现方式？" class="headerlink" title="什么是MyBatis的接口绑定？有哪些实现方式？"></a>什么是MyBatis的接口绑定？有哪些实现方式？</h3><p>  接口绑定，就是在MyBatis中任意定义接口，然后把接口里面的方法和SQL语句绑定，我们直接调用接口方法就可以，这样比起原来了SqlSession提供的方法我们可以有更加灵活的选择和设置。</p><p>  接口绑定有两种实现方式</p><p>  通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含Sql语句来绑定；</p><p>  通过xml里面写SQL来绑定， 在这种情况下，要指定xml映射文件里面的namespace必须为接口的全路径名。当Sql语句比较简单时候，用注解绑定， 当SQL语句比较复杂时候，用xml绑定，一般用xml绑定的比较多。</p><h4 id="使用MyBatis的mapper接口调用时有哪些要求？"><a href="#使用MyBatis的mapper接口调用时有哪些要求？" class="headerlink" title="使用MyBatis的mapper接口调用时有哪些要求？"></a>使用MyBatis的mapper接口调用时有哪些要求？</h4><p>  1、Mapper接口方法名和mapper.xml中定义的每个sql的id相同。</p><p>  2、Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同。</p><p>  3、Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同。</p><p>  4、Mapper.xml文件中的namespace即是mapper接口的类路径。</p><p>  <strong>最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗</strong><br>  Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。</p><p>  Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。</p><p>  Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。</p><p>  <strong>Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？</strong><br>  不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。</p><p>  原因就是namespace+id是作为Map&lt;String, MappedStatement&gt;的key使用的，如果没有namespace，就剩下id，那么，id重复会导致数据互相覆盖。有了namespace，自然id就可以重复，namespace不同，namespace+id自然也就不同。</p><p>  <strong>简述Mybatis的Xml映射文件和Mybatis内部数据结构之间的映射关系？</strong><br>  答：Mybatis将所有Xml配置信息都封装到All-In-One重量级对象Configuration内部。在Xml映射文件中，<parameterMap>标签会被解析为ParameterMap对象，其每个子元素会被解析为ParameterMapping对象。<resultMap>标签会被解析为ResultMap对象，其每个子元素会被解析为ResultMapping对象。每一个<select>、<insert>、<update>、<delete>标签均会被解析为MappedStatement对象，标签内的sql会被解析为BoundSql对象。</p><p>  <strong>Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？</strong><br>  第一种是使用<resultMap>标签，逐一定义列名和对象属性名之间的映射关系。</p><p>  第二种是使用sql列的别名功能，将列别名书写为对象属性名，比如T_NAME AS NAME，对象属性名一般是name，小写，但是列名不区分大小写，Mybatis会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成T_NAME AS NaMe，Mybatis一样可以正常工作。</p><p>  有了列名与属性名的映射关系后，Mybatis通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回，那些找不到映射关系的属性，是无法完成赋值的。</p><p>  <strong>Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？</strong><br>  还有很多其他的标签，<resultMap>、<parameterMap>、<sql>、<include>、<selectKey>，加上动态sql的9个标签，trim|where|set|foreach|if|choose|when|otherwise|bind等，其中<sql>为sql片段标签，通过<include>标签引入sql片段，<selectKey>为不支持自增的主键生成策略标签。</p><p>  <strong>Mybatis映射文件中，如果A标签通过include引用了B标签的内容，请问，B标签能否定义在A标签的后面，还是说必须定义在A标签的前面？</strong><br>  虽然Mybatis解析Xml映射文件是按照顺序解析的，但是，被引用的B标签依然可以定义在任何地方，Mybatis都可以正确识别。</p><p>  原理是，Mybatis解析A标签，发现A标签引用了B标签，但是B标签尚未解析到，尚不存在，此时，Mybatis会将A标签标记为未解析状态，然后继续解析余下的标签，包含B标签，待所有标签解析完毕，Mybatis会重新解析那些被标记为未解析的标签，此时再解析A标签时，B标签已经存在，A标签也就可以正常解析完成了。</p><h2 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h2><p>  <strong>MyBatis实现一对一，一对多有几种方式，怎么操作的？</strong><br>  有联合查询和嵌套查询。联合查询是几个表联合查询，只查询一次，通过在resultMap里面的association，collection节点配置一对一，一对多的类就可以完成</p><p>  嵌套查询是先查一个表，根据这个表里面的结果的外键id，去再另外一个表里面查询数据，也是通过配置association，collection，但另外一个表的查询通过select节点配置。</p><p>  <strong>Mybatis是否可以映射Enum枚举类？</strong><br>  Mybatis可以映射枚举类，不单可以映射枚举类，Mybatis可以映射任何对象到表的一列上。映射方式为自定义一个TypeHandler，实现TypeHandler的setParameter()和getResult()接口方法。</p><p>  TypeHandler有两个作用，一是完成从javaType至jdbcType的转换，二是完成jdbcType至javaType的转换，体现为setParameter()和getResult()两个方法，分别代表设置sql问号占位符参数和获取列查询结果。</p><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p>  <strong>Mybatis动态sql是做什么的？都有哪些动态sql？能简述一下动态sql的执行原理不？</strong><br>  Mybatis动态sql可以让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能，Mybatis提供了9种动态sql标签trim|where|set|foreach|if|choose|when|otherwise|bind。</p><p>  其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。</p><h2 id="插件模块"><a href="#插件模块" class="headerlink" title="插件模块"></a>插件模块</h2><p>  <strong>Mybatis是如何进行分页的？分页插件的原理是什么？</strong><br>  Mybatis使用RowBounds对象进行分页，它是针对ResultSet结果集执行的内存分页，而非物理分页，可以在sql内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。</p><p>  分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。</p><p>  举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10</p><p>  <strong>简述Mybatis的插件运行原理，以及如何编写一个插件。</strong><br>  Mybatis仅可以编写针对ParameterHandler、ResultSetHandler、StatementHandler、Executor这4种接口的插件，Mybatis使用JDK的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这4种接口对象的方法时，就会进入拦截方法，具体就是InvocationHandler的invoke()方法，当然，只会拦截那些你指定需要拦截的方法。</p><p>  实现Mybatis的Interceptor接口并复写intercept()方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。</p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>  <strong>Mybatis的一级、二级缓存</strong><br>  1）一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当 Session flush 或 close 之后，该 Session 中的所有 Cache 就将清空，默认打开一级缓存。</p><p>  2）二级缓存与一级缓存其机制相同，默认也是采用 PerpetualCache，HashMap 存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源，如 Ehcache。默认不打开二级缓存，要开启二级缓存，使用二级缓存属性类需要实现Serializable序列化接口(可用来保存对象的状态),可在它的映射文件中配置<cache/> ；</p><p>  3）对于缓存数据更新机制，当某一个作用域(一级缓存 Session/二级缓存Namespaces)的进行了C/U/D 操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>]]></content>
      
      
      <categories>
          
          <category> Mybatis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
